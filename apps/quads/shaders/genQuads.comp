#version 430 core

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(binding = 0, rgba16f) readonly uniform image2D positionMap;
layout(binding = 1, rgba16f) readonly uniform image2D normalMap;
layout(binding = 2) uniform sampler2D depthMap;

layout(std430, binding = 0) buffer VertexBuffer {
    vec4 vertices[];
};

layout(std430, binding = 1) buffer IndexBuffer {
    uint indices[];
};

// layout(std430, binding = 2) buffer TexCoordBuffer {
//     vec2 texCoords[];
// };

uniform vec2 screenSize;

uniform mat4 viewInverse;
uniform mat4 projectionInverse;

uniform float near;
uniform float far;

uniform int surfelSize;

#define VERTICES_IN_A_QUAD 4

vec3 ndcToView(vec2 ndc, float depth) {
    vec4 ndcPos;
    ndcPos.xy = ndc;
    ndcPos.z = 2.0 * depth - 1.0;
    ndcPos.w = 1.0;

    vec4 viewCoord = projectionInverse * ndcPos;
    viewCoord = viewCoord / viewCoord.w;
    return viewCoord.xyz;
}

vec3 viewToWorld(vec3 viewspaceCoord) {
    vec4 viewCoord = viewInverse * vec4(viewspaceCoord, 1.0);
    viewCoord = viewCoord / viewCoord.w;
    return viewCoord.xyz;
}

vec3 rotatePoint(vec3 point, vec3 center, vec3 axis, float angle) {
    vec3 direction = point - center;
    float s = sin(angle);
    float c = cos(angle);
    float t = 1.0 - c;
    float x = axis.x;
    float y = axis.y;
    float z = axis.z;
    mat3 rotationMatrix = mat3(
        t * x * x + c, t * x * y - s * z, t * x * z + s * y,
        t * x * y + s * z, t * y * y + c, t * y * z - s * x,
        t * x * z - s * y, t * y * z + s * x, t * z * z + c
    );
    return center + rotationMatrix * direction;
}

void main() {
    vec2 size = vec2(screenSize) / float(surfelSize);

    uint shaderIndex = uint(gl_GlobalInvocationID.y * size.x + gl_GlobalInvocationID.x);

    ivec2 surfelCoords = ivec2(gl_GlobalInvocationID.xy);

    ivec2 pixelCoordLowerLeft  = surfelSize * (ivec2(surfelCoords) + ivec2(0, 0));
    ivec2 pixelCoordLowerRight = surfelSize * (ivec2(surfelCoords) + ivec2(1, 0));
    ivec2 pixelCoordUpperLeft  = surfelSize * (ivec2(surfelCoords) + ivec2(0, 1));
    ivec2 pixelCoordUpperRight = surfelSize * (ivec2(surfelCoords) + ivec2(1, 1));
    ivec2 pixelCoordCenter     = (pixelCoordUpperLeft + pixelCoordLowerRight) / 2;

    vec2 pixelCoordUpperLeftNormalized = pixelCoordUpperLeft / screenSize;
    vec2 pixelCoordUpperRightNormalized = pixelCoordUpperRight / screenSize;
    vec2 pixelCoordLowerLeftNormalized = pixelCoordLowerLeft / screenSize;
    vec2 pixelCoordLowerRightNormalized = pixelCoordLowerRight / screenSize;
    vec2 centerPixelNormalized = pixelCoordCenter / screenSize;

    vec2 ndcUpperLeft  = 2.0 * pixelCoordUpperLeftNormalized - 1.0;
    vec2 ndcUpperRight = 2.0 * pixelCoordUpperRightNormalized - 1.0;
    vec2 ndcLowerLeft  = 2.0 * pixelCoordLowerLeftNormalized - 1.0;
    vec2 ndcLowerRight = 2.0 * pixelCoordLowerRightNormalized - 1.0;
    vec2 centerPixel = 2.0 * centerPixelNormalized - 1.0;

    // vec3 positionUpperLeft  = imageLoad(positionMap, pixelCoordUpperLeft).xyz;
    // vec3 positionUpperRight = imageLoad(positionMap, pixelCoordUpperRight).xyz;
    // vec3 positionLowerLeft  = imageLoad(positionMap, pixelCoordLowerLeft).xyz;
    // vec3 positionLowerRight = imageLoad(positionMap, pixelCoordLowerRight).xyz;

    // vec3 normalUpperLeft  = normalize(imageLoad(normalMap, pixelCoordUpperLeft).xyz);
    // vec3 normalUpperRight = normalize(imageLoad(normalMap, pixelCoordUpperRight).xyz);
    // vec3 normalLowerLeft  = normalize(imageLoad(normalMap, pixelCoordLowerLeft).xyz);
    // vec3 normalLowerRight = normalize(imageLoad(normalMap, pixelCoordLowerRight).xyz);

    float depthUpperLeft  = texelFetch(depthMap, pixelCoordUpperLeft, 0).x;
    float depthUpperRight = texelFetch(depthMap, pixelCoordUpperRight, 0).x;
    float depthLowerLeft  = texelFetch(depthMap, pixelCoordLowerLeft, 0).x;
    float depthLowerRight = texelFetch(depthMap, pixelCoordLowerRight, 0).x;
    float depthCenter     = texelFetch(depthMap, pixelCoordCenter, 0).x;

    // move quad so it is centered at the average depth
    // float avgDepth = 0.0;
    // for (int i = pixelCoordUpperLeft.x; i < pixelCoordUpperRight.x; i++) {
    //     for (int j = pixelCoordLowerLeft.y; j < pixelCoordUpperLeft.y; j++) {
    //         avgDepth += texelFetch(depthMap, ivec2(i, j), 0).x;
    //     }
    // }
    // avgDepth /= float(surfelSize * surfelSize);

    // give the same depth for now
    vec3 viewCoordUpperLeft  = ndcToView(ndcUpperLeft, depthCenter);
    vec3 viewCoordUpperRight = ndcToView(ndcUpperRight, depthCenter);
    vec3 viewCoordLowerLeft  = ndcToView(ndcLowerLeft, depthCenter);
    vec3 viewCoordLowerRight = ndcToView(ndcLowerRight, depthCenter);
    vec3 viewCoordCenter     = ndcToView(centerPixel, depthCenter);

    // rotate quad around the center so that it is oriented at average normal
    vec3 avgNormal = vec3(0.0);
    for (int i = pixelCoordUpperLeft.x; i < pixelCoordUpperRight.x; i++) {
        for (int j = pixelCoordLowerLeft.y; j < pixelCoordUpperLeft.y; j++) {
            avgNormal += imageLoad(normalMap, ivec2(i, j)).xyz;
        }
    }
    avgNormal /= float(surfelSize * surfelSize);
    avgNormal = normalize(avgNormal);
    // vec3 avgNormal = normalize(imageLoad(normalMap, pixelCoordCenter).xyz);

    vec3 oldNormal = normalize(cross(viewCoordUpperRight - viewCoordLowerRight, viewCoordLowerLeft - viewCoordLowerRight));
    vec3 axis = cross(avgNormal, oldNormal);
    float angle = acos(dot(oldNormal, avgNormal));

    viewCoordUpperLeft = rotatePoint(viewCoordUpperLeft, viewCoordCenter, axis, angle);
    viewCoordUpperRight = rotatePoint(viewCoordUpperRight, viewCoordCenter, axis, angle);
    viewCoordLowerLeft = rotatePoint(viewCoordLowerLeft, viewCoordCenter, axis, angle);
    viewCoordLowerRight = rotatePoint(viewCoordLowerRight, viewCoordCenter, axis, angle);

    vec4 vertexCoordUpperLeft  = vec4(viewToWorld(viewCoordUpperLeft), 1.0);
    vec4 vertexCoordUpperRight = vec4(viewToWorld(viewCoordUpperRight), 1.0);
    vec4 vertexCoordLowerLeft  = vec4(viewToWorld(viewCoordLowerLeft), 1.0);
    vec4 vertexCoordLowerRight = vec4(viewToWorld(viewCoordLowerRight), 1.0);

    uint vertexIndexUpperLeft  = shaderIndex * VERTICES_IN_A_QUAD + 0;
    uint vertexIndexUpperRight = shaderIndex * VERTICES_IN_A_QUAD + 1;
    uint vertexIndexLowerLeft  = shaderIndex * VERTICES_IN_A_QUAD + 2;
    uint vertexIndexLowerRight = shaderIndex * VERTICES_IN_A_QUAD + 3;

    vertices[vertexIndexUpperLeft] = vertexCoordUpperLeft;
    vertices[vertexIndexUpperRight] = vertexCoordUpperRight;
    vertices[vertexIndexLowerLeft] = vertexCoordLowerLeft;
    vertices[vertexIndexLowerRight] = vertexCoordLowerRight;

    /************************

            ul -- ur
            |   / |
            | /   |
            ll -- lr

    ************************/
    indices[shaderIndex * 6 + 0] = vertexIndexUpperLeft;
    indices[shaderIndex * 6 + 1] = vertexIndexUpperRight;
    indices[shaderIndex * 6 + 2] = vertexIndexLowerLeft;

    indices[shaderIndex * 6 + 3] = vertexIndexUpperRight;
    indices[shaderIndex * 6 + 4] = vertexIndexLowerRight;
    indices[shaderIndex * 6 + 5] = vertexIndexLowerLeft;
}
