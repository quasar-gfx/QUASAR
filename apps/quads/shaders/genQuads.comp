#version 430 core

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(binding = 0, rgba16f) readonly uniform image2D positionMap;
layout(binding = 1, rgba16f) readonly uniform image2D normalMap;
layout(binding = 2) uniform sampler2D depthMap;

layout(std430, binding = 0) buffer VertexBuffer {
    vec4 vertices[];
};

layout(std430, binding = 1) buffer IndexBuffer {
    uint indices[];
};

// layout(std430, binding = 2) buffer TexCoordBuffer {
//     vec2 texCoords[];
// };

uniform vec2 screenSize;

uniform mat4 viewInverse;
uniform mat4 projectionInverse;

uniform float near;
uniform float far;

uniform int surfelSize;

#define VERTICES_IN_A_QUAD 4

vec3 projectToWorld(vec2 ndc, float depth) {
    vec4 ndcPos;
    ndcPos.xy = ndc;
    ndcPos.z = 2.0 * depth - 1.0;
    ndcPos.w = 1.0;

    vec4 worldCoord = viewInverse * projectionInverse * ndcPos;
    worldCoord = worldCoord / worldCoord.w;

    return worldCoord.xyz;
}

void main() {
    vec2 size = vec2(screenSize) / float(surfelSize);

    uint shaderIndex = uint(gl_GlobalInvocationID.y * size.x + gl_GlobalInvocationID.x);

    ivec2 surfelCoords = ivec2(gl_GlobalInvocationID.xy);

    ivec2 pixelCoordsUpperLeft  = surfelSize * ivec2(surfelCoords);
    ivec2 pixelCoordsUpperRight = surfelSize * ivec2(surfelCoords.x + 1, surfelCoords.y);
    ivec2 pixelCoordsLowerLeft  = surfelSize * ivec2(surfelCoords.x, surfelCoords.y + 1);
    ivec2 pixelCoordsLowerRight = surfelSize * ivec2(surfelCoords.x + 1, surfelCoords.y + 1);

    vec2 pixelCoordsUpperLeftNormalized = pixelCoordsUpperLeft / screenSize;
    vec2 pixelCoordsUpperRightNormalized = pixelCoordsUpperRight / screenSize;
    vec2 pixelCoordsLowerLeftNormalized = pixelCoordsLowerLeft / screenSize;
    vec2 pixelCoordsLowerRightNormalized = pixelCoordsLowerRight / screenSize;

    vec2 ndcUpperLeft  = 2.0 * pixelCoordsUpperLeftNormalized - 1.0;
    vec2 ndcUpperRight = 2.0 * pixelCoordsUpperRightNormalized - 1.0;
    vec2 ndcLowerLeft  = 2.0 * pixelCoordsLowerLeftNormalized - 1.0;
    vec2 ndcLowerRight = 2.0 * pixelCoordsLowerRightNormalized - 1.0;

    vec3 positionUpperLeft  = imageLoad(positionMap, pixelCoordsUpperLeft).xyz;
    vec3 positionUpperRight = imageLoad(positionMap, pixelCoordsUpperRight).xyz;
    vec3 positionLowerLeft  = imageLoad(positionMap, pixelCoordsLowerLeft).xyz;
    vec3 positionLowerRight = imageLoad(positionMap, pixelCoordsLowerRight).xyz;

    vec3 normalUpperLeft  = normalize(imageLoad(normalMap, pixelCoordsUpperLeft).xyz);
    vec3 normalUpperRight = normalize(imageLoad(normalMap, pixelCoordsUpperRight).xyz);
    vec3 normalLowerLeft  = normalize(imageLoad(normalMap, pixelCoordsLowerLeft).xyz);
    vec3 normalLowerRight = normalize(imageLoad(normalMap, pixelCoordsLowerRight).xyz);

    // float depthUpperLeft  = texelFetch(depthMap, pixelCoordsUpperLeft, 0).r;
    // float depthUpperRight = texelFetch(depthMap, pixelCoordsUpperRight, 0).r;
    // float depthLowerLeft  = texelFetch(depthMap, pixelCoordsLowerLeft, 0).r;
    // float depthLowerRight = texelFetch(depthMap, pixelCoordsLowerRight, 0).r;

    // // move quad so it is centered at the average depth
    // float avgDepth = 0.0;
    // for (int i = pixelCoordsUpperLeft.x; i < pixelCoordsLowerRight.x; i++) {
    //     for (int j = pixelCoordsUpperLeft.y; j < pixelCoordsLowerRight.y; j++) {
    //         avgDepth += texelFetch(depthMap, ivec2(i, j), 0).r;
    //     }
    // }
    // avgDepth /= float(surfelSize * surfelSize);
    ivec2 centerPixel = (pixelCoordsUpperLeft + pixelCoordsLowerRight) / 2;
    float avgDepth = texelFetch(depthMap, centerPixel, 0).r;

    // give the same depth for now
    vec3 worldCoordUpperLeft  = projectToWorld(ndcUpperLeft, avgDepth);
    vec3 worldCoordUpperRight = projectToWorld(ndcUpperRight, avgDepth);
    vec3 worldCoordLowerLeft  = projectToWorld(ndcLowerLeft, avgDepth);
    vec3 worldCoordLowerRight = projectToWorld(ndcLowerRight, avgDepth);

    // rotate quad around the center so that it is oriented at average normal
    vec3 avgNormal = vec3(0.0);
    for (int i = pixelCoordsUpperLeft.x; i < pixelCoordsLowerRight.x; i++) {
        for (int j = pixelCoordsUpperLeft.y; j < pixelCoordsLowerRight.y; j++) {
            avgNormal += imageLoad(normalMap, ivec2(i, j)).xyz;
        }
    }
    avgNormal /= float(surfelSize * surfelSize);
    avgNormal = normalize(avgNormal);

    vec3 tangent = normalize(worldCoordUpperRight - worldCoordUpperLeft);
    vec3 bitangent = cross(avgNormal, tangent);
    mat3 rotation = mat3(tangent, bitangent, avgNormal);

    vec3 center = (worldCoordUpperLeft + worldCoordUpperRight + worldCoordLowerLeft + worldCoordLowerRight) / 4;
    worldCoordUpperLeft = rotation * (worldCoordUpperLeft - center) + center;
    worldCoordUpperRight = rotation * (worldCoordUpperRight - center) + center;
    worldCoordLowerLeft = rotation * (worldCoordLowerLeft - center) + center;
    worldCoordLowerRight = rotation * (worldCoordLowerRight - center) + center;

    vec4 vertexCoordUpperLeft  = vec4(worldCoordUpperLeft, 1.0);
    vec4 vertexCoordUpperRight = vec4(worldCoordUpperRight, 1.0);
    vec4 vertexCoordLowerLeft  = vec4(worldCoordLowerLeft, 1.0);
    vec4 vertexCoordLowerRight = vec4(worldCoordLowerRight, 1.0);

    uint vertexIndexUpperLeft  = shaderIndex * VERTICES_IN_A_QUAD + 0;
    uint vertexIndexUpperRight = shaderIndex * VERTICES_IN_A_QUAD + 1;
    uint vertexIndexLowerLeft  = shaderIndex * VERTICES_IN_A_QUAD + 2;
    uint vertexIndexLowerRight = shaderIndex * VERTICES_IN_A_QUAD + 3;

    // uint vertexIndexUpperLeft  = shaderIndex;
    vertices[vertexIndexUpperLeft] = vertexCoordUpperLeft;
    vertices[vertexIndexUpperRight] = vertexCoordUpperRight;
    vertices[vertexIndexLowerLeft] = vertexCoordLowerLeft;
    vertices[vertexIndexLowerRight] = vertexCoordLowerRight;

    /************************

            ul -- ur
            |   / |
            | /   |
            ll -- lr

    ************************/
    indices[shaderIndex * 6 + 0] = vertexIndexUpperLeft;
    indices[shaderIndex * 6 + 1] = vertexIndexUpperRight;
    indices[shaderIndex * 6 + 2] = vertexIndexLowerLeft;

    indices[shaderIndex * 6 + 3] = vertexIndexUpperRight;
    indices[shaderIndex * 6 + 4] = vertexIndexLowerRight;
    indices[shaderIndex * 6 + 5] = vertexIndexLowerLeft;
}
