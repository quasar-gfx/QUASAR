layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

struct Vertex {
    uint id;
    vec3 position;
    vec3 color;
    vec3 normal;
    vec2 texCoords;
    vec3 tangent;
    vec3 bitangent;
};

struct Block{
    float max;
    float min;
    uint arr[6];
    //float real[64]; // real value for depth
};

layout(std430, binding = 0) buffer VertexBuffer {
    Vertex vertices[];
};

layout(std430, binding = 1) buffer IndexBuffer {
    uint indices[];
};

layout(std430, binding = 2) buffer VertexBufferWireframe {
    Vertex verticesWireframe[];
};

layout(std430, binding = 3) buffer IndexBufferWireframe {
    uint indicesWireframe[];
};

layout(std430, binding = 4) buffer BC4Buffer {
    Block bc4buffer[];
};

const ivec2 blockSize = ivec2(8, 8);

uniform vec2 screenSize;
uniform vec2 depthMapSize;

uniform mat4 view;
uniform mat4 projection;
uniform mat4 viewInverse;
uniform mat4 projectionInverse;

uniform mat4 viewColor;
uniform mat4 viewInverseDepth;

uniform float near;
uniform float far;

uniform int surfelSize;

#define VERTICES_IN_A_QUAD  4
#define INDICES_IN_A_QUAD   6

vec3 ndcToView(mat4 projectionInverse, vec2 ndc, float depth) {
    vec4 ndcPos;
    ndcPos.xy = ndc;
    ndcPos.z = 2.0 * depth - 1.0;
    ndcPos.w = 1.0;

    vec4 viewCoord = projectionInverse * ndcPos;
    viewCoord = viewCoord / viewCoord.w;
    return viewCoord.xyz;
}

vec3 viewToWorld(mat4 viewInverse, vec3 viewCoord) {
    vec4 worldCoord = viewInverse * vec4(viewCoord, 1.0);
    worldCoord = worldCoord / worldCoord.w;
    return worldCoord.xyz;
}

vec3 worldToView(mat4 view, vec3 worldCoord) {
    vec4 viewCoord = view * vec4(worldCoord, 1.0);
    viewCoord = viewCoord / viewCoord.w;
    return viewCoord.xyz;
}

vec2 viewToNDC(mat4 projection, vec3 viewCoord) {
    vec4 ndcCoord = projection * vec4(viewCoord, 1.0);
    ndcCoord = ndcCoord / ndcCoord.w;
    return ndcCoord.xy;
}

vec2 viewToScreen(mat4 projection, vec3 viewCoord) {
    vec2 ndc = viewToNDC(projection, viewCoord).xy;
    vec2 uv = (ndc + 1.0) / 2.0;
    return uv;
}

float LinearizeDepth(float depth) {
    float z = depth * 2.0 - 1.0; // back to NDC
    return (2.0 * near * far) / (far + near - z * (far - near));
}

float UnLinearizeDepth(float depth) {
    depth *= far;
    depth = max(depth, near);
    float z = (depth * (far + near) - 2.0 * near * far) / (depth * (far - near));
    return (z + 1.0) / 2.0;
}

float sampleBC4Buffer(vec2 pixelCoordNormalized) {
    ivec2 pixelCoord = ivec2(pixelCoordNormalized * depthMapSize); // normalized coord to integer pixel coord
    ivec2 blockCoord = pixelCoord / blockSize;
    ivec2 pixelInBlock = pixelCoord % blockSize;

    uint blockIndex = blockCoord.y * (uint(depthMapSize.x) / blockSize.x) + blockCoord.x; //index of this block in the BC4 buffer
    Block compressedBlock = bc4buffer[blockIndex];

    float maxVal = compressedBlock.max;
    float minVal = compressedBlock.min;

    uint pixelIndex = pixelInBlock.y * blockSize.x + pixelInBlock.x;
    uint globalBitIndex = pixelIndex * 3;
    uint uintIndex = globalBitIndex / 32; // 0-5
    uint bitOffset = globalBitIndex % 32; // 0-31

    uint index;
    if (bitOffset <= 29) {
        // Normal case: all 3 bits are in the current uint
        index = (compressedBlock.arr[uintIndex] >> (29 - bitOffset)) & 0x7u;
    } else {
        // Split case: the 3 bits are split across two uints
        uint bitsInCurrent = 32 - bitOffset;
        uint bitsInNext = 3 - bitsInCurrent;

        // Get the bits from the current uint
        uint mask = 0;
        if (bitsInCurrent == 1) mask = 1; // 0b01
        if (bitsInCurrent == 2) mask = 3; // 0b11
        uint upperBits = compressedBlock.arr[uintIndex] & (mask);

        // Get the bits from the next uint (with wraparound)
        uint lowerBits = compressedBlock.arr[(uintIndex + 1) % 6] >> (32 - bitsInNext);

        // Combine the bits
        index = (upperBits << bitsInNext) | lowerBits;
    }

    index = index & 0x7u; // Ensure index is a valid 3-bit number (0-7)

    float t = float(index) / 7.0;

    float depth = mix(minVal, maxVal, t);

    return depth;
}

void main() {
    vec2 size = vec2(screenSize) / float(surfelSize);

    vec2 surfelCoord = vec2(gl_GlobalInvocationID.xy);
    if (surfelCoord.x >= screenSize.x || surfelCoord.y >= screenSize.y) {
        return;
    }

    vec2 pixelCoord = surfelSize * (surfelCoord + vec2(0.5, 0.5));
    vec2 uv = vec2(pixelCoord) / screenSize;

    float depth = sampleBC4Buffer(uv);

    vec2 ndc = 2.0 * uv - 1.0;
    vec3 viewCoord = ndcToView(projectionInverse, ndc, depth);
    vec3 worldCoord = viewToWorld(viewInverseDepth, viewCoord);

    uint shaderIndex = uint(gl_GlobalInvocationID.y * size.x + gl_GlobalInvocationID.x);
    vertices[shaderIndex].position = worldCoord;
    vertices[shaderIndex].color = vec3(1.0, 1.0, 1.0);
    vertices[shaderIndex].texCoords = viewToScreen(projection, viewCoord);

    // Copy vertex data to wireframe buffer
    verticesWireframe[shaderIndex] = vertices[shaderIndex];

    if (pixelCoord.x < screenSize.x - surfelSize && pixelCoord.y < screenSize.y - surfelSize) {
        /************************

                tl -- tr
                |    / |
                |   c  |
                |  /   |
                bl -- br

        ************************/
        uint bottomLeftIdx = shaderIndex;
        uint bottomRightIdx = shaderIndex + 1;
        uint topLeftIdx = shaderIndex + uint(size.x);
        uint topRightIdx = shaderIndex + uint(size.x) + 1;

        indices[shaderIndex * INDICES_IN_A_QUAD + 0] = topLeftIdx;
        indices[shaderIndex * INDICES_IN_A_QUAD + 1] = bottomLeftIdx;
        indices[shaderIndex * INDICES_IN_A_QUAD + 2] = topRightIdx;

        indices[shaderIndex * INDICES_IN_A_QUAD + 3] = topRightIdx;
        indices[shaderIndex * INDICES_IN_A_QUAD + 4] = bottomLeftIdx;
        indices[shaderIndex * INDICES_IN_A_QUAD + 5] = bottomRightIdx;

        // Wireframe mesh indices
        indicesWireframe[shaderIndex * INDICES_IN_A_QUAD + 0] = indices[shaderIndex * INDICES_IN_A_QUAD + 0];
        indicesWireframe[shaderIndex * INDICES_IN_A_QUAD + 1] = indices[shaderIndex * INDICES_IN_A_QUAD + 1];
        indicesWireframe[shaderIndex * INDICES_IN_A_QUAD + 2] = indices[shaderIndex * INDICES_IN_A_QUAD + 2];
        indicesWireframe[shaderIndex * INDICES_IN_A_QUAD + 3] = indices[shaderIndex * INDICES_IN_A_QUAD + 3];
        indicesWireframe[shaderIndex * INDICES_IN_A_QUAD + 4] = indices[shaderIndex * INDICES_IN_A_QUAD + 4];
        indicesWireframe[shaderIndex * INDICES_IN_A_QUAD + 5] = indices[shaderIndex * INDICES_IN_A_QUAD + 5];
    }
}
