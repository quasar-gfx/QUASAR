layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(binding = 0) uniform sampler2D depthMap;

struct Vertex {
    uint id;
    vec3 position;
    vec3 color;
    vec3 normal;
    vec2 texCoords;
    vec3 tangent;
    vec3 bitangent;
};

layout(std430, binding = 0) buffer VertexBuffer {
    Vertex vertices[];
};

layout(std430, binding = 1) buffer IndexBuffer {
    uint indices[];
};

uniform vec2 screenSize;

uniform mat4 viewColor;
uniform mat4 viewInverseDepth;
uniform mat4 projection;
uniform mat4 projectionInverse;

uniform float near;
uniform float far;

uniform int surfelSize;

#define VERTICES_IN_A_QUAD 4

vec3 ndcToView(vec2 ndc, float depth) {
    vec4 ndcPos;
    ndcPos.xy = ndc;
    ndcPos.z = 2.0 * depth - 1.0;
    ndcPos.w = 1.0;

    vec4 viewCoord = projectionInverse * ndcPos;
    viewCoord = viewCoord / viewCoord.w;
    return viewCoord.xyz;
}

vec3 viewToWorld(mat4 viewInverse, vec3 viewspaceCoord) {
    vec4 worldCoord = viewInverse * vec4(viewspaceCoord, 1.0);
    worldCoord = worldCoord / worldCoord.w;
    return worldCoord.xyz;
}

vec3 worldToView(mat4 view, vec3 worldCoord) {
    vec4 viewCoord = view * vec4(worldCoord, 1.0);
    viewCoord = viewCoord / viewCoord.w;
    return viewCoord.xyz;
}

vec2 viewToNDC(vec3 viewCoord) {
    vec4 ndcCoord = projection * vec4(viewCoord, 1.0);
    ndcCoord = ndcCoord / ndcCoord.w;
    return ndcCoord.xy;
}

vec2 ndcToScreen(vec2 ndc) {
    return (ndc + 1.0) / 2.0;
}

vec2 worldToScreen(mat4 view, vec3 worldCoord) {
    vec2 ndc = viewToNDC(worldToView(view, worldCoord));
    return ndcToScreen(ndc);
}

float LinearizeDepth(float depth) {
    float z = depth * 2.0 - 1.0; // back to NDC
    return (2.0 * near * far) / (far + near - z * (far - near));
}

float UnLinearizeDepth(float depth) {
    depth *= far;
    depth = max(depth, near);
    float z = (depth * (far + near) - 2.0 * near * far) / (depth * (far - near));
    return (z + 1.0) / 2.0;
}

float sampleDepth(sampler2D depthMap, ivec2 pixelCoord) {
    vec2 sampleCoord = (vec2(pixelCoord) + 0.5) / screenSize;
    float depth = texture(depthMap, sampleCoord).r;
    depth = UnLinearizeDepth(depth);
    depth = min(depth, 0.99999);
    return depth;
}

void main() {
    vec2 size = vec2(screenSize) / float(surfelSize);

    uint shaderIndex = uint(gl_GlobalInvocationID.y * size.x + gl_GlobalInvocationID.x);

    ivec2 surfelCoords = ivec2(gl_GlobalInvocationID.xy);

    /************************

            ul -- ur
            |    / |
            |   c  |
            |  /   |
       -->  ll -- lr

    ************************/

    ivec2 pixelCoordLowerLeft  = surfelSize * (ivec2(surfelCoords) + ivec2(0, 0));
    ivec2 pixelCoordLowerRight = surfelSize * (ivec2(surfelCoords) + ivec2(1, 0));
    ivec2 pixelCoordUpperLeft  = surfelSize * (ivec2(surfelCoords) + ivec2(0, 1));
    ivec2 pixelCoordUpperRight = surfelSize * (ivec2(surfelCoords) + ivec2(1, 1));
    // ivec2 pixelCoordCenter     = surfelSize * (ivec2(surfelCoords) + ivec2(0.5, 0.5));

    vec2 pixelCoordLowerLeftNormalized  = pixelCoordLowerLeft / screenSize;
    vec2 pixelCoordLowerRightNormalized = pixelCoordLowerRight / screenSize;
    vec2 pixelCoordUpperLeftNormalized  = pixelCoordUpperLeft / screenSize;
    vec2 pixelCoordUpperRightNormalized = pixelCoordUpperRight / screenSize;
    // vec2 pixelCoordCenterNormalized     = pixelCoordCenter / screenSize;

    float depthLowerLeft  = sampleDepth(depthMap, pixelCoordLowerLeft);
    float depthLowerRight = sampleDepth(depthMap, pixelCoordLowerRight);
    float depthUpperLeft  = sampleDepth(depthMap, pixelCoordUpperLeft);
    float depthUpperRight = sampleDepth(depthMap, pixelCoordUpperRight);
    // float depthCenter     = sampleDepth(depthMap, pixelCoordCenter);

    vec2 ndcLowerLeft  = 2.0 * pixelCoordLowerLeftNormalized - 1.0;
    vec2 ndcLowerRight = 2.0 * pixelCoordLowerRightNormalized - 1.0;
    vec2 ndcUpperLeft  = 2.0 * pixelCoordUpperLeftNormalized - 1.0;
    vec2 ndcUpperRight = 2.0 * pixelCoordUpperRightNormalized - 1.0;
    // vec2 ndcCenter     = 2.0 * pixelCoordCenterNormalized - 1.0;

    vec3 viewCoordLowerLeft  = ndcToView(ndcLowerLeft, depthLowerLeft);
    vec3 viewCoordLowerRight = ndcToView(ndcLowerRight, depthLowerRight);
    vec3 viewCoordUpperLeft  = ndcToView(ndcUpperLeft, depthUpperLeft);
    vec3 viewCoordUpperRight = ndcToView(ndcUpperRight, depthUpperRight);

    vec3 vertexCoordUpperLeft  = viewToWorld(viewInverseDepth, viewCoordUpperLeft);
    vec3 vertexCoordUpperRight = viewToWorld(viewInverseDepth, viewCoordUpperRight);
    vec3 vertexCoordLowerLeft  = viewToWorld(viewInverseDepth, viewCoordLowerLeft);
    vec3 vertexCoordLowerRight = viewToWorld(viewInverseDepth, viewCoordLowerRight);

    uint vertexIndexUpperLeft  = shaderIndex * VERTICES_IN_A_QUAD + 0;
    uint vertexIndexUpperRight = shaderIndex * VERTICES_IN_A_QUAD + 1;
    uint vertexIndexLowerLeft  = shaderIndex * VERTICES_IN_A_QUAD + 2;
    uint vertexIndexLowerRight = shaderIndex * VERTICES_IN_A_QUAD + 3;

    vertices[vertexIndexUpperLeft] .position = vertexCoordUpperLeft;
    vertices[vertexIndexUpperRight].position = vertexCoordUpperRight;
    vertices[vertexIndexLowerLeft] .position = vertexCoordLowerLeft;
    vertices[vertexIndexLowerRight].position = vertexCoordLowerRight;

    vertices[vertexIndexUpperLeft] .color = vec3(1.0, 1.0, 1.0);
    vertices[vertexIndexUpperRight].color = vec3(1.0, 1.0, 1.0);
    vertices[vertexIndexLowerLeft] .color = vec3(1.0, 1.0, 1.0);
    vertices[vertexIndexLowerRight].color = vec3(1.0, 1.0, 1.0);

    vertices[vertexIndexUpperLeft] .texCoords = worldToScreen(viewColor, vertexCoordUpperLeft);
    vertices[vertexIndexUpperRight].texCoords = worldToScreen(viewColor, vertexCoordUpperRight);
    vertices[vertexIndexLowerLeft] .texCoords = worldToScreen(viewColor, vertexCoordLowerLeft);
    vertices[vertexIndexLowerRight].texCoords = worldToScreen(viewColor, vertexCoordLowerRight);

    indices[shaderIndex * 6 + 0] = vertexIndexUpperLeft;
    indices[shaderIndex * 6 + 1] = vertexIndexUpperRight;
    indices[shaderIndex * 6 + 2] = vertexIndexLowerLeft;

    indices[shaderIndex * 6 + 3] = vertexIndexUpperRight;
    indices[shaderIndex * 6 + 4] = vertexIndexLowerRight;
    indices[shaderIndex * 6 + 5] = vertexIndexLowerLeft;
}
