layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

uniform vec2 depthMapSize;

uniform vec2 bc4DepthSize;

layout(binding = 0) uniform sampler2D depthMap;


struct Block{
    float max;
    float min;
    uint arr[6]; // 32 bits each
};

layout(std430, binding = 0) buffer BC4Buffer {
    Block bc4buffer[];
};

// Sample depth value from the depth map
float sampleDepth(sampler2D depthMap, ivec2 sampleCoord) {
    float depth = texelFetch(depthMap, sampleCoord, 0).r;
    //depth = clamp(depth, 0.0, 0.99999);
    return depth;
}

void main() {
    ivec2 blockPixelCoord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 startPixelCoord = 8 * blockPixelCoord;

    float arr[64];
    float minDepth = 1.0;
    float maxDepth = 0.0;

    // Sample 8x8 block and find min/max
    for(int i = 0; i < 64; i++) {
        ivec2 offset = ivec2(i % 8, i / 8);
        arr[i] = sampleDepth(depthMap, startPixelCoord + offset);
        minDepth = min(minDepth, arr[i]);
        maxDepth = max(maxDepth, arr[i]);
    }

    Block block;
    block.min = minDepth;
    block.max = maxDepth;

    // Calculate interpolated values
    float interpVals[8];
    interpVals[0] = minDepth;
    interpVals[1] = maxDepth;
    for(int i = 1; i < 7; i++) {
        interpVals[i+1] = mix(minDepth, maxDepth, i / 7.0);
    }

    // Assign indices and pack bits
    for(int i = 0; i < 6; i++) {
        uint bits = 0u;
        for(int j = 0; j < 10 && (i * 10 + j) < 64; j++) {
            int pixelIndex = i * 10 + j;
            float pixelValue = arr[pixelIndex];
            
            // Find closest interpolated value
            int bestIndex = 0;
            float minDiff = abs(pixelValue - interpVals[0]);
            for(int k = 1; k < 8; k++) {
                float diff = abs(pixelValue - interpVals[k]);
                if(diff < minDiff) {
                    minDiff = diff;
                    bestIndex = k;
                }
            }
            
            // Pack 3-bit index into the 32-bit integer
            bits |= uint(bestIndex) << (j * 3);
        }
        block.arr[i] = bits;
    }
     // Store the compressed block directly in the buffer
    uint index = uint(blockPixelCoord.y) * uint(bc4DepthSize.x) + uint(blockPixelCoord.x);
    bc4buffer[index] = block;
}