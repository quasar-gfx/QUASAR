layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

uniform vec2 depthMapSize;

uniform vec2 bc4DepthSize;

layout(binding = 0) uniform sampler2D depthMap;


struct Block{
    float max;
    float min; // 32 bits
    uint arr[6]; // 32 bits each
};

layout(std430, binding = 0) buffer BC4Buffer {
    Block bc4buffer[];
};

// Sample depth value from the depth map
float sampleDepth(sampler2D depthMap, ivec2 sampleCoord) {
    float depth = texelFetch(depthMap, sampleCoord, 0).r;
    //depth = clamp(depth, 0.0, 0.99999);
    return depth;
}

void main() {
    ivec2 blockPixelCoord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 startPixelCoord = 8 * blockPixelCoord;

    float blockData[64];
    float minDepth = 1.0;
    float maxDepth = 0.0;

    // Sample 8x8 block and find min/max
    for(int y = 0; y < 8; y++) {
        for(int x = 0; x < 8; x++) {
            ivec2 sampleCoord = startPixelCoord + ivec2(x, y);
            if(all(lessThan(sampleCoord, ivec2(depthMapSize)))) {
                float depth = sampleDepth(depthMap, sampleCoord);
                blockData[y * 8 + x] = depth;
                minDepth = min(minDepth, depth);
                maxDepth = max(maxDepth, depth);
            }
        }
    }

    // Calculate interpolated values
    float interpVals[8];
    interpVals[0] = minDepth;
    interpVals[1] = maxDepth;
    for(int i = 1; i < 7; i++) {
        interpVals[i+1] = mix(minDepth, maxDepth, i / 7.0);
    }

    // Compress block data
    Block block;
    block.max = maxDepth;
    block.min = minDepth;

    uint bits[6] = uint[](0u, 0u, 0u, 0u, 0u, 0u);
    int bitIndex = 0;

    for(int i = 0; i < 64; i++) {
        float pixelValue = blockData[i];
        
        // Find closest interpolated value
        int bestIndex = 0;
        float minDiff = abs(pixelValue - interpVals[0]);
        for(int k = 1; k < 8; k++) {
            float diff = abs(pixelValue - interpVals[k]);
            if(diff < minDiff) {
                minDiff = diff;
                bestIndex = k;
            }
        }
        
        // Pack 3-bit index
        int uintIndex = bitIndex / 32;
        int bitOffset = bitIndex % 32;
        bits[uintIndex] |= uint(bestIndex) << bitOffset;
        
        // Handle overflow (when bit[] left bits <3)
        if(bitOffset > 29) {
            int overflow = bitOffset - 29;
            bits[uintIndex + 1] |= uint(bestIndex) >> (3 - overflow);
        }
        
        bitIndex += 3;
    }

    // Store packed data
    for(int i = 0; i < 6; i++) {
        block.arr[i] = bits[i];
    }

    // Write compressed block to output buffer
    uint blockIndex = uint(blockPixelCoord.y) * uint(bc4DepthSize.x) + uint(blockPixelCoord.x);
    bc4buffer[blockIndex] = block;
}