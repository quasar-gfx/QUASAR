layout(local_size_x = THREADS_PER_LOCALGROUP, local_size_y = THREADS_PER_LOCALGROUP, local_size_z = 1) in;

struct QuadMapData {
    vec3 normal;
    float depth;
    vec2 uv;
    ivec2 offset;
    uint size;
    bool flattened;
};

struct QuadMapDataPacked {
    uvec2 normalAndFlattenedAndSize;
    float depth;
    vec2 uv;
    uint offset;
};

struct Quad {
    vec3 bottomLeft;
    vec3 bottomRight;
    vec3 topLeft;
    vec3 topRight;
};

struct Quad1D {
    float bottomLeft;
    float bottomRight;
    float topLeft;
    float topRight;
};

struct Quad2D {
    vec2 bottomLeft;
    vec2 bottomRight;
    vec2 topLeft;
    vec2 topRight;
};

// a Quad subdivided into 4 smaller Quads
struct MultiQuad {
    vec3 bottomLeft;
    vec3 bottom;
    vec3 bottomRight;
    vec3 left;
    vec3 center;
    vec3 right;
    vec3 topLeft;
    vec3 top;
    vec3 topRight;
};

struct MultiQuad1D {
    float bottomLeft;
    float bottom;
    float bottomRight;
    float left;
    float center;
    float right;
    float topLeft;
    float top;
    float topRight;
};

struct MultiQuad2D {
    vec2 bottomLeft;
    vec2 bottom;
    vec2 bottomRight;
    vec2 left;
    vec2 center;
    vec2 right;
    vec2 topLeft;
    vec2 top;
    vec2 topRight;
};

struct Plane {
    vec3 normal;
    vec3 point;
};

struct PlaneEq {
    vec3 normal;
    float constant;
};

uniform vec2 remoteWindowSize;
uniform vec2 inputQuadMapSize;
uniform vec2 outputQuadMapSize;
uniform vec2 depthBufferSize;

uniform mat4 view;
uniform mat4 projection;
uniform mat4 viewInverse;
uniform mat4 projectionInverse;

uniform float near;
uniform float far;

uniform float flatThreshold;
uniform float proxySimilarityThreshold;

#define MAX_DEPTH 0.9999

const float epsilon = 1e-5;
const float surfelSize = 0.5;

const vec3 origin = vec3(0.0, 0.0, 0.0);
const vec3 forward = vec3(0.0, 0.0, -1.0);

layout(std430, binding = 0) buffer InputQuadMapBuffer {
    QuadMapDataPacked inputQuadMap[];
};

layout(std430, binding = 1) writeonly buffer OutputQuadMapBuffer {
    QuadMapDataPacked outputQuadMap[];
};

layout(r16f, binding = 0) uniform image2D depthOffsetBuffer;

vec3 ndcToView(mat4 projectionInverse, vec2 ndc, float depth) {
    vec4 ndcPos;
    ndcPos.xy = ndc;
    ndcPos.z = depth * 2.0 - 1.0;
    ndcPos.w = 1.0;

    vec4 viewCoord = projectionInverse * ndcPos;
    viewCoord = viewCoord / viewCoord.w;
    return viewCoord.xyz;
}

vec3 viewToNDC(mat4 projection, vec3 viewCoord) {
    vec4 ndcCoord = projection * vec4(viewCoord, 1.0);
    ndcCoord = ndcCoord / ndcCoord.w;
    ndcCoord.z = (ndcCoord.z + 1.0) / 2.0;
    return ndcCoord.xyz;
}

vec3 viewToWorld(mat4 viewInverse, vec3 viewCoord) {
    vec4 worldCoord = viewInverse * vec4(viewCoord, 1.0);
    worldCoord = worldCoord / worldCoord.w;
    return worldCoord.xyz;
}

vec3 worldToView(mat4 view, vec3 worldCoord) {
    vec4 viewCoord = view * vec4(worldCoord, 1.0);
    viewCoord = viewCoord / viewCoord.w;
    return viewCoord.xyz;
}

vec2 viewToScreen(mat4 projection, vec3 viewCoord) {
    vec2 ndc = viewToNDC(projection, viewCoord).xy;
    vec2 uv = (ndc + 1.0) / 2.0;
    return uv;
}

vec3 normalToView(mat4 view, vec3 normalWorld) {
    // skybox normals might be NaN, just set normal to face the camera
    if (any(isnan(normalWorld))) {
        return -forward;
    }

    // extract the rotation part of the view matrix
    mat3 rotationMatrix = mat3(view);
    return normalize(rotationMatrix * normalWorld);
}

float signedDistance(vec3 p1, vec3 p2) {
    float dist = distance(p1, p2);
    return (length(p1) > length(p2)) ? dist : -dist;
}

float normalizeDepth(float depth) {
    depth = clamp(depth, near, far);
    float z = (depth - near) / (far - near);
    return (1.0 - (1.0 / (1.0 + z * (far - near) / near)));
}

vec3 rayPlaneIntersection(vec3 rayOrigin, vec3 rayDirection, Plane plane) {
    float denominator = dot(rayDirection, plane.normal);
    if (abs(denominator) < epsilon) {
        return vec3(1.0/0.0);
    }

    float t = dot(plane.point - rayOrigin, plane.normal) / denominator;
    if (t < 0.0) {
        return vec3(1.0/0.0);
    }

    vec3 intersection = rayOrigin + t * rayDirection;
    return intersection;
}

vec3 pointPlaneIntersection(vec3 pt, Plane plane) {
    vec3 rayDirection = normalize(pt);
    return rayPlaneIntersection(origin, rayDirection, plane);
}

QuadMapData loadInputQuadMap(ivec2 pixelCoord) {
    uint index = uint(pixelCoord.y) * uint(inputQuadMapSize.x) + uint(pixelCoord.x);
    QuadMapDataPacked quadMapDataPacked = inputQuadMap[index];

    QuadMapData quadMapData;
    quadMapData.normal.xy = unpackHalf2x16(quadMapDataPacked.normalAndFlattenedAndSize.x);
    quadMapData.normal.z = unpackHalf2x16(quadMapDataPacked.normalAndFlattenedAndSize.y & 0xFFFFu).x;

    quadMapData.depth = quadMapDataPacked.depth;

    quadMapData.uv = quadMapDataPacked.uv;

    quadMapData.offset.x = int(quadMapDataPacked.offset & 0xFFFFu);
    quadMapData.offset.y = int((quadMapDataPacked.offset >> 16) & 0xFFFFu);

    uint flattenedAndSize = (quadMapDataPacked.normalAndFlattenedAndSize.y >> 16) & 0xFFFFu;
    quadMapData.flattened = (flattenedAndSize & (1u << 15)) != 0;
    quadMapData.size = flattenedAndSize & 0x7FFFu;

    return quadMapData;
}

float loadDepthOffset(in ivec2 pixelCoord) {
    return imageLoad(depthOffsetBuffer, pixelCoord).x;
}

void storeInOutputQuadMap(in ivec2 pixelCoord, in QuadMapData quadMapData) {
    uint flattenedAndSize = ((quadMapData.size & 0x7FFFu) | (quadMapData.flattened ? 1u << 15 : 0u)) & 0xFFFFu;

    QuadMapDataPacked quadMapDataPacked;
    quadMapDataPacked.normalAndFlattenedAndSize.x = packHalf2x16(quadMapData.normal.xy);
    uint packedNormalZ = packHalf2x16(vec2(quadMapData.normal.z, 0)) & 0xFFFFu;
    quadMapDataPacked.normalAndFlattenedAndSize.y = packedNormalZ | (flattenedAndSize << 16);
    quadMapDataPacked.depth = quadMapData.depth;
    quadMapDataPacked.uv = quadMapData.uv;
    quadMapDataPacked.offset = (quadMapData.offset.x & 0xFFFFu) | ((quadMapData.offset.y & 0xFFFFu) << 16);

    uint index = uint(pixelCoord.y) * uint(outputQuadMapSize.x) + uint(pixelCoord.x);
    outputQuadMap[index] = quadMapDataPacked;
}

void storeInDepthOffsetBuffer(in ivec2 pixelCoord, in float depthOffset) {
    imageStore(depthOffsetBuffer, pixelCoord, vec4(depthOffset));
}

void ignoreInputQuadMapData(in ivec2 pixelCoord) {
    uint index = uint(pixelCoord.y) * uint(inputQuadMapSize.x) + uint(pixelCoord.x);
    inputQuadMap[index].normalAndFlattenedAndSize.y = 0;
}

void loadDepthOffsets(out Quad1D depthOffsets, in ivec2 pixelCoord) {
    depthOffsets.bottomLeft  = loadDepthOffset(pixelCoord + ivec2(0, 0));
    depthOffsets.bottomRight = loadDepthOffset(pixelCoord + ivec2(1, 0));
    depthOffsets.topLeft     = loadDepthOffset(pixelCoord + ivec2(0, 1));
    depthOffsets.topRight    = loadDepthOffset(pixelCoord + ivec2(1, 1));
}

Plane quadMapDataToPlane(in QuadMapData quadMapData) {
    Plane proxyPlane;

    vec2 proxyPlaneUV = quadMapData.uv;
    float proxyPlaneDepth = quadMapData.depth;
    proxyPlane.normal = quadMapData.normal;

    vec2 proxyPlaneNDC = proxyPlaneUV * 2.0 - 1.0;
    proxyPlane.point = ndcToView(projectionInverse, proxyPlaneNDC, proxyPlaneDepth);

    return proxyPlane;
}

Quad1D findDepthOffsets(in Quad quadView, in Plane proxyPlane) {
    Quad quadPtsOnPlane;
    quadPtsOnPlane.bottomLeft  = pointPlaneIntersection(quadView.bottomLeft,  proxyPlane);
    quadPtsOnPlane.bottomRight = pointPlaneIntersection(quadView.bottomRight, proxyPlane);
    quadPtsOnPlane.topLeft     = pointPlaneIntersection(quadView.topLeft,     proxyPlane);
    quadPtsOnPlane.topRight    = pointPlaneIntersection(quadView.topRight,    proxyPlane);

    Quad1D depthOffsets;
    depthOffsets.bottomLeft  = signedDistance(quadPtsOnPlane.bottomLeft,  quadView.bottomLeft);
    depthOffsets.bottomRight = signedDistance(quadPtsOnPlane.bottomRight, quadView.bottomRight);
    depthOffsets.topLeft     = signedDistance(quadPtsOnPlane.topLeft,     quadView.topLeft);
    depthOffsets.topRight    = signedDistance(quadPtsOnPlane.topRight,    quadView.topRight);

    return depthOffsets;
}

void storeDepthOffsets(in ivec2 pixelCoord, in Quad1D depthOffsets) {
    storeInDepthOffsetBuffer(pixelCoord + ivec2(0, 0), depthOffsets.bottomLeft);
    storeInDepthOffsetBuffer(pixelCoord + ivec2(1, 0), depthOffsets.bottomRight);
    storeInDepthOffsetBuffer(pixelCoord + ivec2(0, 1), depthOffsets.topLeft);
    storeInDepthOffsetBuffer(pixelCoord + ivec2(1, 1), depthOffsets.topRight);
}

void createSurfel(out Quad surfel, in Quad2D surfelPixelCoords, in Quad1D depthOffsets, in Plane proxyPlane) {
    Quad2D surfelUVs;
    surfelUVs.bottomLeft  = surfelPixelCoords.bottomLeft  / remoteWindowSize;
    surfelUVs.bottomRight = surfelPixelCoords.bottomRight / remoteWindowSize;
    surfelUVs.topLeft     = surfelPixelCoords.topLeft     / remoteWindowSize;
    surfelUVs.topRight    = surfelPixelCoords.topRight    / remoteWindowSize;

    Quad2D surfelNDCs;
    surfelNDCs.bottomLeft  = surfelUVs.bottomLeft  * 2.0 - 1.0;
    surfelNDCs.bottomRight = surfelUVs.bottomRight * 2.0 - 1.0;
    surfelNDCs.topLeft     = surfelUVs.topLeft     * 2.0 - 1.0;
    surfelNDCs.topRight    = surfelUVs.topRight    * 2.0 - 1.0;

    Quad surfelNearPlane;
    surfelNearPlane.bottomLeft  = ndcToView(projectionInverse, surfelNDCs.bottomLeft, 0.0);
    surfelNearPlane.bottomRight = ndcToView(projectionInverse, surfelNDCs.bottomRight, 0.0);
    surfelNearPlane.topLeft     = ndcToView(projectionInverse, surfelNDCs.topLeft, 0.0);
    surfelNearPlane.topRight    = ndcToView(projectionInverse, surfelNDCs.topRight, 0.0);

    // shoot rays from corners of the surfel to the plane to find the 3D intersection points
    Quad quadPtsOnPlane;
    quadPtsOnPlane.bottomLeft  = pointPlaneIntersection(surfelNearPlane.bottomLeft,  proxyPlane);
    quadPtsOnPlane.bottomRight = pointPlaneIntersection(surfelNearPlane.bottomRight, proxyPlane);
    quadPtsOnPlane.topLeft     = pointPlaneIntersection(surfelNearPlane.topLeft,     proxyPlane);
    quadPtsOnPlane.topRight    = pointPlaneIntersection(surfelNearPlane.topRight,    proxyPlane);

    // apply depth offsets to the quad points
    surfel.bottomLeft  = quadPtsOnPlane.bottomLeft  - depthOffsets.bottomLeft  * normalize(quadPtsOnPlane.bottomLeft);
    surfel.bottomRight = quadPtsOnPlane.bottomRight - depthOffsets.bottomRight * normalize(quadPtsOnPlane.bottomRight);
    surfel.topLeft     = quadPtsOnPlane.topLeft     - depthOffsets.topLeft     * normalize(quadPtsOnPlane.topLeft);
    surfel.topRight    = quadPtsOnPlane.topRight    - depthOffsets.topRight    * normalize(quadPtsOnPlane.topRight);
}

bool planeEquationsSimilar(in PlaneEq planeEq1, in PlaneEq planeEq2) {
    vec4 planeEq1Vec = vec4(planeEq1.normal, planeEq1.constant);
    vec4 planeEq2Vec = vec4(planeEq2.normal, planeEq2.constant);
    float similarity = distance(planeEq1Vec, planeEq2Vec);
    return similarity < proxySimilarityThreshold;
}

PlaneEq planeToPlaneEq(in Plane plane) {
    PlaneEq planeEq;
    planeEq.normal = plane.normal;
    planeEq.constant = -dot(planeEq.normal, plane.point);
    return planeEq;
}

Plane planeEqToPlane(in PlaneEq planeEq) {
    Plane plane;
    plane.normal = planeEq.normal;
    if (planeEq.normal.z != 0.0) {
        float z = -planeEq.constant / planeEq.normal.z;
        plane.point = vec3(0.0, 0.0, z);
    }
    else if (planeEq.normal.y != 0.0) {
        float y = -planeEq.constant / planeEq.normal.y;
        plane.point = vec3(0.0, y, 0.0);
    }
    else if (planeEq.normal.x != 0.0) {
        float x = -planeEq.constant / planeEq.normal.x;
        plane.point = vec3(x, 0.0, 0.0);
    }
    return plane;
}

Plane averagePlanes(in Plane plane1, in Plane plane2, in Plane plane3, in Plane plane4) {
    Plane averagePlane;
    averagePlane.normal = normalize((plane1.normal + plane2.normal + plane3.normal + plane4.normal) / 4.0);
    averagePlane.point = (plane1.point + plane2.point + plane3.point + plane4.point) / 4.0;
    return averagePlane;
}

bool shouldMerge(in Plane proxyPlaneBottomLeft, in Plane proxyPlaneBottomRight, in Plane proxyPlaneTopLeft, in Plane proxyPlaneTopRight) {
    PlaneEq proxyPlaneEqBottomLeft  = planeToPlaneEq(proxyPlaneBottomLeft);
    PlaneEq proxyPlaneEqBottomRight = planeToPlaneEq(proxyPlaneBottomRight);
    PlaneEq proxyPlaneEqTopLeft     = planeToPlaneEq(proxyPlaneTopLeft);
    PlaneEq proxyPlaneEqTopRight    = planeToPlaneEq(proxyPlaneTopRight);

    // we merge the quad if all the proxy planes are similar
    return planeEquationsSimilar(proxyPlaneEqBottomLeft, proxyPlaneEqBottomRight) &&
           planeEquationsSimilar(proxyPlaneEqBottomLeft, proxyPlaneEqTopLeft) &&
           planeEquationsSimilar(proxyPlaneEqBottomLeft, proxyPlaneEqTopRight) &&
           planeEquationsSimilar(proxyPlaneEqBottomRight, proxyPlaneEqTopLeft) &&
           planeEquationsSimilar(proxyPlaneEqBottomRight, proxyPlaneEqTopRight) &&
           planeEquationsSimilar(proxyPlaneEqTopLeft, proxyPlaneEqTopRight);
}

void mergeQuadMapData(
    out QuadMapData mergedQuadMapData,
    in Plane proxyPlaneBottomLeft, in Plane proxyPlaneBottomRight, in Plane proxyPlaneTopLeft, in Plane proxyPlaneTopRight,
    in QuadMapData quadMapDataBottomLeft, in QuadMapData quadMapDataBottomRight, in QuadMapData quadMapDataTopLeft, in QuadMapData quadMapDataTopRight
) {
    // get average plane
    Plane newProxyPlane = averagePlanes(proxyPlaneBottomLeft, proxyPlaneBottomRight, proxyPlaneTopLeft, proxyPlaneTopRight);

    // find what depth the average uv maps to on the new plane
    vec2 averageUV = (quadMapDataBottomLeft.uv + quadMapDataBottomRight.uv + quadMapDataTopLeft.uv + quadMapDataTopRight.uv) / 4.0;
    vec2 averageNDC = averageUV * 2.0 - 1.0;
    vec3 averageNearPlane = ndcToView(projectionInverse, averageNDC, 0.0);

    vec3 planeCenterPt = pointPlaneIntersection(averageNearPlane, newProxyPlane);
    vec3 newProxyPlaneNDC = viewToNDC(projection, planeCenterPt);
    vec2 newProxyPlaneUV = (newProxyPlaneNDC.xy + 1.0) / 2.0;

    float newProxyPlaneDepth = min(newProxyPlaneNDC.z, MAX_DEPTH);

    // recalculate the new merged proxy plane's surfel's depth offsets
    int numBelowThreshold = 0;
    int total = 0;
    QuadMapData quadMapDatas[4] = QuadMapData[](quadMapDataBottomLeft, quadMapDataBottomRight, quadMapDataTopLeft, quadMapDataTopRight);
    Plane proxyPlanes[4] = Plane[](proxyPlaneBottomLeft, proxyPlaneBottomRight, proxyPlaneTopLeft, proxyPlaneTopRight);
    for (int i = 0; i < 4; i++) {
        QuadMapData quadMapData = quadMapDatas[i];
        Plane proxyPlane = proxyPlanes[i];

        vec2 proxyPlaneUV = quadMapData.uv;
        vec2 proxyPlanePixelCoords = vec2(proxyPlaneUV * remoteWindowSize);

        uint size = 1 << quadMapData.size;
        float halfGridSize = float(size) * surfelSize / 2;

        // calculate new depth offsets relative to new proxy plane
        vec2 start = vec2(proxyPlanePixelCoords - vec2(halfGridSize, halfGridSize));
        for (int i = 0; i < size; i++) {
            for (int j = 0; j < size; j++) {
                Quad2D surfelPixelCoords;
                surfelPixelCoords.bottomLeft  = start + vec2(float(i) * 0.5, float(j) * 0.5);
                surfelPixelCoords.bottomRight = surfelPixelCoords.bottomLeft + vec2(0.5, 0.0);
                surfelPixelCoords.topLeft     = surfelPixelCoords.bottomLeft + vec2(0.0, 0.5);
                surfelPixelCoords.topRight    = surfelPixelCoords.bottomLeft + vec2(0.5, 0.5);

                Quad1D oldDepthOffsets;
                loadDepthOffsets(oldDepthOffsets, 4 * quadMapData.offset + 2 * ivec2(i, j));

                Quad surfel;
                createSurfel(surfel, surfelPixelCoords, oldDepthOffsets, proxyPlane);

                Quad1D newDepthOffsets = findDepthOffsets(surfel, newProxyPlane);
                storeDepthOffsets(4 * quadMapData.offset + 2 * ivec2(i, j), newDepthOffsets);

                if (abs(newDepthOffsets.bottomLeft)  < flatThreshold) numBelowThreshold++;
                if (abs(newDepthOffsets.bottomRight) < flatThreshold) numBelowThreshold++;
                if (abs(newDepthOffsets.topLeft)     < flatThreshold) numBelowThreshold++;
                if (abs(newDepthOffsets.topRight)    < flatThreshold) numBelowThreshold++;
                total += 4;
            }
        }
    }

    // if more than half the surfels are below the threshold, then the plane is considered flattened
    bool flattened = numBelowThreshold > total / 2;

    mergedQuadMapData.flattened = flattened;
    mergedQuadMapData.normal = newProxyPlane.normal;
    mergedQuadMapData.uv = newProxyPlaneUV;
    mergedQuadMapData.depth = newProxyPlaneDepth;
    mergedQuadMapData.offset = quadMapDataBottomLeft.offset;
    mergedQuadMapData.size = quadMapDataBottomLeft.size + 1;
}

void main() {
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    if (pixelCoord.x >= int(outputQuadMapSize.x) || pixelCoord.y >= int(outputQuadMapSize.y)) {
        return;
    }

    ivec2 pixelCoordsBottomLeft  = 2 * pixelCoord + ivec2(0, 0);
    ivec2 pixelCoordsBottomRight = 2 * pixelCoord + ivec2(1, 0);
    ivec2 pixelCoordsTopLeft     = 2 * pixelCoord + ivec2(0, 1);
    ivec2 pixelCoordsTopRight    = 2 * pixelCoord + ivec2(1, 1);

    QuadMapData quadMapDataBottomLeft  = loadInputQuadMap(pixelCoordsBottomLeft);
    QuadMapData quadMapDataBottomRight = loadInputQuadMap(pixelCoordsBottomRight);
    QuadMapData quadMapDataTopLeft     = loadInputQuadMap(pixelCoordsTopLeft);
    QuadMapData quadMapDataTopRight    = loadInputQuadMap(pixelCoordsTopRight);

    // create proxy planes
    Plane proxyPlaneBottomLeft  = quadMapDataToPlane(quadMapDataBottomLeft);
    Plane proxyPlaneBottomRight = quadMapDataToPlane(quadMapDataBottomRight);
    Plane proxyPlaneTopLeft     = quadMapDataToPlane(quadMapDataTopLeft);
    Plane proxyPlaneTopRight    = quadMapDataToPlane(quadMapDataTopRight);

    QuadMapData mergedQuadMapData;
    // by default, ignore the quad
    mergedQuadMapData.flattened = false;
    mergedQuadMapData.size = 0;

    // if any of the loaded proxy planes are empty, ignore the quad
    if (quadMapDataBottomLeft.size == 0 || quadMapDataBottomRight.size == 0 ||
           quadMapDataTopLeft.size == 0 || quadMapDataTopRight.size == 0) {
        storeInOutputQuadMap(pixelCoord, mergedQuadMapData);
    }
    else if (shouldMerge(proxyPlaneBottomLeft, proxyPlaneBottomRight, proxyPlaneTopLeft, proxyPlaneTopRight)) {
        // merge the proxy planes
        mergeQuadMapData(
            mergedQuadMapData,
            proxyPlaneBottomLeft, proxyPlaneBottomRight, proxyPlaneTopLeft, proxyPlaneTopRight,
            quadMapDataBottomLeft, quadMapDataBottomRight, quadMapDataTopLeft, quadMapDataTopRight
        );

        // ignore the previous proxy planes that have been merged
        ignoreInputQuadMapData(pixelCoordsBottomLeft);
        ignoreInputQuadMapData(pixelCoordsBottomRight);
        ignoreInputQuadMapData(pixelCoordsTopLeft);
        ignoreInputQuadMapData(pixelCoordsTopRight);
    }

    storeInOutputQuadMap(pixelCoord, mergedQuadMapData);
}
