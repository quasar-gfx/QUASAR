layout(local_size_x = THREADS_PER_LOCALGROUP, local_size_y = THREADS_PER_LOCALGROUP, local_size_z = 1) in;

struct QuadMapData {
    vec3 normal;
    float depth;
    vec2 uv;
    uvec2 offset;
    uint size;
    bool flattened;
};

struct QuadMapDataPacked {
    uint normalSpherical;
    float depth;
    uint offsetSizeFlattened;
};

struct Quad {
    vec3 bottomLeft;
    vec3 bottomRight;
    vec3 topLeft;
    vec3 topRight;
};

struct Quad2D {
    vec2 bottomLeft;
    vec2 bottomRight;
    vec2 topLeft;
    vec2 topRight;
};

// a Quad subdivided into 4 smaller Quads
struct MultiQuad {
    vec3 bottomLeft;
    vec3 bottom;
    vec3 bottomRight;
    vec3 left;
    vec3 center;
    vec3 right;
    vec3 topLeft;
    vec3 top;
    vec3 topRight;
};

struct Multivec4 {
    float bottomLeft;
    float bottom;
    float bottomRight;
    float left;
    float center;
    float right;
    float topLeft;
    float top;
    float topRight;
};

struct MultiQuad2D {
    vec2 bottomLeft;
    vec2 bottom;
    vec2 bottomRight;
    vec2 left;
    vec2 center;
    vec2 right;
    vec2 topLeft;
    vec2 top;
    vec2 topRight;
};

struct Plane {
    vec3 normal;
    vec3 point;
};

layout(std430, binding = 0) readonly buffer NormalSphericalsBufferInput {
    uint normalSphericalsInput[];
};

layout(std430, binding = 1) readonly buffer DepthBufferInput {
    float depthsInput[];
};

layout(std430, binding = 2) buffer OffsetsBufferInput {
    uint offsetSizeFlattenedsInput[];
};

layout(std430, binding = 3) writeonly buffer NormalSphericalsBufferOutput {
    uint normalSphericalsOutput[];
};

layout(std430, binding = 4) writeonly buffer DepthBufferOutput {
    float depthsOutput[];
};

layout(std430, binding = 5) writeonly buffer OffsetsBufferOutput {
    uint offsetSizeFlattenedsOutput[];
};

layout(rgba16f, binding = 0) uniform image2D depthOffsetsBuffer;

uniform vec2 gBufferSize;
uniform vec2 depthBufferSize;
uniform vec2 inputQuadMapSize;
uniform vec2 outputQuadMapSize;

uniform mat4 view;
uniform mat4 projection;
uniform mat4 viewInverse;
uniform mat4 projectionInverse;
uniform float near;
uniform float far;

uniform float flatThreshold;
uniform float proxySimilarityThreshold;

#define MAX_DEPTH 0.9999

const float epsilon = 1e-5;
const float surfelSize = 0.5;
const float PI = 3.1415926535897932384626433832795;

const vec3 origin = vec3(0.0, 0.0, 0.0);
const vec3 forward = vec3(0.0, 0.0, -1.0);

vec3 ndcToView(mat4 projectionInverse, vec2 ndc, float depth) {
    vec4 ndcPos;
    ndcPos.xy = ndc;
    ndcPos.z = depth * 2.0 - 1.0;
    ndcPos.w = 1.0;

    vec4 viewCoord = projectionInverse * ndcPos;
    viewCoord = viewCoord / viewCoord.w;
    return viewCoord.xyz;
}

vec3 viewToNDC(mat4 projection, vec3 viewCoord) {
    vec4 ndcCoord = projection * vec4(viewCoord, 1.0);
    ndcCoord = ndcCoord / ndcCoord.w;
    ndcCoord.z = (ndcCoord.z + 1.0) / 2.0;
    return ndcCoord.xyz;
}

vec3 viewToWorld(mat4 viewInverse, vec3 viewCoord) {
    vec4 worldCoord = viewInverse * vec4(viewCoord, 1.0);
    worldCoord = worldCoord / worldCoord.w;
    return worldCoord.xyz;
}

vec3 worldToView(mat4 view, vec3 worldCoord) {
    vec4 viewCoord = view * vec4(worldCoord, 1.0);
    viewCoord = viewCoord / viewCoord.w;
    return viewCoord.xyz;
}

vec2 viewToScreen(mat4 projection, vec3 viewCoord) {
    vec2 ndc = viewToNDC(projection, viewCoord).xy;
    vec2 uv = (ndc + 1.0) / 2.0;
    return uv;
}

vec3 normalToView(mat4 view, vec3 normalWorld) {
    // skybox normals might be NaN, just set normal to face the camera
    if (any(isnan(normalWorld))) {
        return -forward;
    }

    // extract the rotation part of the view matrix
    mat3 rotationMatrix = mat3(view);
    return normalize(rotationMatrix * normalWorld);
}

float signedDistance(vec3 p1, vec3 p2) {
    float dist = distance(p1, p2);
    return (length(p1) > length(p2)) ? -dist : dist;
}

float normalizeDepth(float depth) {
    depth = clamp(depth, near, far);
    float z = (depth - near) / (far - near);
    return (1.0 - (1.0 / (1.0 + z * (far - near) / near)));
}

vec3 rayPlaneIntersection(vec3 rayOrigin, vec3 rayDirection, Plane plane) {
    float denominator = dot(rayDirection, plane.normal);
    if (abs(denominator) < epsilon) {
        return vec3(1.0/0.0);
    }

    float t = dot(plane.point - rayOrigin, plane.normal) / denominator;
    if (t < 0.0) {
        return vec3(1.0/0.0);
    }

    vec3 intersection = rayOrigin + t * rayDirection;
    return intersection;
}

vec3 pointPlaneIntersection(vec3 pt, Plane plane) {
    vec3 rayDirection = normalize(pt);
    return rayPlaneIntersection(origin, rayDirection, plane);
}

uint packNormalToSphericalHalf(vec3 normal) {
    float theta = atan(normal.z, normal.x);
    float phi = acos(normal.y);

    float theta01 = (theta + PI) / (2.0 * PI);
    float phi01 = phi / PI;

    return packHalf2x16(vec2(theta01, phi01));
}

vec3 unpackSphericalToNormalHalf(uint packedNormal) {
    vec2 spherical01 = unpackHalf2x16(packedNormal);

    float theta = spherical01.x * (2.0 * PI) - PI;
    float phi = spherical01.y * PI;

    return vec3(
        sin(phi) * cos(theta),
        cos(phi),
        sin(phi) * sin(theta)
    );
}

QuadMapData loadInputQuadMap(ivec2 pixelCoord) {
    uint index = uint(pixelCoord.y) * uint(inputQuadMapSize.x) + uint(pixelCoord.x);

    QuadMapDataPacked quadMapDataPacked;
    quadMapDataPacked.normalSpherical = normalSphericalsInput[index];
    quadMapDataPacked.depth = depthsInput[index];
    quadMapDataPacked.offsetSizeFlattened = offsetSizeFlattenedsInput[index];

    QuadMapData quadMapData;
    quadMapData.normal = unpackSphericalToNormalHalf(quadMapDataPacked.normalSpherical);
    quadMapData.depth = quadMapDataPacked.depth;

    quadMapData.offset.x = (quadMapDataPacked.offsetSizeFlattened >> 20) & 0xFFFu;
    quadMapData.offset.y = (quadMapDataPacked.offsetSizeFlattened >> 8) & 0xFFFu;

    uint flattenedAndSize = quadMapDataPacked.offsetSizeFlattened & 0xFFu;
    quadMapData.size = (flattenedAndSize >> 1) & 0x7Fu;
    quadMapData.flattened = (flattenedAndSize & 1u) != 0;

    uint halfSize = 1u << (quadMapData.size - 1u); // 2^size / 2
    quadMapData.uv = (vec2(quadMapData.offset) + float(halfSize) * vec2(0.5)) / gBufferSize;

    return quadMapData;
}

void storeOutputQuadMap(in ivec2 pixelCoord, in QuadMapData quadMapData) {
    QuadMapDataPacked quadMapDataPacked;
    quadMapDataPacked.normalSpherical = packNormalToSphericalHalf(quadMapData.normal);
    quadMapDataPacked.depth = quadMapData.depth;

    uint flattenedAndSize = ((quadMapData.size & 0x7Fu) << 1) | (quadMapData.flattened ? 1u : 0u);
    quadMapDataPacked.offsetSizeFlattened = ((quadMapData.offset.x & 0xFFFu) << 20) |
                                                    ((quadMapData.offset.y & 0xFFFu) << 8) |
                                                        (flattenedAndSize & 0xFFu);

    uint index = uint(pixelCoord.y) * uint(outputQuadMapSize.x) + uint(pixelCoord.x);
    normalSphericalsOutput[index] = quadMapDataPacked.normalSpherical;
    depthsOutput[index] = quadMapDataPacked.depth;
    offsetSizeFlattenedsOutput[index] = quadMapDataPacked.offsetSizeFlattened;
}

void ignoreInputQuadMapData(in ivec2 pixelCoord) {
    uint index = uint(pixelCoord.y) * uint(inputQuadMapSize.x) + uint(pixelCoord.x);
    offsetSizeFlattenedsInput[index] = 0;
}

vec4 loadDepthOffsets(in ivec2 pixelCoord) {
    return imageLoad(depthOffsetsBuffer, pixelCoord);
}

Plane quadMapDataToPlane(in QuadMapData quadMapData) {
    Plane proxyPlane;

    vec2 proxyPlaneUV = quadMapData.uv;
    float proxyPlaneDepth = quadMapData.depth;
    proxyPlane.normal = quadMapData.normal;

    vec2 proxyPlaneNDC = proxyPlaneUV * 2.0 - 1.0;
    proxyPlane.point = ndcToView(projectionInverse, proxyPlaneNDC, proxyPlaneDepth);

    return proxyPlane;
}

vec4 findDepthOffsets(in Quad quadView, in Plane proxyPlane) {
    Quad quadPtsOnPlane;
    quadPtsOnPlane.bottomLeft  = pointPlaneIntersection(quadView.bottomLeft,  proxyPlane);
    quadPtsOnPlane.bottomRight = pointPlaneIntersection(quadView.bottomRight, proxyPlane);
    quadPtsOnPlane.topLeft     = pointPlaneIntersection(quadView.topLeft,     proxyPlane);
    quadPtsOnPlane.topRight    = pointPlaneIntersection(quadView.topRight,    proxyPlane);

    vec4 depthOffsets;
    depthOffsets.x = signedDistance(quadPtsOnPlane.bottomLeft,  quadView.bottomLeft);
    depthOffsets.y = signedDistance(quadPtsOnPlane.bottomRight, quadView.bottomRight);
    depthOffsets.z = signedDistance(quadPtsOnPlane.topLeft,     quadView.topLeft);
    depthOffsets.w = signedDistance(quadPtsOnPlane.topRight,    quadView.topRight);

    return depthOffsets;
}

void storeDepthOffsets(in ivec2 pixelCoord, in vec4 depthOffsets) {
    imageStore(depthOffsetsBuffer, pixelCoord, depthOffsets);
}

void createSurfel(out Quad surfel, in Quad2D surfelPixelCoords, in vec4 depthOffsets, in Plane proxyPlane) {
    Quad2D surfelUVs;
    surfelUVs.bottomLeft  = surfelPixelCoords.bottomLeft  / gBufferSize;
    surfelUVs.bottomRight = surfelPixelCoords.bottomRight / gBufferSize;
    surfelUVs.topLeft     = surfelPixelCoords.topLeft     / gBufferSize;
    surfelUVs.topRight    = surfelPixelCoords.topRight    / gBufferSize;

    Quad2D surfelNDCs;
    surfelNDCs.bottomLeft  = surfelUVs.bottomLeft  * 2.0 - 1.0;
    surfelNDCs.bottomRight = surfelUVs.bottomRight * 2.0 - 1.0;
    surfelNDCs.topLeft     = surfelUVs.topLeft     * 2.0 - 1.0;
    surfelNDCs.topRight    = surfelUVs.topRight    * 2.0 - 1.0;

    Quad surfelNearPlane;
    surfelNearPlane.bottomLeft  = ndcToView(projectionInverse, surfelNDCs.bottomLeft, 0.0);
    surfelNearPlane.bottomRight = ndcToView(projectionInverse, surfelNDCs.bottomRight, 0.0);
    surfelNearPlane.topLeft     = ndcToView(projectionInverse, surfelNDCs.topLeft, 0.0);
    surfelNearPlane.topRight    = ndcToView(projectionInverse, surfelNDCs.topRight, 0.0);

    // shoot rays from corners of the surfel to the plane to find the 3D intersection points
    Quad quadPtsOnPlane;
    quadPtsOnPlane.bottomLeft  = pointPlaneIntersection(surfelNearPlane.bottomLeft,  proxyPlane);
    quadPtsOnPlane.bottomRight = pointPlaneIntersection(surfelNearPlane.bottomRight, proxyPlane);
    quadPtsOnPlane.topLeft     = pointPlaneIntersection(surfelNearPlane.topLeft,     proxyPlane);
    quadPtsOnPlane.topRight    = pointPlaneIntersection(surfelNearPlane.topRight,    proxyPlane);

    // apply depth offsets to the quad points
    surfel.bottomLeft  = quadPtsOnPlane.bottomLeft  - depthOffsets.x * normalize(quadPtsOnPlane.bottomLeft);
    surfel.bottomRight = quadPtsOnPlane.bottomRight - depthOffsets.y * normalize(quadPtsOnPlane.bottomRight);
    surfel.topLeft     = quadPtsOnPlane.topLeft     - depthOffsets.z * normalize(quadPtsOnPlane.topLeft);
    surfel.topRight    = quadPtsOnPlane.topRight    - depthOffsets.w * normalize(quadPtsOnPlane.topRight);
}

vec4 planeToPlaneEq(in Plane plane) {
    vec4 planeEq = vec4(plane.normal, -dot(plane.normal, plane.point));
    return planeEq;
}

Plane planeEqToPlane(in vec4 planeEq) {
    Plane plane;
    plane.normal = planeEq.xyz;
    if (planeEq.z != 0.0) {
        float z = -planeEq.w / planeEq.z;
        plane.point = vec3(0.0, 0.0, z);
    }
    else if (planeEq.y != 0.0) {
        float y = -planeEq.w / planeEq.y;
        plane.point = vec3(0.0, y, 0.0);
    }
    else if (planeEq.x != 0.0) {
        float x = -planeEq.w / planeEq.x;
        plane.point = vec3(x, 0.0, 0.0);
    }
    return plane;
}

bool planeEquationsSimilar(in vec4 planeEq1, in vec4 planeEq2) {
    float similarity = distance(planeEq1, planeEq2);
    return similarity < proxySimilarityThreshold;
}

bool shouldMerge(
    in Plane proxyPlaneBottomLeft, in Plane proxyPlaneBottomRight,
    in Plane proxyPlaneTopLeft, in Plane proxyPlaneTopRight
) {
    vec4 proxyPlaneEqBottomLeft  = planeToPlaneEq(proxyPlaneBottomLeft);
    vec4 proxyPlaneEqBottomRight = planeToPlaneEq(proxyPlaneBottomRight);
    vec4 proxyPlaneEqTopLeft     = planeToPlaneEq(proxyPlaneTopLeft);
    vec4 proxyPlaneEqTopRight    = planeToPlaneEq(proxyPlaneTopRight);

    // we merge the quad if all the proxy planes are similar
    return planeEquationsSimilar(proxyPlaneEqBottomLeft, proxyPlaneEqBottomRight) &&
           planeEquationsSimilar(proxyPlaneEqBottomLeft, proxyPlaneEqTopLeft) &&
           planeEquationsSimilar(proxyPlaneEqBottomLeft, proxyPlaneEqTopRight) &&
           planeEquationsSimilar(proxyPlaneEqBottomRight, proxyPlaneEqTopLeft) &&
           planeEquationsSimilar(proxyPlaneEqBottomRight, proxyPlaneEqTopRight) &&
           planeEquationsSimilar(proxyPlaneEqTopLeft, proxyPlaneEqTopRight);
}

Plane averagePlanes(in Plane plane1, in Plane plane2, in Plane plane3, in Plane plane4) {
    vec4 proxyPlaneEq1 = planeToPlaneEq(plane1);
    vec4 proxyPlaneEq2 = planeToPlaneEq(plane2);
    vec4 proxyPlaneEq3 = planeToPlaneEq(plane3);
    vec4 proxyPlaneEq4 = planeToPlaneEq(plane4);

    vec4 newProxyPlaneEq = (proxyPlaneEq1 + proxyPlaneEq2 + proxyPlaneEq3 + proxyPlaneEq4) / 4.0;
    Plane newProxyPlane = planeEqToPlane(newProxyPlaneEq);
    return newProxyPlane;
}

void recalcDepthOffsets(
    in Plane newProxyPlane,
    in QuadMapData quadMapData, in Plane proxyPlane,
    inout int numBelowThreshold, inout int total
) {
    vec2 proxyPlaneUV = quadMapData.uv;
    vec2 proxyPlanePixelCoords = vec2(proxyPlaneUV * gBufferSize);

    uint size = 1 << quadMapData.size;
    float halfGridSize = float(size) * surfelSize / 2;

    vec2 start = proxyPlanePixelCoords - vec2(halfGridSize);
    vec2 stepSize = vec2(0.5);

    // calculate new depth offsets relative to new proxy plane
    for (int i = 0; i < size; i++) {
        vec2 rowStart = start + vec2(float(i) * stepSize.x, 0.0);
        for (int j = 0; j < size; j++) {
            vec2 surfelBaseCoord = rowStart + vec2(0.0, float(j) * stepSize.y);

            Quad2D surfelPixelCoords;
            surfelPixelCoords.bottomLeft  = surfelBaseCoord;
            surfelPixelCoords.bottomRight = surfelBaseCoord + vec2(stepSize.x, 0.0);
            surfelPixelCoords.topLeft     = surfelBaseCoord + vec2(0.0, stepSize.y);
            surfelPixelCoords.topRight    = surfelBaseCoord + stepSize;

            ivec2 depthOffsetPixelCoords = 2 * ivec2(quadMapData.offset) + ivec2(i, j);
            vec4 oldDepthOffsets = loadDepthOffsets(depthOffsetPixelCoords);
            Quad surfel;
            createSurfel(surfel, surfelPixelCoords, oldDepthOffsets, proxyPlane);

            vec4 newDepthOffsets = findDepthOffsets(surfel, newProxyPlane);
            storeDepthOffsets(depthOffsetPixelCoords, newDepthOffsets);

            vec4 absOffsets = abs(newDepthOffsets);
            numBelowThreshold += int(absOffsets.x < flatThreshold) +
                                 int(absOffsets.y < flatThreshold) +
                                 int(absOffsets.z < flatThreshold) +
                                 int(absOffsets.w < flatThreshold);
            total += 4;
        }
    }
}

void mergeQuadMapData(
    out QuadMapData mergedQuadMapData,
    in Plane proxyPlaneBottomLeft, in Plane proxyPlaneBottomRight,
    in Plane proxyPlaneTopLeft, in Plane proxyPlaneTopRight,
    in QuadMapData quadMapDataBottomLeft, in QuadMapData quadMapDataBottomRight,
    in QuadMapData quadMapDataTopLeft, in QuadMapData quadMapDataTopRight
) {
    // get average plane
    Plane newProxyPlane = averagePlanes(proxyPlaneBottomLeft, proxyPlaneBottomRight,
                                        proxyPlaneTopLeft, proxyPlaneTopRight);

    // find what depth the average uv maps to on the new plane
    vec2 averageUV = (quadMapDataBottomLeft.uv + quadMapDataBottomRight.uv +
                      quadMapDataTopLeft.uv + quadMapDataTopRight.uv) / 4.0;
    vec2 averageNDC = averageUV * 2.0 - 1.0;
    vec3 averageNearPlane = ndcToView(projectionInverse, averageNDC, 0.0);

    vec3 planeCenterPt = pointPlaneIntersection(averageNearPlane, newProxyPlane);
    vec3 newProxyPlaneNDC = viewToNDC(projection, planeCenterPt);
    vec2 newProxyPlaneUV = (newProxyPlaneNDC.xy + 1.0) / 2.0;

    float newProxyPlaneDepth = min(newProxyPlaneNDC.z, MAX_DEPTH);

    bool flattened = (quadMapDataBottomLeft.flattened && quadMapDataBottomRight.flattened &&
                      quadMapDataTopLeft.flattened && quadMapDataTopRight.flattened);
    // if at least one of the quads to merge is not flattened,
    // recalculate the new merged proxy plane's surfel's depth offsets
    if (!flattened) {
        int numBelowThreshold = 0, total = 0;
        recalcDepthOffsets(newProxyPlane, quadMapDataBottomLeft, proxyPlaneBottomLeft, numBelowThreshold, total);
        recalcDepthOffsets(newProxyPlane, quadMapDataBottomRight, proxyPlaneBottomRight, numBelowThreshold, total);
        recalcDepthOffsets(newProxyPlane, quadMapDataTopLeft, proxyPlaneTopLeft, numBelowThreshold, total);
        recalcDepthOffsets(newProxyPlane, quadMapDataTopRight, proxyPlaneTopRight, numBelowThreshold, total);

        // if more than half the surfels are below the threshold, then the plane is considered flattened
        flattened = (numBelowThreshold == total);
    }

    mergedQuadMapData.flattened = flattened;
    mergedQuadMapData.normal = newProxyPlane.normal;
    mergedQuadMapData.uv = newProxyPlaneUV;
    mergedQuadMapData.depth = newProxyPlaneDepth;
    mergedQuadMapData.offset = quadMapDataBottomLeft.offset;
    mergedQuadMapData.size = quadMapDataBottomLeft.size + 1;

    // // zero out depth offsets
    // uint size = 1u << mergedQuadMapData.size;
    // for (uint i = 0u; i < size; i++) {
    //     for (uint j = 0u; j < size; j++) {
    //         ivec2 depthOffsetPixelCoords = 2 * ivec2(mergedQuadMapData.offset) + ivec2(i, j);
    //         imageStore(depthOffsetsBuffer, depthOffsetPixelCoords + ivec2(0, 0), vec4(0.0));
    //         imageStore(depthOffsetsBuffer, depthOffsetPixelCoords + ivec2(1, 0), vec4(0.0));
    //         imageStore(depthOffsetsBuffer, depthOffsetPixelCoords + ivec2(0, 1), vec4(0.0));
    //         imageStore(depthOffsetsBuffer, depthOffsetPixelCoords + ivec2(1, 1), vec4(0.0));
    //     }
    // }
}

void main() {
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    if (pixelCoord.x >= int(outputQuadMapSize.x) || pixelCoord.y >= int(outputQuadMapSize.y)) {
        return;
    }

    ivec2 pixelCoordsBottomLeft  = 2 * pixelCoord + ivec2(0, 0);
    ivec2 pixelCoordsBottomRight = 2 * pixelCoord + ivec2(1, 0);
    ivec2 pixelCoordsTopLeft     = 2 * pixelCoord + ivec2(0, 1);
    ivec2 pixelCoordsTopRight    = 2 * pixelCoord + ivec2(1, 1);

    QuadMapData quadMapDataBottomLeft  = loadInputQuadMap(pixelCoordsBottomLeft);
    QuadMapData quadMapDataBottomRight = loadInputQuadMap(pixelCoordsBottomRight);
    QuadMapData quadMapDataTopLeft     = loadInputQuadMap(pixelCoordsTopLeft);
    QuadMapData quadMapDataTopRight    = loadInputQuadMap(pixelCoordsTopRight);

    // create proxy planes
    Plane proxyPlaneBottomLeft  = quadMapDataToPlane(quadMapDataBottomLeft);
    Plane proxyPlaneBottomRight = quadMapDataToPlane(quadMapDataBottomRight);
    Plane proxyPlaneTopLeft     = quadMapDataToPlane(quadMapDataTopLeft);
    Plane proxyPlaneTopRight    = quadMapDataToPlane(quadMapDataTopRight);

    QuadMapData mergedQuadMapData;
    mergedQuadMapData.size = 0; // by default, ignore the quad

    // if any of the loaded proxy planes are empty, ignore the quad
    if (quadMapDataBottomLeft.size != 0 && quadMapDataBottomRight.size != 0 &&
            quadMapDataTopLeft.size != 0 && quadMapDataTopRight.size != 0 &&
                shouldMerge(proxyPlaneBottomLeft, proxyPlaneBottomRight, proxyPlaneTopLeft, proxyPlaneTopRight)) {
        // merge the proxy planes
        mergeQuadMapData(
            mergedQuadMapData,
            proxyPlaneBottomLeft, proxyPlaneBottomRight, proxyPlaneTopLeft, proxyPlaneTopRight,
            quadMapDataBottomLeft, quadMapDataBottomRight, quadMapDataTopLeft, quadMapDataTopRight
        );

        // ignore the previous proxy planes that have been merged
        ignoreInputQuadMapData(pixelCoordsBottomLeft);
        ignoreInputQuadMapData(pixelCoordsBottomRight);
        ignoreInputQuadMapData(pixelCoordsTopLeft);
        ignoreInputQuadMapData(pixelCoordsTopRight);
    }

    storeOutputQuadMap(pixelCoord, mergedQuadMapData);
}
