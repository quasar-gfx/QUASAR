layout(local_size_x = THREADS_PER_LOCALGROUP, local_size_y = 1, local_size_z = 1) in;

struct Vertex {
    vec3 position;
    vec3 color;
    vec3 normal;
    vec2 texCoords;
    vec3 texCoords3D;
    vec3 bitangent;
};

struct QuadMapData {
    vec3 normal;
    float depth;
    vec2 uv;
    uvec2 offset;
    uint size;
    bool flattened;
};

struct QuadMapDataPacked {
    uint normalSpherical;
    float depth;
    uint xy;
    uint offsetSizeFlattened;
};

struct Quad {
    vec3 bottomLeft;
    vec3 bottomRight;
    vec3 topLeft;
    vec3 topRight;
};

struct Quad2D {
    vec2 bottomLeft;
    vec2 bottomRight;
    vec2 topLeft;
    vec2 topRight;
};

struct Plane {
    vec3 normal;
    vec3 point;
};

layout(std430, binding = 0) buffer MeshBufferSizes {
    uint numVertices;
    uint numIndices;
};

layout(std430, binding = 1) buffer AtlasOffsetBuffer {
    uint atlasOffsetX;
    uint atlasOffsetY;
};

layout(std430, binding = 2) buffer VertexBuffer {
    Vertex vertices[];
};

layout(std430, binding = 3) buffer IndexBuffer {
    uint indices[];
};

layout(std430, binding = 4) buffer MeshIndirectCommandBuffer {
    uint count;
    uint instanceCount;
    uint firstIndex;
    uint baseVertex;
    uint baseInstance;
} meshIndirectCommandBuffer;

layout(std430, binding = 5) readonly buffer normalSphericalsBufferInput {
    uint normalSphericalsInput[];
};

layout(std430, binding = 6) readonly buffer depthBufferInput {
    float depthsInput[];
};

layout(std430, binding = 7) readonly buffer uvsBufferInput {
    uint uvsInput[];
};

layout(std430, binding = 8) readonly buffer offsetsBufferInput {
    uint offsetSizeFlattenedsInput[];
};

#ifdef PLATFORM_CORE
layout(r16f, binding = 0) uniform readonly image2D depthOffsetsBuffer;
#else
layout(rgba16f, binding = 0) uniform readonly image2D depthOffsetsBuffer;
#endif
// layout(rgba16f, binding = 1) uniform readonly image2D colorTexture;
// layout(rgba16f, binding = 2) uniform writeonly image2D atlas;

uniform bool appendGeometry;

uniform vec2 remoteWindowSize;
uniform vec2 atlasSize;

uniform uint quadMapSize;
uniform vec2 depthBufferSize;

uniform mat4 view;
uniform mat4 projection;
uniform mat4 viewInverse;
uniform mat4 projectionInverse;

uniform float near;
uniform float far;

#define MAX_DEPTH 0.9999

#define VERTICES_IN_A_QUAD  4u
#define INDICES_IN_A_QUAD   6u
#define NUM_SUB_QUADS       4u

const float epsilon = 1e-5;
const float PI = 3.1415926535897932384626433832795;

const float minVal = -1.0;
const float maxVal = 1.0;
const int numBits = 12;

const float surfelSize = 0.5;
const vec3 origin = vec3(0.0, 0.0, 0.0);

vec3 ndcToView(mat4 projectionInverse, vec2 ndc, float depth) {
    vec4 ndcPos;
    ndcPos.xy = ndc;
    ndcPos.z = depth * 2.0 - 1.0;
    ndcPos.w = 1.0;

    vec4 viewCoord = projectionInverse * ndcPos;
    viewCoord = viewCoord / viewCoord.w;
    return viewCoord.xyz;
}

vec3 viewToNDC(mat4 projection, vec3 viewCoord) {
    vec4 ndcCoord = projection * vec4(viewCoord, 1.0);
    ndcCoord = ndcCoord / ndcCoord.w;
    ndcCoord.z = (ndcCoord.z + 1.0) / 2.0;
    return ndcCoord.xyz;
}

vec3 viewToWorld(mat4 viewInverse, vec3 viewCoord) {
    vec4 worldCoord = viewInverse * vec4(viewCoord, 1.0);
    worldCoord = worldCoord / worldCoord.w;
    return worldCoord.xyz;
}

vec3 worldToView(mat4 view, vec3 worldCoord) {
    vec4 viewCoord = view * vec4(worldCoord, 1.0);
    viewCoord = viewCoord / viewCoord.w;
    return viewCoord.xyz;
}

vec2 viewToScreen(mat4 projection, vec3 viewCoord) {
    vec2 ndc = viewToNDC(projection, viewCoord).xy;
    vec2 uv = (ndc + 1.0) / 2.0;
    return uv;
}

vec2 worldToScreen(mat4 view, mat4 projection, vec3 worldCoord) {
    vec2 ndc = viewToNDC(projection, worldToView(view, worldCoord)).xy;
    vec2 uv = (ndc + 1.0) / 2.0;
    return uv;
}

vec3 rayPlaneIntersection(vec3 rayOrigin, vec3 rayDirection, Plane plane) {
    float denominator = dot(rayDirection, plane.normal);
    if (abs(denominator) < epsilon) {
        return vec3(0.0);
    }

    float t = dot(plane.point - rayOrigin, plane.normal) / denominator;
    if (t < 0.0) {
        return vec3(0.0);
    }

    vec3 intersection = rayOrigin + t * rayDirection;
    return intersection;
}

vec3 pointPlaneIntersection(vec3 pt, Plane plane) {
    vec3 rayDirection = normalize(pt);
    return rayPlaneIntersection(origin, rayDirection, plane);
}

vec3 lineLineIntersection(vec3 p0, vec3 p1, vec3 p2, vec3 p3) {
    vec3 d1 = p1 - p0;
    vec3 d2 = p3 - p2;
    vec3 r = p2 - p0;

    vec3 d1xd2 = cross(d1, d2);
    vec3 rxd2 = cross(r, d2);

    float denominator = dot(d1xd2, d1xd2);
    if (denominator < epsilon) {
        return vec3(0.0);
    }

    float t = dot(rxd2, d1xd2) / denominator;

    vec3 intersectionPoint = p0 + t * d1;
    return intersectionPoint;
}

vec3 unpackSphericalToNormalHalf(uint packedNormal) {
    vec2 spherical01 = unpackHalf2x16(packedNormal);

    float theta = spherical01.x * (2.0 * PI) - PI;
    float phi = spherical01.y * PI;

    return vec3(
        sin(phi) * cos(theta),
        cos(phi),
        sin(phi) * sin(theta)
    );
}

QuadMapData loadQuadMap(uint index) {
    QuadMapDataPacked quadMapDataPacked;
    quadMapDataPacked.normalSpherical = normalSphericalsInput[index];
    quadMapDataPacked.depth = depthsInput[index];
    quadMapDataPacked.xy = uvsInput[index];
    quadMapDataPacked.offsetSizeFlattened = offsetSizeFlattenedsInput[index];

    QuadMapData quadMapData;
    quadMapData.normal = unpackSphericalToNormalHalf(quadMapDataPacked.normalSpherical);
    quadMapData.depth = quadMapDataPacked.depth;

    quadMapData.offset.x = (quadMapDataPacked.offsetSizeFlattened >> 20) & 0xFFFu;
    quadMapData.offset.y = (quadMapDataPacked.offsetSizeFlattened >> 8) & 0xFFFu;

    uint flattenedAndSize = quadMapDataPacked.offsetSizeFlattened & 0xFFu;
    quadMapData.size = (flattenedAndSize >> 1) & 0x7Fu;
    quadMapData.flattened = (flattenedAndSize & 1u) != 0u;

    uint halfSize = 1u << (quadMapData.size - 1u); // 2^size / 2
    quadMapData.uv.x = float((quadMapDataPacked.xy >> 12) & 0xFFFu);
    quadMapData.uv.y = float((quadMapDataPacked.xy >> 0) & 0xFFFu);
    quadMapData.uv = (vec2(quadMapData.uv) + float(halfSize) * vec2(0.5)) / remoteWindowSize;

    return quadMapData;
}

float loadDepthOffset(in ivec2 pixelCoord) {
    return imageLoad(depthOffsetsBuffer, pixelCoord).x;
}

vec4 loadDepthOffsets(in ivec2 pixelCoord) {
    vec4 depthOffsets;
    depthOffsets.x = loadDepthOffset(pixelCoord + ivec2(0, 0));
    depthOffsets.y = loadDepthOffset(pixelCoord + ivec2(1, 0));
    depthOffsets.z = loadDepthOffset(pixelCoord + ivec2(0, 1));
    depthOffsets.w = loadDepthOffset(pixelCoord + ivec2(1, 1));
    return depthOffsets;
}

Plane quadMapDataToPlane(in QuadMapData quadMapData) {
    Plane proxyPlane;

    vec2 proxyPlaneUV = quadMapData.uv;
    float proxyPlaneDepth = quadMapData.depth;
    proxyPlane.normal = quadMapData.normal;

    vec2 proxyPlaneNDC = proxyPlaneUV * 2.0 - 1.0;
    proxyPlane.point = ndcToView(projectionInverse, proxyPlaneNDC, proxyPlaneDepth);

    return proxyPlane;
}

void createSurfel(out Quad surfel, in Quad2D surfelPixelCoords, in vec4 depthOffsets, in Plane proxyPlane) {
    Quad2D surfelUVs;
    surfelUVs.bottomLeft  = surfelPixelCoords.bottomLeft  / remoteWindowSize;
    surfelUVs.bottomRight = surfelPixelCoords.bottomRight / remoteWindowSize;
    surfelUVs.topLeft     = surfelPixelCoords.topLeft     / remoteWindowSize;
    surfelUVs.topRight    = surfelPixelCoords.topRight    / remoteWindowSize;

    Quad2D surfelNDCs;
    surfelNDCs.bottomLeft  = surfelUVs.bottomLeft  * 2.0 - 1.0;
    surfelNDCs.bottomRight = surfelUVs.bottomRight * 2.0 - 1.0;
    surfelNDCs.topLeft     = surfelUVs.topLeft     * 2.0 - 1.0;
    surfelNDCs.topRight    = surfelUVs.topRight    * 2.0 - 1.0;

    surfelNDCs.bottomLeft  += vec2(-epsilon, -epsilon);
    surfelNDCs.bottomRight += vec2(+epsilon, -epsilon);
    surfelNDCs.topLeft     += vec2(-epsilon, +epsilon);
    surfelNDCs.topRight    += vec2(+epsilon, +epsilon);

    Quad surfelNearPlane;
    surfelNearPlane.bottomLeft  = ndcToView(projectionInverse, surfelNDCs.bottomLeft, 0.0);
    surfelNearPlane.bottomRight = ndcToView(projectionInverse, surfelNDCs.bottomRight, 0.0);
    surfelNearPlane.topLeft     = ndcToView(projectionInverse, surfelNDCs.topLeft, 0.0);
    surfelNearPlane.topRight    = ndcToView(projectionInverse, surfelNDCs.topRight, 0.0);

    // shoot rays from corners of the surfel to the plane to find the 3D intersection points
    Quad quadPtsOnPlane;
    quadPtsOnPlane.bottomLeft  = pointPlaneIntersection(surfelNearPlane.bottomLeft,  proxyPlane);
    quadPtsOnPlane.bottomRight = pointPlaneIntersection(surfelNearPlane.bottomRight, proxyPlane);
    quadPtsOnPlane.topLeft     = pointPlaneIntersection(surfelNearPlane.topLeft,     proxyPlane);
    quadPtsOnPlane.topRight    = pointPlaneIntersection(surfelNearPlane.topRight,    proxyPlane);

    // apply depth offsets to the quad points
    surfel.bottomLeft  = quadPtsOnPlane.bottomLeft  - depthOffsets.x * normalize(quadPtsOnPlane.bottomLeft);
    surfel.bottomRight = quadPtsOnPlane.bottomRight - depthOffsets.y * normalize(quadPtsOnPlane.bottomRight);
    surfel.topLeft     = quadPtsOnPlane.topLeft     - depthOffsets.z * normalize(quadPtsOnPlane.topLeft);
    surfel.topRight    = quadPtsOnPlane.topRight    - depthOffsets.w * normalize(quadPtsOnPlane.topRight);
}

void storeSurfel(in Quad quad, in Quad2D uvsSrc, in QuadMapData quadMapData) {
    // // first, copy the color from the color texture to the atlas
    // ivec2 pixelCoordsBottomLeft = ivec2(uvsSrc.bottomLeft * remoteWindowSize);
    // ivec2 pixelCoordsBottomRight = ivec2(uvsSrc.bottomRight * remoteWindowSize);
    // ivec2 pixelCoordsTopLeft = ivec2(uvsSrc.topLeft * remoteWindowSize);
    // ivec2 pixelCoordsTopRight = ivec2(uvsSrc.topRight * remoteWindowSize);
    // for (int i = pixelCoordsBottomLeft.x; i <= pixelCoordsBottomRight.x; i++) {
    //     for (int j = pixelCoordsBottomLeft.y; j <= pixelCoordsTopLeft.y; j++) {
    //         ivec2 pixelCoords = ivec2(i, j);
    //         vec4 color = imageLoad(colorTexture, pixelCoords);

    //         ivec2 atlasPixelCoords = ivec2(atlasOffsetX, atlasOffsetY) + pixelCoords;
    //         imageStore(atlas, atlasPixelCoords, color);
    //     }
    // }

    // // then, find UVs for the quad in atlas space
    // Quad2D uvsAtlas;
    // uvsAtlas.bottomLeft  = vec2(ivec2(atlasOffsetX, atlasOffsetY) + pixelCoordsBottomLeft)  / atlasSize;
    // uvsAtlas.bottomRight = vec2(ivec2(atlasOffsetX, atlasOffsetY) + pixelCoordsBottomRight) / atlasSize;
    // uvsAtlas.topLeft     = vec2(ivec2(atlasOffsetX, atlasOffsetY) + pixelCoordsTopLeft)     / atlasSize;
    // uvsAtlas.topRight    = vec2(ivec2(atlasOffsetX, atlasOffsetY) + pixelCoordsTopRight)    / atlasSize;

    /************************

            tl -- tr
            |   / |
            | /   |
            bl -- br

    ************************/

    uint vertexIdxBase = atomicAdd(numVertices, VERTICES_IN_A_QUAD);

    uint vertexIdxTopLeft = vertexIdxBase + 0u;
    vertices[vertexIdxTopLeft].position = viewToWorld(viewInverse, quad.topLeft);
    vertices[vertexIdxTopLeft].color = vec3(1.0, 1.0, 1.0);
    vertices[vertexIdxTopLeft].texCoords = uvsSrc.topLeft;
    vertices[vertexIdxTopLeft].normal = quadMapData.normal;

    uint vertexIdxTopRight = vertexIdxBase + 1u;
    vertices[vertexIdxTopRight].position = viewToWorld(viewInverse, quad.topRight);
    vertices[vertexIdxTopRight].color = vec3(1.0, 1.0, 1.0);
    vertices[vertexIdxTopRight].texCoords = uvsSrc.topRight;
    vertices[vertexIdxTopRight].normal = quadMapData.normal;

    uint vertexIdxBottomLeft = vertexIdxBase + 2u;
    vertices[vertexIdxBottomLeft].position = viewToWorld(viewInverse, quad.bottomLeft);
    vertices[vertexIdxBottomLeft].color = vec3(1.0, 1.0, 1.0);
    vertices[vertexIdxBottomLeft].texCoords = uvsSrc.bottomLeft;
    vertices[vertexIdxBottomLeft].normal = quadMapData.normal;

    uint vertexIdxBottomRight = vertexIdxBase + 3u;
    vertices[vertexIdxBottomRight].position = viewToWorld(viewInverse, quad.bottomRight);
    vertices[vertexIdxBottomRight].color = vec3(1.0, 1.0, 1.0);
    vertices[vertexIdxBottomRight].texCoords = uvsSrc.bottomRight;
    vertices[vertexIdxBottomRight].normal = quadMapData.normal;

    vec3 vertPositionsView[4];
    vertPositionsView[0] = quad.bottomLeft;
    vertPositionsView[1] = quad.bottomRight;
    vertPositionsView[2] = quad.topRight;
    vertPositionsView[3] = quad.topLeft;

    // uv coordinates have to be in 3D to properly interpolate them in the fragment shader.
    // to do this, add a q component to the uvs and the fragment shader will perform perspective-correct interpolation.
    vec3 uvqs[4];
    uvqs[0] = vec3(vertices[vertexIdxBottomLeft].texCoords,  1.0);
    uvqs[1] = vec3(vertices[vertexIdxBottomRight].texCoords, 1.0);
    uvqs[2] = vec3(vertices[vertexIdxTopRight].texCoords,    1.0);
    uvqs[3] = vec3(vertices[vertexIdxTopLeft].texCoords,     1.0);

    // adapted from:
    // https://www.roxlu.com/2014/026/mapping-a-texture-on-a-disc and
    // https://www.reedbeta.com/blog/quadrilateral-interpolation-part-1/
    float vertDistanceToCenter[4];
    vec3 intersectPointView = lineLineIntersection(
                                vertPositionsView[0], vertPositionsView[2],
                                vertPositionsView[1], vertPositionsView[3]);
    for (int i = 0; i < 4; i++) {
        float dist = distance(intersectPointView, vertPositionsView[i]);
        vertDistanceToCenter[i] = dist;
    }
    for (int i = 0; i < 4; i++) {
        int i2 = (i + 2) % 4;
        uvqs[i] = uvqs[i] * ((vertDistanceToCenter[i] + vertDistanceToCenter[i2]) / vertDistanceToCenter[i2]);
    }

    vertices[vertexIdxBottomLeft].texCoords3D  = uvqs[0];
    vertices[vertexIdxBottomRight].texCoords3D = uvqs[1];
    vertices[vertexIdxTopRight].texCoords3D    = uvqs[2];
    vertices[vertexIdxTopLeft].texCoords3D     = uvqs[3];

    uint indexIdxBase = atomicAdd(numIndices, INDICES_IN_A_QUAD);

    indices[indexIdxBase + 0u] = vertexIdxTopLeft;
    indices[indexIdxBase + 1u] = vertexIdxBottomLeft;
    indices[indexIdxBase + 2u] = vertexIdxTopRight;

    indices[indexIdxBase + 3u] = vertexIdxTopRight;
    indices[indexIdxBase + 4u] = vertexIdxBottomLeft;
    indices[indexIdxBase + 5u] = vertexIdxBottomRight;
}

void quantizeDepthOffsets(in vec4 depthOffsets, out ivec4 depthOffsetsQuantized) {
    const float maxValueBits = float(2 << numBits - 1);

    vec4 depthOffsetsNormalized = (depthOffsets - minVal) / (maxVal - minVal);
    depthOffsetsQuantized = ivec4(
        int(depthOffsetsNormalized.x * maxValueBits),
        int(depthOffsetsNormalized.y * maxValueBits),
        int(depthOffsetsNormalized.z * maxValueBits),
        int(depthOffsetsNormalized.w * maxValueBits)
    );
}

void unQuantizeDepthOffsets(in ivec4 depthOffsetsQuantized, out vec4 depthOffsets) {
    const float maxValueBits = float(2 << numBits - 1);

    depthOffsets.x = float(depthOffsetsQuantized.x) / maxValueBits;
    depthOffsets.y = float(depthOffsetsQuantized.y) / maxValueBits;
    depthOffsets.z = float(depthOffsetsQuantized.z) / maxValueBits;
    depthOffsets.w = float(depthOffsetsQuantized.w) / maxValueBits;

    depthOffsets = depthOffsets * (maxVal - minVal) + minVal;
}

void storeSurfelsFromQuadMap(in QuadMapData quadMapData) {
    // extract the plane normal and point from the quad map
    Plane proxyPlane = quadMapDataToPlane(quadMapData);

    vec2 proxyPlaneUV = quadMapData.uv;
    vec2 proxyPlanePixelCoords = vec2(proxyPlaneUV * remoteWindowSize);

    uint size = 1u << quadMapData.size;
    float halfGridSize = float(size) * surfelSize / 2.0;

    bool flattened = quadMapData.flattened;
    if (!flattened) {
        vec2 start = proxyPlanePixelCoords - vec2(halfGridSize);
        vec2 stepSize = vec2(0.5);

        // create surfels for each subpixel in the quad map
        for (uint i = 0u; i < size; i++) {
            vec2 rowStart = start + vec2(float(i) * stepSize.x, 0.0);
            for (uint j = 0u; j < size; j++) {
                vec2 surfelBaseCoord = rowStart + vec2(0.0, float(j) * stepSize.y);

                Quad2D surfelPixelCoords;
                surfelPixelCoords.bottomLeft  = surfelBaseCoord;
                surfelPixelCoords.bottomRight = surfelBaseCoord + vec2(stepSize.x, 0.0);
                surfelPixelCoords.topLeft     = surfelBaseCoord + vec2(0.0, stepSize.y);
                surfelPixelCoords.topRight    = surfelBaseCoord + stepSize;

                vec4 depthOffsets = loadDepthOffsets(4 * ivec2(quadMapData.offset) + 2 * ivec2(i, j));
                // ivec4 depthOffsetsQuantized;
                // quantizeDepthOffsets(depthOffsets, depthOffsetsQuantized); // quantize depth offsets
                // unQuantizeDepthOffsets(depthOffsetsQuantized, depthOffsets); // recover depth offsets
                Quad surfel;
                createSurfel(surfel, surfelPixelCoords, depthOffsets, proxyPlane);

                Quad2D surfelUVs;
                surfelUVs.bottomLeft  = surfelPixelCoords.bottomLeft  / remoteWindowSize;
                surfelUVs.bottomRight = surfelPixelCoords.bottomRight / remoteWindowSize;
                surfelUVs.topLeft     = surfelPixelCoords.topLeft     / remoteWindowSize;
                surfelUVs.topRight    = surfelPixelCoords.topRight    / remoteWindowSize;
                storeSurfel(surfel, surfelUVs, quadMapData);
            }
        }
    }
    else {
        // create a single surfel for the quad map
        Quad2D surfelPixelCoords;
        surfelPixelCoords.bottomLeft  = proxyPlanePixelCoords + vec2(-halfGridSize, -halfGridSize);
        surfelPixelCoords.bottomRight = proxyPlanePixelCoords + vec2(+halfGridSize, -halfGridSize);
        surfelPixelCoords.topLeft     = proxyPlanePixelCoords + vec2(-halfGridSize, +halfGridSize);
        surfelPixelCoords.topRight    = proxyPlanePixelCoords + vec2(+halfGridSize, +halfGridSize);

        Quad surfel;
        vec4 depthOffsets = vec4(0.0);
        createSurfel(surfel, surfelPixelCoords, depthOffsets, proxyPlane);

        Quad2D surfelUVs;
        surfelUVs.bottomLeft  = surfelPixelCoords.bottomLeft  / remoteWindowSize;
        surfelUVs.bottomRight = surfelPixelCoords.bottomRight / remoteWindowSize;
        surfelUVs.topLeft     = surfelPixelCoords.topLeft     / remoteWindowSize;
        surfelUVs.topRight    = surfelPixelCoords.topRight    / remoteWindowSize;
        storeSurfel(surfel, surfelUVs, quadMapData);
    }
}

void main() {
    uint quadMapIndex = gl_GlobalInvocationID.x;
    if (quadMapIndex >= quadMapSize) {
        return;
    }

    // reset buffers on first invocation
    if (quadMapIndex == 0u) {
        if (!appendGeometry) {
            atomicExchange(numVertices, 0u);
            atomicExchange(numIndices, 0u);
            atomicExchange(atlasOffsetX, 0u);
            atomicExchange(atlasOffsetY, 0u);
        }
        else {
            uint oldAtlasOffsetX = atomicAdd(atlasOffsetX, uint(remoteWindowSize.x));
            if (oldAtlasOffsetX + uint(remoteWindowSize.x) >= uint(atlasSize.x)) {
                atomicExchange(atlasOffsetX, 0u);
                atomicAdd(atlasOffsetY, uint(remoteWindowSize.y));
            }
        }
    }
    memoryBarrier();

    QuadMapData quadMapData = loadQuadMap(quadMapIndex);
    storeSurfelsFromQuadMap(quadMapData);

    meshIndirectCommandBuffer.count = numIndices;
    memoryBarrier();
}
