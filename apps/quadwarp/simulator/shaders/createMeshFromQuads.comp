layout(local_size_x = THREADS_PER_LOCALGROUP, local_size_y = THREADS_PER_LOCALGROUP, local_size_z = 1) in;

struct Vertex {
    vec3 position;
    vec3 texCoords3D;
};

struct QuadMapData {
    vec3 normal;
    float depth;
    vec2 uv;
    uvec2 offset;
    uint size;
    bool flattened;
};

struct QuadMapDataPacked {
    uint normalSpherical;
    float depth;
    uint offsetSizeFlattened;
};

struct Quad {
    vec3 bottomLeft;
    vec3 bottomRight;
    vec3 topLeft;
    vec3 topRight;
};

struct Quad2D {
    vec2 bottomLeft;
    vec2 bottomRight;
    vec2 topLeft;
    vec2 topRight;
};

struct Plane {
    vec3 normal;
    vec3 point;
};

layout(std430, binding = 0) buffer MeshBufferSizes {
    uint numVertices;
    uint numIndices;
};

layout(std430, binding = 1) readonly buffer QuadCreatedFlagsBuffer {
    int quadCreatedFlags[];
};

layout(std430, binding = 2) buffer VertexBuffer {
    Vertex vertices[];
};

layout(std430, binding = 3) buffer IndexBuffer {
    uint indices[];
};

layout(std430, binding = 4) buffer MeshIndirectCommandBuffer {
    uint count;
    uint instanceCount;
    uint firstIndex;
    uint baseVertex;
    uint baseInstance;
} meshIndirectCommandBuffer;

layout(std430, binding = 5) readonly buffer NormalSphericalsBufferInput {
    uint normalSphericalsInput[];
};

layout(std430, binding = 6) readonly buffer DepthBufferInput {
    float depthsInput[];
};

layout(std430, binding = 7) readonly buffer OffsetsBufferInput {
    uint offsetSizeFlattenedsInput[];
};

layout(std430, binding = 8) readonly buffer QuadIndicesBuffer {
    uint quadIndices[];
};

layout(std430, binding = 9) readonly buffer CurrNumProxiesBuffer {
    uint currNumProxies;
};

layout(rgba16f, binding = 0) uniform readonly image2D depthOffsetsBuffer;

uniform vec2 remoteWindowSize;
uniform vec2 depthBufferSize;
uniform vec2 atlasSize;

uniform mat4 view;
uniform mat4 projection;
uniform mat4 viewInverse;
uniform mat4 projectionInverse;
uniform float near;
uniform float far;

#define MAX_DEPTH 0.9999

#define VERTICES_IN_A_QUAD  4u
#define INDICES_IN_A_QUAD   6u
#define NUM_SUB_QUADS       4u

const float epsilon = 1e-5;
const float PI = 3.1415926535897932384626433832795;

const float minVal = -1.0;
const float maxVal = 1.0;
const int numBits = 12;

const float surfelSize = 0.5;
const vec3 origin = vec3(0.0, 0.0, 0.0);

vec3 ndcToView(mat4 projectionInverse, vec2 ndc, float depth) {
    vec4 ndcPos;
    ndcPos.xy = ndc;
    ndcPos.z = depth * 2.0 - 1.0;
    ndcPos.w = 1.0;

    vec4 viewCoord = projectionInverse * ndcPos;
    viewCoord = viewCoord / viewCoord.w;
    return viewCoord.xyz;
}

vec3 viewToWorld(mat4 viewInverse, vec3 viewCoord) {
    vec4 worldCoord = viewInverse * vec4(viewCoord, 1.0);
    worldCoord = worldCoord / worldCoord.w;
    return worldCoord.xyz;
}

vec3 rayPlaneIntersection(vec3 rayOrigin, vec3 rayDirection, Plane plane) {
    float denominator = dot(rayDirection, plane.normal);
    if (abs(denominator) < epsilon) {
        return vec3(0.0);
    }

    float t = dot(plane.point - rayOrigin, plane.normal) / denominator;
    if (t < 0.0) {
        return vec3(0.0);
    }

    vec3 intersection = rayOrigin + t * rayDirection;
    return intersection;
}

vec3 pointPlaneIntersection(vec3 pt, Plane plane) {
    vec3 rayDirection = normalize(pt);
    return rayPlaneIntersection(origin, rayDirection, plane);
}

vec3 lineLineIntersection(vec3 p0, vec3 p1, vec3 p2, vec3 p3) {
    vec3 d1 = p1 - p0;
    vec3 d2 = p3 - p2;
    vec3 r = p2 - p0;

    vec3 d1xd2 = cross(d1, d2);
    vec3 rxd2 = cross(r, d2);

    float denominator = dot(d1xd2, d1xd2);
    if (denominator < epsilon) {
        return vec3(0.0);
    }

    float t = dot(rxd2, d1xd2) / denominator;

    vec3 intersectionPoint = p0 + t * d1;
    return intersectionPoint;
}

vec3 unpackSphericalToNormalHalf(uint packedNormal) {
    vec2 spherical01 = unpackHalf2x16(packedNormal);

    float theta = spherical01.x * (2.0 * PI) - PI;
    float phi = spherical01.y * PI;

    return vec3(
        sin(phi) * cos(theta),
        cos(phi),
        sin(phi) * sin(theta)
    );
}

QuadMapData loadQuadMap(uint index) {
    QuadMapDataPacked quadMapDataPacked;
    quadMapDataPacked.normalSpherical = normalSphericalsInput[index];
    quadMapDataPacked.depth = depthsInput[index];
    quadMapDataPacked.offsetSizeFlattened = offsetSizeFlattenedsInput[index];

    QuadMapData quadMapData;
    quadMapData.normal = unpackSphericalToNormalHalf(quadMapDataPacked.normalSpherical);
    quadMapData.depth = quadMapDataPacked.depth;

    quadMapData.offset.x = (quadMapDataPacked.offsetSizeFlattened >> 20) & 0xFFFu;
    quadMapData.offset.y = (quadMapDataPacked.offsetSizeFlattened >> 8) & 0xFFFu;

    uint flattenedAndSize = quadMapDataPacked.offsetSizeFlattened & 0xFFu;
    quadMapData.size = (flattenedAndSize >> 1) & 0x7Fu;
    quadMapData.flattened = (flattenedAndSize & 1u) != 0u;

    uint halfSize = 1u << (quadMapData.size - 1u); // 2^size / 2
    quadMapData.uv = (vec2(quadMapData.offset) + float(halfSize) * vec2(0.5)) / remoteWindowSize;

    return quadMapData;
}

vec4 loadDepthOffsets(in ivec2 pixelCoord) {
    return imageLoad(depthOffsetsBuffer, pixelCoord);
}

uint loadQuadMapIndex(ivec2 pixelCoords) {
    uint pixelIndex = uint(pixelCoords.y) * uint(remoteWindowSize.x) + uint(pixelCoords.x);
    return quadIndices[pixelIndex];
}

Plane quadMapDataToPlane(in QuadMapData quadMapData) {
    Plane proxyPlane;

    vec2 proxyPlaneUV = quadMapData.uv;
    float proxyPlaneDepth = quadMapData.depth;
    proxyPlane.normal = quadMapData.normal;

    vec2 proxyPlaneNDC = proxyPlaneUV * 2.0 - 1.0;
    proxyPlane.point = ndcToView(projectionInverse, proxyPlaneNDC, proxyPlaneDepth);

    return proxyPlane;
}

void createSurfel(out Quad surfel, in Quad2D surfelPixelCoords, in vec4 depthOffsets, in Plane proxyPlane) {
    Quad2D surfelUVs;
    surfelUVs.bottomLeft  = surfelPixelCoords.bottomLeft  / remoteWindowSize;
    surfelUVs.bottomRight = surfelPixelCoords.bottomRight / remoteWindowSize;
    surfelUVs.topLeft     = surfelPixelCoords.topLeft     / remoteWindowSize;
    surfelUVs.topRight    = surfelPixelCoords.topRight    / remoteWindowSize;

    Quad2D surfelNDCs;
    surfelNDCs.bottomLeft  = surfelUVs.bottomLeft  * 2.0 - 1.0;
    surfelNDCs.bottomRight = surfelUVs.bottomRight * 2.0 - 1.0;
    surfelNDCs.topLeft     = surfelUVs.topLeft     * 2.0 - 1.0;
    surfelNDCs.topRight    = surfelUVs.topRight    * 2.0 - 1.0;

    surfelNDCs.bottomLeft  += vec2(-0.02, -0.02) / remoteWindowSize;
    surfelNDCs.bottomRight += vec2(+0.02, -0.02) / remoteWindowSize;
    surfelNDCs.topLeft     += vec2(-0.02, +0.02) / remoteWindowSize;
    surfelNDCs.topRight    += vec2(+0.02, +0.02) / remoteWindowSize;

    Quad surfelNearPlane;
    surfelNearPlane.bottomLeft  = ndcToView(projectionInverse, surfelNDCs.bottomLeft, 0.0);
    surfelNearPlane.bottomRight = ndcToView(projectionInverse, surfelNDCs.bottomRight, 0.0);
    surfelNearPlane.topLeft     = ndcToView(projectionInverse, surfelNDCs.topLeft, 0.0);
    surfelNearPlane.topRight    = ndcToView(projectionInverse, surfelNDCs.topRight, 0.0);

    // shoot rays from corners of the surfel to the plane to find the 3D intersection points
    Quad quadPtsOnPlane;
    quadPtsOnPlane.bottomLeft  = pointPlaneIntersection(surfelNearPlane.bottomLeft,  proxyPlane);
    quadPtsOnPlane.bottomRight = pointPlaneIntersection(surfelNearPlane.bottomRight, proxyPlane);
    quadPtsOnPlane.topLeft     = pointPlaneIntersection(surfelNearPlane.topLeft,     proxyPlane);
    quadPtsOnPlane.topRight    = pointPlaneIntersection(surfelNearPlane.topRight,    proxyPlane);

    // apply depth offsets to the quad points
    surfel.bottomLeft  = quadPtsOnPlane.bottomLeft  + depthOffsets.x * normalize(quadPtsOnPlane.bottomLeft);
    surfel.bottomRight = quadPtsOnPlane.bottomRight + depthOffsets.y * normalize(quadPtsOnPlane.bottomRight);
    surfel.topLeft     = quadPtsOnPlane.topLeft     + depthOffsets.z * normalize(quadPtsOnPlane.topLeft);
    surfel.topRight    = quadPtsOnPlane.topRight    + depthOffsets.w * normalize(quadPtsOnPlane.topRight);
}

void storeSurfel(in Quad quad, in Quad2D uvsSrc, in QuadMapData quadMapData) {
    /************************

            tl -- tr
            |   / |
            | /   |
            bl -- br

    ************************/

    uint vertexIdxBase = atomicAdd(numVertices, VERTICES_IN_A_QUAD);

    uint vertexIdxTopLeft = vertexIdxBase + 0u;
    vertices[vertexIdxTopLeft].position = viewToWorld(viewInverse, quad.topLeft);

    uint vertexIdxTopRight = vertexIdxBase + 1u;
    vertices[vertexIdxTopRight].position = viewToWorld(viewInverse, quad.topRight);

    uint vertexIdxBottomLeft = vertexIdxBase + 2u;
    vertices[vertexIdxBottomLeft].position = viewToWorld(viewInverse, quad.bottomLeft);

    uint vertexIdxBottomRight = vertexIdxBase + 3u;
    vertices[vertexIdxBottomRight].position = viewToWorld(viewInverse, quad.bottomRight);

    vec3 vertPositionsView[4];
    vertPositionsView[0] = quad.bottomLeft;
    vertPositionsView[1] = quad.bottomRight;
    vertPositionsView[2] = quad.topRight;
    vertPositionsView[3] = quad.topLeft;

    // uv coordinates have to be in 3D to properly interpolate them in the fragment shader.
    // to do this, add a q component to the uvs and the fragment shader will perform perspective-correct interpolation.
    vec3 uvqs[4];
    uvqs[0] = vec3(uvsSrc.bottomLeft,  1.0);
    uvqs[1] = vec3(uvsSrc.bottomRight, 1.0);
    uvqs[2] = vec3(uvsSrc.topRight,    1.0);
    uvqs[3] = vec3(uvsSrc.topLeft, 1.0);

    // adapted from:
    // https://www.roxlu.com/2014/026/mapping-a-texture-on-a-disc and
    // https://www.reedbeta.com/blog/quadrilateral-interpolation-part-1/
    float vertDistanceToCenter[4];
    vec3 intersectPointView = lineLineIntersection(
                                vertPositionsView[0], vertPositionsView[2],
                                vertPositionsView[1], vertPositionsView[3]);
    for (int i = 0; i < 4; i++) {
        float dist = distance(intersectPointView, vertPositionsView[i]);
        vertDistanceToCenter[i] = dist;
    }
    for (int i = 0; i < 4; i++) {
        int i2 = (i + 2) % 4;
        uvqs[i] = uvqs[i] * ((vertDistanceToCenter[i] + vertDistanceToCenter[i2]) / vertDistanceToCenter[i2]);
    }

    vertices[vertexIdxBottomLeft].texCoords3D  = uvqs[0];
    vertices[vertexIdxBottomRight].texCoords3D = uvqs[1];
    vertices[vertexIdxTopRight].texCoords3D    = uvqs[2];
    vertices[vertexIdxTopLeft].texCoords3D     = uvqs[3];

    uint indexIdxBase = atomicAdd(numIndices, INDICES_IN_A_QUAD);

    indices[indexIdxBase + 0u] = vertexIdxBottomLeft;
    indices[indexIdxBase + 1u] = vertexIdxBottomRight;
    indices[indexIdxBase + 2u] = vertexIdxTopRight;

    indices[indexIdxBase + 3u] = vertexIdxTopRight;
    indices[indexIdxBase + 4u] = vertexIdxTopLeft;
    indices[indexIdxBase + 5u] = vertexIdxBottomLeft;
}

// void quantizeDepthOffsets(in vec4 depthOffsets, out ivec4 depthOffsetsQuantized) {
//     const float maxValueBits = float(2 << numBits - 1);

//     vec4 depthOffsetsNormalized = (depthOffsets - minVal) / (maxVal - minVal);
//     depthOffsetsQuantized = ivec4(
//         int(depthOffsetsNormalized.x * maxValueBits),
//         int(depthOffsetsNormalized.y * maxValueBits),
//         int(depthOffsetsNormalized.z * maxValueBits),
//         int(depthOffsetsNormalized.w * maxValueBits)
//     );
// }

// void unQuantizeDepthOffsets(in ivec4 depthOffsetsQuantized, out vec4 depthOffsets) {
//     const float maxValueBits = float(2 << numBits - 1);

//     depthOffsets.x = float(depthOffsetsQuantized.x) / maxValueBits;
//     depthOffsets.y = float(depthOffsetsQuantized.y) / maxValueBits;
//     depthOffsets.z = float(depthOffsetsQuantized.z) / maxValueBits;
//     depthOffsets.w = float(depthOffsetsQuantized.w) / maxValueBits;

//     depthOffsets = depthOffsets * (maxVal - minVal) + minVal;
// }

void storeSurfelsFromQuadMap(in QuadMapData quadMapData) {
    // extract the plane normal and point from the quad map
    Plane proxyPlane = quadMapDataToPlane(quadMapData);

    vec2 proxyPlaneUV = quadMapData.uv;
    vec2 proxyPlanePixelCoords = vec2(proxyPlaneUV * remoteWindowSize);

    uint size = 1u << quadMapData.size;
    float halfGridSize = float(size) * surfelSize / 2.0;

    bool flattened = quadMapData.flattened;
    if (!flattened) {
        // create surfels for each subpixel in the quad map
        vec2 baseCoord = proxyPlanePixelCoords - vec2(halfGridSize);
        vec2 stepSize = vec2(surfelSize);
        for (uint idx = 0u; idx < size * size; idx++) {
            uint i = idx % size;
            uint j = idx / size;
            vec2 surfelBaseCoord = baseCoord + vec2(i, j) * stepSize;

            Quad2D surfelPixelCoords;
            surfelPixelCoords.bottomLeft  = surfelBaseCoord + vec2(0.0, 0.0);
            surfelPixelCoords.bottomRight = surfelBaseCoord + vec2(stepSize.x, 0.0);
            surfelPixelCoords.topLeft     = surfelBaseCoord + vec2(0.0, stepSize.y);
            surfelPixelCoords.topRight    = surfelBaseCoord + stepSize;

            ivec2 depthOffsetPixelCoords = 2 * ivec2(quadMapData.offset) + ivec2(i, j);
            vec4 depthOffsets = loadDepthOffsets(depthOffsetPixelCoords);
            // ivec4 depthOffsetsQuantized;
            // quantizeDepthOffsets(depthOffsets, depthOffsetsQuantized); // quantize depth offsets
            // unQuantizeDepthOffsets(depthOffsetsQuantized, depthOffsets); // recover depth offsets
            Quad surfel;
            createSurfel(surfel, surfelPixelCoords, depthOffsets, proxyPlane);

            Quad2D surfelUVs;
            surfelUVs.bottomLeft  = surfelPixelCoords.bottomLeft  / remoteWindowSize;
            surfelUVs.bottomRight = surfelPixelCoords.bottomRight / remoteWindowSize;
            surfelUVs.topLeft     = surfelPixelCoords.topLeft     / remoteWindowSize;
            surfelUVs.topRight    = surfelPixelCoords.topRight    / remoteWindowSize;
            storeSurfel(surfel, surfelUVs, quadMapData);
        }
    }
    else {
        // create a single surfel for the quad map
        Quad2D surfelPixelCoords;
        surfelPixelCoords.bottomLeft  = proxyPlanePixelCoords + vec2(-halfGridSize, -halfGridSize);
        surfelPixelCoords.bottomRight = proxyPlanePixelCoords + vec2(+halfGridSize, -halfGridSize);
        surfelPixelCoords.topLeft     = proxyPlanePixelCoords + vec2(-halfGridSize, +halfGridSize);
        surfelPixelCoords.topRight    = proxyPlanePixelCoords + vec2(+halfGridSize, +halfGridSize);

        Quad surfel;
        vec4 depthOffsets = vec4(0.0);
        createSurfel(surfel, surfelPixelCoords, depthOffsets, proxyPlane);

        Quad2D surfelUVs;
        surfelUVs.bottomLeft  = surfelPixelCoords.bottomLeft  / remoteWindowSize;
        surfelUVs.bottomRight = surfelPixelCoords.bottomRight / remoteWindowSize;
        surfelUVs.topLeft     = surfelPixelCoords.topLeft     / remoteWindowSize;
        surfelUVs.topRight    = surfelPixelCoords.topRight    / remoteWindowSize;
        storeSurfel(surfel, surfelUVs, quadMapData);
    }
}

void main() {
    uvec2 quadIndicesPixelCoord = gl_GlobalInvocationID.xy;
    if (quadIndicesPixelCoord.x >= uint(remoteWindowSize.x) || quadIndicesPixelCoord.y >= uint(remoteWindowSize.y)) {
        return;
    }

    // reset buffers on first invocation
    if (quadIndicesPixelCoord == uvec2(0u)) {
        // reset mesh buffers
        atomicExchange(numVertices, 0u);
        atomicExchange(numIndices, 0u);
        atomicExchange(meshIndirectCommandBuffer.count, 0u);
    }

    // uint quadMapIndex = quadIndicesPixelCoord.y * uint(remoteWindowSize.x) + quadIndicesPixelCoord.x;
    uint quadMapIndex = loadQuadMapIndex(ivec2(quadIndicesPixelCoord));
    if (quadMapIndex >= currNumProxies) {
        return;
    }

    // if the quad has already been created, skip it
    bool quadCreated = bool(atomicExchange(quadCreatedFlags[quadMapIndex], 1));
    if (quadCreated) {
        return;
    }

    QuadMapData quadMapData = loadQuadMap(quadMapIndex);
    storeSurfelsFromQuadMap(quadMapData);

    atomicExchange(meshIndirectCommandBuffer.count, numIndices);
}
