layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(binding = 0) uniform sampler2D positionMap;
layout(binding = 1) uniform sampler2D normalMap;
layout(binding = 2) uniform sampler2D idMap;
layout(binding = 3) uniform sampler2D depthMap;

struct Vertex {
    uint id;
    vec3 position;
    vec3 color;
    vec3 normal;
    vec2 texCoords;
    vec3 tangent;
    vec3 bitangent;
};

layout(std430, binding = 0) buffer VertexBuffer {
    Vertex vertices[];
};

layout(std430, binding = 1) buffer IndexBuffer {
    uint indices[];
};

uniform vec2 screenSize;

uniform mat4 view;
uniform mat4 projection;
uniform mat4 viewInverse;
uniform mat4 projectionInverse;

uniform float near;
uniform float far;

uniform int surfelSize;

const float epilson = 1e-5;

const vec3 forward = vec3(0.0, 0.0, -1.0);

#define MAX_DEPTH 0.99999

#define VERTICES_IN_A_QUAD  4
#define INDICES_IN_A_QUAD   6
#define NUM_SUB_QUADS       4

vec3 ndcToView(mat4 projectionInverse, vec2 ndc, float depth) {
    depth = clamp(depth, 0.0, MAX_DEPTH);

    vec4 ndcPos;
    ndcPos.xy = ndc;
    ndcPos.z = 2.0 * depth - 1.0;
    ndcPos.w = 1.0;

    vec4 viewCoord = projectionInverse * ndcPos;
    viewCoord = viewCoord / viewCoord.w;
    return viewCoord.xyz;
}

vec3 viewToWorld(mat4 viewInverse, vec3 viewCoord) {
    vec4 worldCoord = viewInverse * vec4(viewCoord, 1.0);
    worldCoord = worldCoord / worldCoord.w;
    return worldCoord.xyz;
}

vec3 worldToView(mat4 view, vec3 worldCoord) {
    vec4 viewCoord = view * vec4(worldCoord, 1.0);
    viewCoord = viewCoord / viewCoord.w;
    return viewCoord.xyz;
}

vec2 viewToNDC(mat4 projection, vec3 viewCoord) {
    vec4 ndcCoord = projection * vec4(viewCoord, 1.0);
    ndcCoord = ndcCoord / ndcCoord.w;
    return ndcCoord.xy;
}

vec2 ndcToScreen(vec2 ndc) {
    return (ndc + 1.0) / 2.0;
}

vec2 worldToScreen(mat4 view, mat4 projection, vec3 worldCoord) {
    vec2 ndc = viewToNDC(projection, worldToView(view, worldCoord));
    return ndcToScreen(ndc);
}

vec3 sampleNormal(sampler2D normalMap, vec2 sampleCoord) {
    return normalize(texture(normalMap, sampleCoord).xyz);
}

float sampleDepth(sampler2D depthMap, vec2 sampleCoord) {
    float depth = texture(depthMap, sampleCoord).x;
    depth = clamp(depth, 0.0, MAX_DEPTH);
    return depth;
}

vec3 normalToView(mat4 view, vec3 normalWorld) {
    // extract the rotation part of the view matrix
    mat3 rotationMatrix = mat3(view);
    vec3 normalView = normalize(rotationMatrix * normalWorld);
    return normalView;
}

float LinearizeDepth(float depth) {
    float z = depth * 2.0 - 1.0; // back to NDC
    return (2.0 * near * far) / (far + near - z * (far - near));
}

float NormalizeDepth(float depth) {
    depth = clamp(depth, near, far);
    float z = (depth - near) / (far - near);
    return (1.0 - (1.0 / (1.0 + z * (far - near) / near)));
}

vec3 planeRayIntersection(vec3 rayOrigin, vec3 rayDirection, vec3 planePoint, vec3 planeNormal) {
    float denominator = dot(rayDirection, planeNormal);
    if (abs(denominator) < epilson) {
        return vec3(1.0/0.0, 1.0/0.0, 1.0/0.0);
    }

    float t = dot(planePoint - rayOrigin, planeNormal) / denominator;
    if (t < 0.0) {
        return vec3(1.0/0.0, 1.0/0.0, 1.0/0.0);
    }

    vec3 intersection = rayOrigin + t * rayDirection;
    return intersection;
}

void createSubQuad(
        vec3 planePoint, vec3 planeNormal,
        vec2 ndcTopLeft, vec2 ndcTopRight, vec2 ndcBottomLeft, vec2 ndcBottomRight,
        float x, float y, vec2 size,
        uint shaderIndex, uint vertexOffset, uint indexOffset
    )
{
    /************************

            tl -- tr
            |   / |
            | /   |
            bl -- br

    ************************/
    vec3 rayOrigin = vec3(0.0);

    vec3 rayDirectionBottomLeft = normalize(ndcToView(projectionInverse, ndcBottomLeft, 1));
    vec3 viewCoordBottomLeft = planeRayIntersection(rayOrigin, rayDirectionBottomLeft, planePoint, planeNormal);

    vec3 rayDirectionBottomRight = normalize(ndcToView(projectionInverse, ndcBottomRight, 1));
    vec3 viewCoordBottomRight = planeRayIntersection(rayOrigin, rayDirectionBottomRight, planePoint, planeNormal);

    vec3 rayDirectionTopLeft = normalize(ndcToView(projectionInverse, ndcTopLeft, 1));
    vec3 viewCoordTopLeft = planeRayIntersection(rayOrigin, rayDirectionTopLeft, planePoint, planeNormal);

    vec3 rayDirectionTopRight = normalize(ndcToView(projectionInverse, ndcTopRight, 1));
    vec3 viewCoordTopRight = planeRayIntersection(rayOrigin, rayDirectionTopRight, planePoint, planeNormal);

    uint vertexIndexTopLeft  = shaderIndex * NUM_SUB_QUADS * VERTICES_IN_A_QUAD + vertexOffset + 0;
    vertices[vertexIndexTopLeft] .position = viewToWorld(viewInverse, viewCoordTopLeft);
    vertices[vertexIndexTopLeft] .color = vec3(1.0, 1.0, 1.0);
    vertices[vertexIndexTopLeft] .texCoords = worldToScreen(view, projection, viewToWorld(viewInverse, viewCoordTopLeft));

    uint vertexIndexTopRight = shaderIndex * NUM_SUB_QUADS * VERTICES_IN_A_QUAD + vertexOffset + 1;
    vertices[vertexIndexTopRight].position = viewToWorld(viewInverse, viewCoordTopRight);
    vertices[vertexIndexTopRight].color = vec3(1.0, 1.0, 1.0);
    vertices[vertexIndexTopRight].texCoords = worldToScreen(view, projection, viewToWorld(viewInverse, viewCoordTopRight));

    uint vertexIndexBottomLeft  = shaderIndex * NUM_SUB_QUADS * VERTICES_IN_A_QUAD + vertexOffset + 2;
    vertices[vertexIndexBottomLeft] .position = viewToWorld(viewInverse, viewCoordBottomLeft);
    vertices[vertexIndexBottomLeft] .color = vec3(1.0, 1.0, 1.0);
    vertices[vertexIndexBottomLeft] .texCoords = worldToScreen(view, projection, viewToWorld(viewInverse, viewCoordBottomLeft));

    uint vertexIndexBottomRight = shaderIndex * NUM_SUB_QUADS * VERTICES_IN_A_QUAD + vertexOffset + 3;
    vertices[vertexIndexBottomRight].position = viewToWorld(viewInverse, viewCoordBottomRight);
    vertices[vertexIndexBottomRight].color = vec3(1.0, 1.0, 1.0);
    vertices[vertexIndexBottomRight].texCoords = worldToScreen(view, projection, viewToWorld(viewInverse, viewCoordBottomRight));

    indices[shaderIndex * NUM_SUB_QUADS * 6 + indexOffset + 0] = vertexIndexTopLeft;
    indices[shaderIndex * NUM_SUB_QUADS * 6 + indexOffset + 1] = vertexIndexTopRight;
    indices[shaderIndex * NUM_SUB_QUADS * 6 + indexOffset + 2] = vertexIndexBottomLeft;

    indices[shaderIndex * NUM_SUB_QUADS * 6 + indexOffset + 3] = vertexIndexTopRight;
    indices[shaderIndex * NUM_SUB_QUADS * 6 + indexOffset + 4] = vertexIndexBottomRight;
    indices[shaderIndex * NUM_SUB_QUADS * 6 + indexOffset + 5] = vertexIndexBottomLeft;
}

void main() {
    vec2 size = vec2(screenSize) / float(surfelSize);

    uint shaderIndex = uint(gl_GlobalInvocationID.y * size.x + gl_GlobalInvocationID.x);

    vec2 surfelCenterCoord = vec2(gl_GlobalInvocationID.xy) + vec2(0.5, 0.5);

    /************************

            tl  - (tc) - tr
            |      |     |
           (cl) - (c) - (cr)
            |      |     |
       -->  bl  - (bc) - br

    ************************/

    vec2 pixelCoordBottomLeft   = surfelSize * (surfelCenterCoord + vec2(0.0, 0.0));
    vec2 pixelCoordBottomCenter = surfelSize * (surfelCenterCoord + vec2(0.5, 0.0));
    vec2 pixelCoordBottomRight  = surfelSize * (surfelCenterCoord + vec2(1.0, 0.0));
    vec2 pixelCoordCenterLeft   = surfelSize * (surfelCenterCoord + vec2(0.0, 0.5));
    vec2 pixelCoordCenter       = surfelSize * (surfelCenterCoord + vec2(0.5, 0.5));
    vec2 pixelCoordCenterRight  = surfelSize * (surfelCenterCoord + vec2(1.0, 0.5));
    vec2 pixelCoordTopLeft      = surfelSize * (surfelCenterCoord + vec2(0.0, 1.0));
    vec2 pixelCoordTopCenter    = surfelSize * (surfelCenterCoord + vec2(0.5, 1.0));
    vec2 pixelCoordTopRight     = surfelSize * (surfelCenterCoord + vec2(1.0, 1.0));

    vec2 uvBottomLeft   = pixelCoordBottomLeft / screenSize;
    vec2 uvBottomCenter = pixelCoordBottomCenter / screenSize;
    vec2 uvBottomRight  = pixelCoordBottomRight / screenSize;
    vec2 uvCenterLeft   = pixelCoordCenterLeft / screenSize;
    vec2 uvCenter       = pixelCoordCenter / screenSize;
    vec2 uvCenterRight  = pixelCoordCenterRight / screenSize;
    vec2 uvTopLeft      = pixelCoordTopLeft / screenSize;
    vec2 uvTopCenter    = pixelCoordTopCenter / screenSize;
    vec2 uvTopRight     = pixelCoordTopRight / screenSize;

    vec2 ndcBottomLeft   = 2.0 * uvBottomLeft - 1.0;
    vec2 ndcBottomCenter = 2.0 * uvBottomCenter - 1.0;
    vec2 ndcBottomRight  = 2.0 * uvBottomRight - 1.0;
    vec2 ndcCenterLeft   = 2.0 * uvCenterLeft - 1.0;
    vec2 ndcCenter       = 2.0 * uvCenter - 1.0;
    vec2 ndcCenterRight  = 2.0 * uvCenterRight - 1.0;
    vec2 ndcTopLeft      = 2.0 * uvTopLeft - 1.0;
    vec2 ndcTopCenter    = 2.0 * uvTopCenter - 1.0;
    vec2 ndcTopRight     = 2.0 * uvTopRight - 1.0;

    vec3 normalBottomLeft  = normalToView(view, sampleNormal(normalMap, uvBottomLeft));
    vec3 normalBottomRight = normalToView(view, sampleNormal(normalMap, uvBottomRight));
    vec3 normalTopLeft     = normalToView(view, sampleNormal(normalMap, uvTopLeft));
    vec3 normalTopRight    = normalToView(view, sampleNormal(normalMap, uvTopRight));

    float depthBottomLeft  = sampleDepth(depthMap, uvBottomLeft);
    float depthBottomRight = sampleDepth(depthMap, uvBottomRight);
    float depthTopLeft     = sampleDepth(depthMap, uvTopLeft);
    float depthTopRight    = sampleDepth(depthMap, uvTopRight);

    vec3 viewCoordBottomLeft  = ndcToView(projectionInverse, ndcBottomLeft, depthBottomLeft);
    vec3 viewCoordBottomRight = ndcToView(projectionInverse, ndcBottomRight, depthBottomRight);
    vec3 viewCoordTopLeft     = ndcToView(projectionInverse, ndcTopLeft, depthTopLeft);
    vec3 viewCoordTopRight    = ndcToView(projectionInverse, ndcTopRight, depthTopRight);

    uint x = shaderIndex % uint(size.x);
    uint y = shaderIndex / uint(size.x);

    // void createSubQuad(
    //     vec3 planeNormal, vec3 planePoint,
    //     vec2 ndcBottomLeft, vec2 ndcBottomRight, vec2 ndcTopLeft, vec2 ndcTopRight,
    //     uint shaderIndex, uint vertexOffset, uint indexOffset
    // )

    /**********************

     (ptl) - (st) - str
        |     |     |
      (sl) - (sc) - sr
        |     |     |
       pbl - sb - pbr

    **********************/
    createSubQuad(
        viewCoordTopLeft, normalTopLeft,
        ndcTopLeft, ndcTopCenter, ndcCenterLeft, ndcCenter,
        x, y + 0.5, size,
        shaderIndex, 0 * VERTICES_IN_A_QUAD, 0 * INDICES_IN_A_QUAD
    );

    /**********************

       ptl - (st) - (ptr)
        |     |       |
        sl - (sc) - (sr)
        |     |       |
       pbl -  sb  -  pbr

    **********************/
    createSubQuad(
        viewCoordTopRight, normalTopRight,
        ndcTopCenter, ndcTopRight, ndcCenter, ndcCenterRight,
        x + 0.5, y + 0.5, size,
        shaderIndex, 1 * VERTICES_IN_A_QUAD, 1 * INDICES_IN_A_QUAD
    );

    /**********************

        ptl -  st - ptr
        |      |     |
       (sl) - (sc) - sr
        |      |     |
      (pbl) - (sb) - pbr

    **********************/
    createSubQuad(
        viewCoordBottomLeft, normalBottomLeft,
        ndcCenterLeft, ndcCenter, ndcBottomLeft, ndcBottomCenter,
        x, y, size,
        shaderIndex, 2 * VERTICES_IN_A_QUAD, 2 * INDICES_IN_A_QUAD
    );

    /**********************

        ptl -  st - ptr
        |      |     |
        sl - (sc) - (sr)
        |      |     |
       pbl - (sb) - (pbr)

    **********************/
    createSubQuad(
        viewCoordBottomRight, normalBottomRight,
        ndcCenter, ndcCenterRight, ndcBottomCenter, ndcBottomRight,
        x + 0.5, y, size,
        shaderIndex, 3 * VERTICES_IN_A_QUAD, 3 * INDICES_IN_A_QUAD
    );
}
