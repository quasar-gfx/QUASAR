layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(binding = 0) uniform sampler2D positionMap;
layout(binding = 1) uniform sampler2D normalMap;
layout(binding = 2) uniform sampler2D idMap;
layout(binding = 3) uniform sampler2D depthMap;

struct Vertex {
    uint id;
    vec3 position;
    vec3 color;
    vec3 normal;
    vec2 texCoords;
    vec3 tangent;
    vec3 bitangent;
};

layout(std430, binding = 0) buffer VertexBuffer {
    Vertex vertices[];
};

layout(std430, binding = 1) buffer IndexBuffer {
    uint indices[];
};

uniform vec2 screenSize;

uniform mat4 viewInverse;
uniform mat4 projectionInverse;

uniform float near;
uniform float far;

uniform int surfelSize;

#define VERTICES_IN_A_QUAD 4
#define NUM_SUB_QUADS 4

vec3 ndcToView(vec2 ndc, float depth) {
    vec4 ndcPos;
    ndcPos.xy = ndc;
    ndcPos.z = 2.0 * depth - 1.0;
    ndcPos.w = 1.0;

    vec4 viewCoord = projectionInverse * ndcPos;
    viewCoord = viewCoord / viewCoord.w;
    return viewCoord.xyz;
}

vec3 viewToWorld(vec3 viewspaceCoord) {
    vec4 worldCoord = viewInverse * vec4(viewspaceCoord, 1.0);
    worldCoord = worldCoord / worldCoord.w;
    return worldCoord.xyz;
}

vec3 sampleNormal(sampler2D normalMap, ivec2 pixelCoord) {
    vec2 sampleCoord = vec2(pixelCoord) / screenSize;
    return texture(normalMap, sampleCoord).xyz;
}

float sampleDepth(sampler2D depthMap, ivec2 pixelCoord) {
    vec2 sampleCoord = vec2(pixelCoord) / screenSize;
    return texture(depthMap, sampleCoord).x;
}

vec3 planeRayIntersection(vec3 rayOrigin, vec3 rayDirection, vec3 planeNormal, vec3 planePoint) {
    float t = dot(planeNormal, planePoint - rayOrigin) / dot(planeNormal, rayDirection);
    return rayOrigin + t * rayDirection;
}

void createSubQuad(
        vec3 planeNormal, vec3 planePoint,
        vec2 ndcLowerLeft, vec2 ndcLowerRight, vec2 ndcUpperLeft, vec2 ndcUpperRight,
        float x, float y, vec2 size,
        uint shaderIndex, uint vertexOffset, uint indexOffset
    )
{
    /************************

            ul -- ur
            |   / |
            | /   |
            ll -- lr

    ************************/
    vec3 rayOrigin = vec3(0.0);

    vec3 rayDirectionLowerLeft = normalize(ndcToView(ndcLowerLeft, 1));
    vec3 viewCoordLowerLeft = planeRayIntersection(rayOrigin, rayDirectionLowerLeft, planeNormal, planePoint);

    vec3 rayDirectionLowerRight = normalize(ndcToView(ndcLowerRight, 1));
    vec3 viewCoordLowerRight = planeRayIntersection(rayOrigin, rayDirectionLowerRight, planeNormal, planePoint);

    vec3 rayDirectionUpperLeft = normalize(ndcToView(ndcUpperLeft, 1));
    vec3 viewCoordUpperLeft = planeRayIntersection(rayOrigin, rayDirectionUpperLeft, planeNormal, planePoint);

    vec3 rayDirectionUpperRight = normalize(ndcToView(ndcUpperRight, 1));
    vec3 viewCoordUpperRight = planeRayIntersection(rayOrigin, rayDirectionUpperRight, planeNormal, planePoint);

    uint vertexIndexUpperLeft  = shaderIndex * NUM_SUB_QUADS * VERTICES_IN_A_QUAD + vertexOffset + 0;
    vertices[vertexIndexUpperLeft] .position = viewToWorld(viewCoordUpperLeft);
    vertices[vertexIndexUpperLeft] .color = vec3(1.0, 1.0, 1.0);
    vertices[vertexIndexUpperLeft] .texCoords = vec2(x / size.x, 1 - (y + 0.5) / size.y);

    uint vertexIndexUpperRight = shaderIndex * NUM_SUB_QUADS * VERTICES_IN_A_QUAD + vertexOffset + 1;
    vertices[vertexIndexUpperRight].position = viewToWorld(viewCoordUpperRight);
    vertices[vertexIndexUpperRight].color = vec3(1.0, 1.0, 1.0);
    vertices[vertexIndexUpperRight].texCoords = vec2((x + 0.5) / size.x, 1 - (y + 0.5) / size.y);

    uint vertexIndexLowerLeft  = shaderIndex * NUM_SUB_QUADS * VERTICES_IN_A_QUAD + vertexOffset + 2;
    vertices[vertexIndexLowerLeft] .position = viewToWorld(viewCoordLowerLeft);
    vertices[vertexIndexLowerLeft] .color = vec3(1.0, 1.0, 1.0);
    vertices[vertexIndexLowerLeft] .texCoords = vec2(x / size.x, 1 - y / size.y);

    uint vertexIndexLowerRight = shaderIndex * NUM_SUB_QUADS * VERTICES_IN_A_QUAD + vertexOffset + 3;
    vertices[vertexIndexLowerRight].position = viewToWorld(viewCoordLowerRight);
    vertices[vertexIndexLowerRight].color = vec3(1.0, 1.0, 1.0);
    vertices[vertexIndexLowerRight].texCoords = vec2((x + 0.5) / size.x, 1 - y / size.y);

    indices[shaderIndex * NUM_SUB_QUADS * 6 + indexOffset + 0] = vertexIndexUpperLeft;
    indices[shaderIndex * NUM_SUB_QUADS * 6 + indexOffset + 1] = vertexIndexUpperRight;
    indices[shaderIndex * NUM_SUB_QUADS * 6 + indexOffset + 2] = vertexIndexLowerLeft;

    indices[shaderIndex * NUM_SUB_QUADS * 6 + indexOffset + 3] = vertexIndexUpperRight;
    indices[shaderIndex * NUM_SUB_QUADS * 6 + indexOffset + 4] = vertexIndexLowerRight;
    indices[shaderIndex * NUM_SUB_QUADS * 6 + indexOffset + 5] = vertexIndexLowerLeft;
}


void main() {
    vec2 size = vec2(screenSize) / float(surfelSize);

    uint shaderIndex = uint(gl_GlobalInvocationID.y * size.x + gl_GlobalInvocationID.x);

    ivec2 surfelCoords = ivec2(gl_GlobalInvocationID.xy);

    uint x = shaderIndex % uint(size.x);
    uint y = shaderIndex / uint(size.x);

    /************************

            ul - uc - ur
            |        / |
            lc    c    rc
            |  /       |
       -->  ll - lc - lr

    ************************/

    ivec2 pixelCoordLowerLeft  = ivec2(surfelSize * (surfelCoords + vec2(0.0, 0.0)));
    ivec2 pixelCoordLowerRight = ivec2(surfelSize * (surfelCoords + vec2(1.0, 0.0)));
    ivec2 pixelCoordUpperLeft  = ivec2(surfelSize * (surfelCoords + vec2(0.0, 1.0)));
    ivec2 pixelCoordUpperRight = ivec2(surfelSize * (surfelCoords + vec2(1.0, 1.0)));
    ivec2 pixelCoordCenter     = ivec2(surfelSize * (surfelCoords + vec2(0.5, 0.5)));
    ivec2 pixelCoordUpperCenter = ivec2(surfelSize * (surfelCoords + vec2(0.5, 1.0)));
    ivec2 pixelCoordLowerCenter = ivec2(surfelSize * (surfelCoords + vec2(0.5, 0.0)));
    ivec2 pixelCoordLeftCenter  = ivec2(surfelSize * (surfelCoords + vec2(0.0, 0.5)));
    ivec2 pixelCoordRightCenter = ivec2(surfelSize * (surfelCoords + vec2(1.0, 0.5)));

    vec2 pixelCoordLowerLeftNormalized  = pixelCoordLowerLeft / screenSize;
    vec2 pixelCoordLowerRightNormalized = pixelCoordLowerRight / screenSize;
    vec2 pixelCoordUpperLeftNormalized  = pixelCoordUpperLeft / screenSize;
    vec2 pixelCoordUpperRightNormalized = pixelCoordUpperRight / screenSize;
    vec2 pixelCoordCenterNormalized     = pixelCoordCenter / screenSize;
    vec2 pixelCoordUpperCenterNormalized = pixelCoordUpperCenter / screenSize;
    vec2 pixelCoordLowerCenterNormalized = pixelCoordLowerCenter / screenSize;
    vec2 pixelCoordLeftCenterNormalized  = pixelCoordLeftCenter / screenSize;
    vec2 pixelCoordRightCenterNormalized = pixelCoordRightCenter / screenSize;

    vec2 ndcLowerLeft  = 2.0 * pixelCoordLowerLeftNormalized - 1.0;
    vec2 ndcLowerRight = 2.0 * pixelCoordLowerRightNormalized - 1.0;
    vec2 ndcUpperLeft  = 2.0 * pixelCoordUpperLeftNormalized - 1.0;
    vec2 ndcUpperRight = 2.0 * pixelCoordUpperRightNormalized - 1.0;
    vec2 ndcCenter     = 2.0 * pixelCoordCenterNormalized - 1.0;
    vec2 ndcUpperCenter = 2.0 * pixelCoordUpperCenterNormalized - 1.0;
    vec2 ndcLowerCenter = 2.0 * pixelCoordLowerCenterNormalized - 1.0;
    vec2 ndcLeftCenter  = 2.0 * pixelCoordLeftCenterNormalized - 1.0;
    vec2 ndcRightCenter = 2.0 * pixelCoordRightCenterNormalized - 1.0;

    vec3 normalLowerLeft  = sampleNormal(normalMap, pixelCoordLowerLeft);
    vec3 normalLowerRight = sampleNormal(normalMap, pixelCoordLowerRight);
    vec3 normalUpperLeft  = sampleNormal(normalMap, pixelCoordUpperLeft);
    vec3 normalUpperRight = sampleNormal(normalMap, pixelCoordUpperRight);

    uint idLowerLeft  = uint(texture(idMap, pixelCoordLowerLeftNormalized).x);
    uint idLowerRight = uint(texture(idMap, pixelCoordLowerRightNormalized).x);
    uint idUpperLeft  = uint(texture(idMap, pixelCoordUpperLeftNormalized).x);
    uint idUpperRight = uint(texture(idMap, pixelCoordUpperRightNormalized).x);

    float depthLowerLeft  = sampleDepth(depthMap, pixelCoordLowerLeft);
    float depthLowerRight = sampleDepth(depthMap, pixelCoordLowerRight);
    float depthUpperLeft  = sampleDepth(depthMap, pixelCoordUpperLeft);
    float depthUpperRight = sampleDepth(depthMap, pixelCoordUpperRight);

    vec3 viewCoordLowerLeft  = ndcToView(ndcLowerLeft, depthLowerLeft);
    vec3 viewCoordLowerRight = ndcToView(ndcLowerRight, depthLowerRight);
    vec3 viewCoordUpperLeft  = ndcToView(ndcUpperLeft, depthUpperLeft);
    vec3 viewCoordUpperRight = ndcToView(ndcUpperRight, depthUpperRight);

    // void createSubQuad(
    //     vec3 planeNormal, vec3 planePoint,
    //     vec2 ndcLowerLeft, vec2 ndcLowerRight, vec2 ndcUpperLeft, vec2 ndcUpperRight,
    //     uint shaderIndex, uint vertexOffset, uint indexOffset
    // )

    /************************

            lec - c
            |  /  |
       -->  ll - loc

    ************************/
    createSubQuad(
        normalLowerLeft, viewCoordLowerLeft,
        ndcLowerLeft, ndcLowerCenter, ndcLeftCenter, ndcCenter,
        x, y, size,
        shaderIndex, 0, 0
    );

    /************************

       -->  ul - upc
            |     |
            lec - c

    ************************/
    createSubQuad(
        normalUpperLeft, viewCoordUpperLeft,
        ndcLeftCenter, ndcCenter, ndcUpperLeft, ndcUpperCenter,
        x, y + 0.5, size,
        shaderIndex, 4, 6
    );

    /************************

            upc - ur  <--
            |     |
            c  - ric

    ************************/
    createSubQuad(
        normalUpperRight, viewCoordUpperRight,
        ndcCenter, ndcRightCenter, ndcUpperCenter, ndcUpperRight,
        x + 0.5, y + 0.5, size,
        shaderIndex, 8, 12
    );

    /************************

            c  - ric
            |     |
            loc - lr  <--

    ************************/
    createSubQuad(
        normalLowerRight, viewCoordLowerRight,
        ndcLowerCenter, ndcLowerRight, ndcCenter, ndcRightCenter,
        x + 0.5, y, size,
        shaderIndex, 12, 18
    );
}
