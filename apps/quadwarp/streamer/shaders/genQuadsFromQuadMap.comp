layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

precision highp sampler2D;
precision highp image2D;

struct Vertex {
    uint id;
    vec3 position;
    vec3 color;
    vec3 normal;
    vec2 texCoords;
    vec3 tangent;
    vec3 bitangent;
};

struct QuadMapData {
    vec3 normal;
    vec2 uv;
    float depth;
};

layout(std430, binding = 0) buffer QuadMapBuffer {
    QuadMapData quadMap[];
};

layout(std430, binding = 1) buffer VertexCounterBuffer {
    uint numVertices;
};

layout(std430, binding = 2) buffer IndexCounterBuffer {
    uint numIndices;
};

layout(std430, binding = 3) buffer VertexBuffer {
    Vertex vertices[];
};

layout(std430, binding = 4) buffer IndexBuffer {
    uint indices[];
};

layout(std430, binding = 5) buffer VertexBufferWireframe {
    Vertex verticesWireframe[];
};

layout(std430, binding = 6) buffer IndexBufferWireframe {
    uint indicesWireframe[];
};

struct Plane {
    vec3 normal;
    float constant;
};

struct Quad {
    vec3 bottomLeft;
    vec3 bottomRight;
    vec3 topLeft;
    vec3 topRight;
};

struct Quad1D {
    float bottomLeft;
    float bottomRight;
    float topLeft;
    float topRight;
};

struct Quad2D {
    vec2 bottomLeft;
    vec2 bottomRight;
    vec2 topLeft;
    vec2 topRight;
};

// a Quad subdivided into 4 smaller Quads
struct MultiQuad {
    vec3 bottomLeft;
    vec3 bottom;
    vec3 bottomRight;
    vec3 left;
    vec3 center;
    vec3 right;
    vec3 topLeft;
    vec3 top;
    vec3 topRight;
};

struct MultiQuad1D {
    float bottomLeft;
    float bottom;
    float bottomRight;
    float left;
    float center;
    float right;
    float topLeft;
    float top;
    float topRight;
};

struct MultiQuad2D {
    vec2 bottomLeft;
    vec2 bottom;
    vec2 bottomRight;
    vec2 left;
    vec2 center;
    vec2 right;
    vec2 topLeft;
    vec2 top;
    vec2 topRight;
};

uniform vec2 quadMapSize;

uniform mat4 view;
uniform mat4 projection;
uniform mat4 viewInverse;
uniform mat4 projectionInverse;

uniform float near;
uniform float far;

uniform float distanceThreshold;
uniform float angleThreshold;

const float epilson = 1e-5;

const vec3 origin = vec3(0.0, 0.0, 0.0);

#define MAX_DEPTH 0.9999

#define VERTICES_IN_A_QUAD  4
#define INDICES_IN_A_QUAD   6
#define NUM_SUB_QUADS       4

#define BOTTOM_LEFT  0
#define BOTTOM       1
#define BOTTOM_RIGHT 2
#define LEFT         3
#define CENTER       4
#define RIGHT        5
#define TOP_LEFT     6
#define TOP          7
#define TOP_RIGHT    8

vec3 ndcToView(mat4 projectionInverse, vec2 ndc, float depth) {
    depth = clamp(depth, 0.0, MAX_DEPTH);

    vec4 ndcPos;
    ndcPos.xy = ndc;
    ndcPos.z = 2.0 * depth - 1.0;
    ndcPos.w = 1.0;

    vec4 viewCoord = projectionInverse * ndcPos;
    viewCoord = viewCoord / viewCoord.w;
    return viewCoord.xyz;
}

vec3 viewToWorld(mat4 viewInverse, vec3 viewCoord) {
    vec4 worldCoord = viewInverse * vec4(viewCoord, 1.0);
    worldCoord = worldCoord / worldCoord.w;
    return worldCoord.xyz;
}

vec3 worldToView(mat4 view, vec3 worldCoord) {
    vec4 viewCoord = view * vec4(worldCoord, 1.0);
    viewCoord = viewCoord / viewCoord.w;
    return viewCoord.xyz;
}

vec2 viewToNDC(mat4 projection, vec3 viewCoord) {
    vec4 ndcCoord = projection * vec4(viewCoord, 1.0);
    ndcCoord = ndcCoord / ndcCoord.w;
    return ndcCoord.xy;
}

vec2 ndcToScreen(vec2 ndc) {
    return (ndc + 1.0) / 2.0;
}

vec2 worldToScreen(mat4 view, mat4 projection, vec3 worldCoord) {
    vec2 ndc = viewToNDC(projection, worldToView(view, worldCoord));
    return ndcToScreen(ndc);
}

QuadMapData sampleQuadMap(vec2 texCoord) {
    uint index = uint(texCoord.y * quadMapSize.x + texCoord.x);
    return quadMap[index];
}

vec3 planeRayIntersection(vec3 rayOrigin, vec3 rayDirection, vec3 planePoint, vec3 planeNormal) {
    float denominator = dot(rayDirection, planeNormal);
    if (abs(denominator) < epilson) {
        return vec3(1.0/0.0, 1.0/0.0, 1.0/0.0);
    }

    float t = dot(planePoint - rayOrigin, planeNormal) / denominator;
    if (t < 0.0) {
        return vec3(1.0/0.0, 1.0/0.0, 1.0/0.0);
    }

    vec3 intersection = rayOrigin + t * rayDirection;
    return intersection;
}

void storeQuad(Quad quad)
{
    /************************

            tl -- tr
            |   / |
            | /   |
            bl -- br

    ************************/

    uint vertexIdxBase = atomicAdd(numVertices, VERTICES_IN_A_QUAD);

    uint vertexIndexTopLeft = vertexIdxBase + 0;
    vertices[vertexIndexTopLeft].position = viewToWorld(viewInverse, quad.topLeft);
    vertices[vertexIndexTopLeft].color = vec3(1.0, 1.0, 1.0);
    vertices[vertexIndexTopLeft].texCoords = worldToScreen(view, projection, vertices[vertexIndexTopLeft].position);

    uint vertexIndexTopRight = vertexIdxBase + 1;
    vertices[vertexIndexTopRight].position = viewToWorld(viewInverse, quad.topRight);
    vertices[vertexIndexTopRight].color = vec3(1.0, 1.0, 1.0);
    vertices[vertexIndexTopRight].texCoords = worldToScreen(view, projection, vertices[vertexIndexTopRight].position);

    uint vertexIndexBottomLeft = vertexIdxBase + 2;
    vertices[vertexIndexBottomLeft].position = viewToWorld(viewInverse, quad.bottomLeft);
    vertices[vertexIndexBottomLeft].color = vec3(1.0, 1.0, 1.0);
    vertices[vertexIndexBottomLeft].texCoords = worldToScreen(view, projection, vertices[vertexIndexBottomLeft].position);

    uint vertexIndexBottomRight = vertexIdxBase + 3;
    vertices[vertexIndexBottomRight].position = viewToWorld(viewInverse, quad.bottomRight);
    vertices[vertexIndexBottomRight].color = vec3(1.0, 1.0, 1.0);
    vertices[vertexIndexBottomRight].texCoords = worldToScreen(view, projection, vertices[vertexIndexBottomRight].position);

    verticesWireframe[vertexIndexTopLeft] = vertices[vertexIndexTopLeft];
    verticesWireframe[vertexIndexTopRight] = vertices[vertexIndexTopRight];
    verticesWireframe[vertexIndexBottomLeft] = vertices[vertexIndexBottomLeft];
    verticesWireframe[vertexIndexBottomRight] = vertices[vertexIndexBottomRight];

    uint indexIdxBase = atomicAdd(numIndices, INDICES_IN_A_QUAD);

    indices[indexIdxBase + 0] = vertexIndexTopLeft;
    indices[indexIdxBase + 1] = vertexIndexBottomLeft;
    indices[indexIdxBase + 2] = vertexIndexTopRight;

    indices[indexIdxBase + 3] = vertexIndexTopRight;
    indices[indexIdxBase + 4] = vertexIndexBottomLeft;
    indices[indexIdxBase + 5] = vertexIndexBottomRight;

    indicesWireframe[indexIdxBase + 0] = indices[indexIdxBase + 0];
    indicesWireframe[indexIdxBase + 1] = indices[indexIdxBase + 1];
    indicesWireframe[indexIdxBase + 2] = indices[indexIdxBase + 2];
    indicesWireframe[indexIdxBase + 3] = indices[indexIdxBase + 3];
    indicesWireframe[indexIdxBase + 4] = indices[indexIdxBase + 4];
    indicesWireframe[indexIdxBase + 5] = indices[indexIdxBase + 5];
}

// runs at every "pixel" in the quad map
void main() {
    uint shaderIndex = uint(gl_GlobalInvocationID.y * quadMapSize.x + gl_GlobalInvocationID.x);

    /**********************

      (stl)  ------- (str)
        |             |
        |     sc      |
        |             |
      (sbl) ------- (sbl)

    **********************/

    vec2 pixelCoord = vec2(gl_GlobalInvocationID.xy);

    const int surfelSize = 1;

    QuadMapData quadMapData = sampleQuadMap(pixelCoord);
    vec2 uv = quadMapData.uv;
    vec2 ndc = uv * 2.0 - 1.0;

    vec3 surfelCenterView = ndcToView(projectionInverse, ndc, quadMapData.depth);

    Quad2D surfelUV;
    surfelUV.bottomLeft  = uv - (vec2(+0.5, +0.5) * (surfelSize / 2.0)) / quadMapSize;
    surfelUV.bottomRight = uv + (vec2(+0.5, -0.5) * (surfelSize / 2.0)) / quadMapSize;
    surfelUV.topLeft     = uv - (vec2(-0.5, +0.5) * (surfelSize / 2.0)) / quadMapSize;
    surfelUV.topRight    = uv + (vec2(-0.5, -0.5) * (surfelSize / 2.0)) / quadMapSize;

    Quad2D surfelNDC;
    surfelNDC.bottomLeft  = surfelUV.bottomLeft * 2.0 - 1.0;
    surfelNDC.bottomRight = surfelUV.bottomRight * 2.0 - 1.0;
    surfelNDC.topLeft     = surfelUV.topLeft * 2.0 - 1.0;
    surfelNDC.topRight    = surfelUV.topRight * 2.0 - 1.0;

    Quad surfelViews;
    surfelViews.bottomLeft  = ndcToView(projectionInverse, surfelNDC.bottomLeft, 1.0);
    surfelViews.bottomRight = ndcToView(projectionInverse, surfelNDC.bottomRight, 1.0);
    surfelViews.topLeft     = ndcToView(projectionInverse, surfelNDC.topLeft, 1.0);
    surfelViews.topRight    = ndcToView(projectionInverse, surfelNDC.topRight, 1.0);

    Quad surfel;

    // shoot 4 rays from corners of the surfel to the plane
    vec3 rayDirection;

    rayDirection = normalize(surfelViews.bottomLeft - origin);
    surfel.bottomLeft = planeRayIntersection(origin, rayDirection, surfelCenterView, quadMapData.normal);

    rayDirection = normalize(surfelViews.bottomRight - origin);
    surfel.bottomRight = planeRayIntersection(origin, rayDirection, surfelCenterView, quadMapData.normal);

    rayDirection = normalize(surfelViews.topLeft - origin);
    surfel.topLeft = planeRayIntersection(origin, rayDirection, surfelCenterView, quadMapData.normal);

    rayDirection = normalize(surfelViews.topRight - origin);
    surfel.topRight = planeRayIntersection(origin, rayDirection, surfelCenterView, quadMapData.normal);


    /**********************************

      (ptl)  ----   (pt) ----  (ptr)
        |            |           |
        |  - stl -  st  -  str - |
        |            |           |
     (pl)  - sl - (pc/sc) - sr - (pr)
        |            |           |
        |  - sbl -  sb  -  sbr - |
        |            |           |
      (pbl)  ----   (pb) ----  (pbr)

    **********************************/
    vec2 surfelCoordBottomLeft  = vec2(gl_GlobalInvocationID.xy);

    MultiQuad2D pixelCoords;
    pixelCoords.bottomLeft  = surfelCoordBottomLeft + vec2(0.5, 0.5) + vec2(-1.0, -1.0);
    pixelCoords.bottom      = surfelCoordBottomLeft + vec2(0.5, 0.5) + vec2(+0.0, -1.0);
    pixelCoords.bottomRight = surfelCoordBottomLeft + vec2(0.5, 0.5) + vec2(+1.0, -1.0);
    pixelCoords.left        = surfelCoordBottomLeft + vec2(0.5, 0.5) + vec2(-1.0, +0.0);
    pixelCoords.center      = surfelCoordBottomLeft + vec2(0.5, 0.5) + vec2(+0.0, +0.0);
    pixelCoords.right       = surfelCoordBottomLeft + vec2(0.5, 0.5) + vec2(+1.0, +0.0);
    pixelCoords.topLeft     = surfelCoordBottomLeft + vec2(0.5, 0.5) + vec2(-1.0, +1.0);
    pixelCoords.top         = surfelCoordBottomLeft + vec2(0.5, 0.5) + vec2(+0.0, +1.0);
    pixelCoords.topRight    = surfelCoordBottomLeft + vec2(0.5, 0.5) + vec2(+1.0, +1.0);

    MultiQuad2D surfelCoords;
    surfelCoords.bottomLeft  = surfelCoordBottomLeft + vec2(0.0, 0.0) + vec2(0.0, 0.0);
    surfelCoords.bottom      = surfelCoordBottomLeft + vec2(0.0, 0.0) + vec2(0.5, 0.0);
    surfelCoords.bottomRight = surfelCoordBottomLeft + vec2(0.0, 0.0) + vec2(1.0, 0.0);
    surfelCoords.left        = surfelCoordBottomLeft + vec2(0.0, 0.0) + vec2(0.0, 0.5);
    surfelCoords.center      = pixelCoords.center;
    surfelCoords.right       = surfelCoordBottomLeft + vec2(0.0, 0.0) + vec2(1.0, 0.5);
    surfelCoords.topLeft     = surfelCoordBottomLeft + vec2(0.0, 0.0) + vec2(0.0, 1.0);
    surfelCoords.top         = surfelCoordBottomLeft + vec2(0.0, 0.0) + vec2(0.5, 1.0);
    surfelCoords.topRight    = surfelCoordBottomLeft + vec2(0.0, 0.0) + vec2(1.0, 1.0);

    // project points to view space
    MultiQuad2D pixelNDCs;
    pixelNDCs.bottomLeft  = 2.0 * (pixelCoords.bottomLeft / quadMapSize) - 1.0;
    pixelNDCs.bottom      = 2.0 * (pixelCoords.bottom / quadMapSize) - 1.0;
    pixelNDCs.bottomRight = 2.0 * (pixelCoords.bottomRight / quadMapSize) - 1.0;
    pixelNDCs.left        = 2.0 * (pixelCoords.left / quadMapSize) - 1.0;
    pixelNDCs.center      = 2.0 * (pixelCoords.center / quadMapSize) - 1.0;
    pixelNDCs.right       = 2.0 * (pixelCoords.right / quadMapSize) - 1.0;
    pixelNDCs.topLeft     = 2.0 * (pixelCoords.topLeft / quadMapSize) - 1.0;
    pixelNDCs.top         = 2.0 * (pixelCoords.top / quadMapSize) - 1.0;
    pixelNDCs.topRight    = 2.0 * (pixelCoords.topRight / quadMapSize) - 1.0;

    MultiQuad2D surfelNDCs;
    surfelNDCs.bottomLeft  = 2.0 * (surfelCoords.bottomLeft / quadMapSize) - 1.0;
    surfelNDCs.bottom      = 2.0 * (surfelCoords.bottom / quadMapSize) - 1.0;
    surfelNDCs.bottomRight = 2.0 * (surfelCoords.bottomRight / quadMapSize) - 1.0;
    surfelNDCs.left        = 2.0 * (surfelCoords.left / quadMapSize) - 1.0;
    surfelNDCs.center      = 2.0 * (surfelCoords.center / quadMapSize) - 1.0;
    surfelNDCs.right       = 2.0 * (surfelCoords.right / quadMapSize) - 1.0;
    surfelNDCs.topLeft     = 2.0 * (surfelCoords.topLeft / quadMapSize) - 1.0;
    surfelNDCs.top         = 2.0 * (surfelCoords.top / quadMapSize) - 1.0;
    surfelNDCs.topRight    = 2.0 * (surfelCoords.topRight / quadMapSize) - 1.0;

    if (quadMapData.depth <= 0) return;

    surfel.bottomLeft = ndcToView(projectionInverse, surfelNDCs.bottomLeft, 1.0);
    surfel.bottomRight = ndcToView(projectionInverse, surfelNDCs.bottomRight, 1.0);
    surfel.topLeft = ndcToView(projectionInverse, surfelNDCs.topLeft, 1.0);
    surfel.topRight = ndcToView(projectionInverse, surfelNDCs.topRight, 1.0);

    storeQuad(surfel);
}
