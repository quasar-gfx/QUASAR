layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

precision highp sampler2D;
precision highp image2D;

struct Vertex {
    uint id;
    vec3 position;
    vec3 color;
    vec3 normal;
    vec2 texCoords;
    vec3 tangent;
    vec3 bitangent;
};

struct QuadMapData {
    vec3 normal;
    vec2 uv;
    float depth;
    ivec2 offset;
};

struct Quad {
    vec3 bottomLeft;
    vec3 bottomRight;
    vec3 topLeft;
    vec3 topRight;
};

struct Quad1D {
    float bottomLeft;
    float bottomRight;
    float topLeft;
    float topRight;
};

struct Quad2D {
    vec2 bottomLeft;
    vec2 bottomRight;
    vec2 topLeft;
    vec2 topRight;
};

layout(std430, binding = 0) buffer QuadMapBuffer {
    QuadMapData quadMap[];
};

layout(std430, binding = 1) buffer VertexCounterBuffer {
    uint numVertices;
};

layout(std430, binding = 2) buffer IndexCounterBuffer {
    uint numIndices;
};

layout(std430, binding = 3) buffer VertexBuffer {
    Vertex vertices[];
};

layout(std430, binding = 4) buffer IndexBuffer {
    uint indices[];
};

layout(std430, binding = 5) buffer VertexBufferWireframe {
    Vertex verticesWireframe[];
};

layout(std430, binding = 6) buffer IndexBufferWireframe {
    uint indicesWireframe[];
};

layout(std430, binding = 7) buffer DepthOffsetBuffer {
    float depthOffsetBuffer[];
};

uniform vec2 remoteWinSize;
uniform vec2 quadMapSize;
uniform vec2 depthBufferSize;

uniform mat4 view;
uniform mat4 projection;
uniform mat4 viewInverse;
uniform mat4 projectionInverse;

uniform float near;
uniform float far;

const float epilson = 1e-5;

const vec3 origin = vec3(0.0, 0.0, 0.0);

#define MAX_DEPTH 0.9999

#define VERTICES_IN_A_QUAD  4u
#define INDICES_IN_A_QUAD   6u
#define NUM_SUB_QUADS       4u

vec3 ndcToView(mat4 projectionInverse, vec2 ndc, float depth) {
    depth = clamp(depth, 0.0, MAX_DEPTH);

    vec4 ndcPos;
    ndcPos.xy = ndc;
    ndcPos.z = 2.0 * depth - 1.0;
    ndcPos.w = 1.0;

    vec4 viewCoord = projectionInverse * ndcPos;
    viewCoord = viewCoord / viewCoord.w;
    return viewCoord.xyz;
}

vec3 viewToWorld(mat4 viewInverse, vec3 viewCoord) {
    vec4 worldCoord = viewInverse * vec4(viewCoord, 1.0);
    worldCoord = worldCoord / worldCoord.w;
    return worldCoord.xyz;
}

vec3 worldToView(mat4 view, vec3 worldCoord) {
    vec4 viewCoord = view * vec4(worldCoord, 1.0);
    viewCoord = viewCoord / viewCoord.w;
    return viewCoord.xyz;
}

vec2 viewToNDC(mat4 projection, vec3 viewCoord) {
    vec4 ndcCoord = projection * vec4(viewCoord, 1.0);
    ndcCoord = ndcCoord / ndcCoord.w;
    return ndcCoord.xy;
}

vec2 ndcToScreen(vec2 ndc) {
    return (ndc + 1.0) / 2.0;
}

vec2 worldToScreen(mat4 view, mat4 projection, vec3 worldCoord) {
    vec2 ndc = viewToNDC(projection, worldToView(view, worldCoord));
    return ndcToScreen(ndc);
}

vec3 rayPlaneIntersection(vec3 rayOrigin, vec3 rayDirection, vec3 planePoint, vec3 planeNormal) {
    float denominator = dot(rayDirection, planeNormal);
    if (abs(denominator) < epilson) {
        return vec3(1.0/0.0, 1.0/0.0, 1.0/0.0);
    }

    float t = dot(planePoint - rayOrigin, planeNormal) / denominator;
    if (t < 0.0) {
        return vec3(1.0/0.0, 1.0/0.0, 1.0/0.0);
    }

    vec3 intersection = rayOrigin + t * rayDirection;
    return intersection;
}

vec3 pointPlaneIntersection(vec3 pt, vec3 planePoint, vec3 planeNormal) {
    vec3 rayDirection = normalize(pt);
    return rayPlaneIntersection(origin, rayDirection, planePoint, planeNormal);
}

QuadMapData loadQuadMap(ivec2 pixelCoord) {
    uint index = uint(pixelCoord.y) * uint(quadMapSize.x) + uint(pixelCoord.x);
    QuadMapData quadMapData = quadMap[index];
    return quadMapData;
}

float loadDepthOffset(in ivec2 pixelCoord) {
    uint index = uint(pixelCoord.y) * uint(depthBufferSize.x) + uint(pixelCoord.x);
    return depthOffsetBuffer[index];
}

void loadDepthOffsets(out Quad1D depthOffsets, in ivec2 pixelCoord) {
    depthOffsets.bottomLeft  = loadDepthOffset(pixelCoord + ivec2(0, 0));
    depthOffsets.bottomRight = loadDepthOffset(pixelCoord + ivec2(1, 0));
    depthOffsets.topLeft     = loadDepthOffset(pixelCoord + ivec2(0, 1));
    depthOffsets.topRight    = loadDepthOffset(pixelCoord + ivec2(1, 1));
}

void createSurfel(out Quad surfel, in Quad2D surfelPixelCoords, in Quad1D depthOffets, in vec3 proxyPlanePt, in vec3 proxyPlaneNormal) {
    Quad2D surfelUVs;
    surfelUVs.bottomLeft  = surfelPixelCoords.bottomLeft / remoteWinSize;
    surfelUVs.bottomRight = surfelPixelCoords.bottomRight / remoteWinSize;
    surfelUVs.topLeft     = surfelPixelCoords.topLeft / remoteWinSize;
    surfelUVs.topRight    = surfelPixelCoords.topRight / remoteWinSize;

    Quad2D surfelNDCs;
    surfelNDCs.bottomLeft  = surfelUVs.bottomLeft * 2.0 - 1.0;
    surfelNDCs.bottomRight = surfelUVs.bottomRight * 2.0 - 1.0;
    surfelNDCs.topLeft     = surfelUVs.topLeft * 2.0 - 1.0;
    surfelNDCs.topRight    = surfelUVs.topRight * 2.0 - 1.0;

    Quad surfelFarPlane;
    surfelFarPlane.bottomLeft  = ndcToView(projectionInverse, surfelNDCs.bottomLeft, 1.0);
    surfelFarPlane.bottomRight = ndcToView(projectionInverse, surfelNDCs.bottomRight, 1.0);
    surfelFarPlane.topLeft     = ndcToView(projectionInverse, surfelNDCs.topLeft, 1.0);
    surfelFarPlane.topRight    = ndcToView(projectionInverse, surfelNDCs.topRight, 1.0);

    // shoot rays from corners of the surfel to the plane to find the 3D intersection points
    Quad quadPtsOnPlane;
    quadPtsOnPlane.bottomLeft  = pointPlaneIntersection(surfelFarPlane.bottomLeft,  proxyPlanePt, proxyPlaneNormal);
    quadPtsOnPlane.bottomRight = pointPlaneIntersection(surfelFarPlane.bottomRight, proxyPlanePt, proxyPlaneNormal);
    quadPtsOnPlane.topLeft     = pointPlaneIntersection(surfelFarPlane.topLeft,     proxyPlanePt, proxyPlaneNormal);
    quadPtsOnPlane.topRight    = pointPlaneIntersection(surfelFarPlane.topRight,    proxyPlanePt, proxyPlaneNormal);

    // apply depth offsets to the quad points
    surfel.bottomLeft  = quadPtsOnPlane.bottomLeft  - depthOffets.bottomLeft  * normalize(quadPtsOnPlane.bottomLeft);
    surfel.bottomRight = quadPtsOnPlane.bottomRight - depthOffets.bottomRight * normalize(quadPtsOnPlane.bottomRight);
    surfel.topLeft     = quadPtsOnPlane.topLeft     - depthOffets.topLeft     * normalize(quadPtsOnPlane.topLeft);
    surfel.topRight    = quadPtsOnPlane.topRight    - depthOffets.topRight    * normalize(quadPtsOnPlane.topRight);
}

void loadSurfelsFromQuadMap(
    out Quad surfelBottomLeft, out Quad surfelBottomRight, out Quad surfelTopLeft, out Quad surfelTopRight,
    in QuadMapData quadMapData
) {
    // extract the plane normal and point from the quad map
    vec2 proxyPlaneUV = quadMapData.uv;
    float proxyPlaneDepth = quadMapData.depth;
    vec3 proxyPlaneNormal = quadMapData.normal;
    ivec2 depthOffsetPixelCoord = quadMapData.offset;

    vec2 proxyPlaneNDC = proxyPlaneUV * 2.0 - 1.0;
    vec3 proxyPlanePt = ndcToView(projectionInverse, proxyPlaneNDC, proxyPlaneDepth);

    vec2 proxyPlanePixelCoords = proxyPlaneUV * remoteWinSize;

    // find the pixel coordinates of the surfel corners
    Quad2D surfelPixelCoordsBottomLeft;
    surfelPixelCoordsBottomLeft.bottomLeft  = proxyPlanePixelCoords + vec2(-0.5, -0.5);
    surfelPixelCoordsBottomLeft.bottomRight = proxyPlanePixelCoords + vec2(+0.0, -0.5);
    surfelPixelCoordsBottomLeft.topLeft     = proxyPlanePixelCoords + vec2(-0.5, +0.0);
    surfelPixelCoordsBottomLeft.topRight    = proxyPlanePixelCoords + vec2(+0.0, +0.0);

    Quad2D surfelPixelCoordsBottomRight;
    surfelPixelCoordsBottomRight.bottomLeft  = proxyPlanePixelCoords + vec2(+0.0, -0.5);
    surfelPixelCoordsBottomRight.bottomRight = proxyPlanePixelCoords + vec2(+0.5, -0.5);
    surfelPixelCoordsBottomRight.topLeft     = proxyPlanePixelCoords + vec2(+0.0, +0.0);
    surfelPixelCoordsBottomRight.topRight    = proxyPlanePixelCoords + vec2(+0.5, +0.0);

    Quad2D surfelPixelCoordsTopLeft;
    surfelPixelCoordsTopLeft.bottomLeft  = proxyPlanePixelCoords + vec2(-0.5, +0.0);
    surfelPixelCoordsTopLeft.bottomRight = proxyPlanePixelCoords + vec2(+0.0, +0.0);
    surfelPixelCoordsTopLeft.topLeft     = proxyPlanePixelCoords + vec2(-0.5, +0.5);
    surfelPixelCoordsTopLeft.topRight    = proxyPlanePixelCoords + vec2(+0.0, +0.5);

    Quad2D surfelPixelCoordsTopRight;
    surfelPixelCoordsTopRight.bottomLeft  = proxyPlanePixelCoords + vec2(+0.0, +0.0);
    surfelPixelCoordsTopRight.bottomRight = proxyPlanePixelCoords + vec2(+0.5, +0.0);
    surfelPixelCoordsTopRight.topLeft     = proxyPlanePixelCoords + vec2(+0.0, +0.5);
    surfelPixelCoordsTopRight.topRight    = proxyPlanePixelCoords + vec2(+0.5, +0.5);

    // load the depth offsets for the surfel corners
    Quad1D depthOffsetsBottomLeft, depthOffsetsBottomRight, depthOffsetsTopLeft, depthOffsetsTopRight;
    loadDepthOffsets(depthOffsetsBottomLeft,  4 * depthOffsetPixelCoord + 2 * ivec2(0, 0));
    loadDepthOffsets(depthOffsetsBottomRight, 4 * depthOffsetPixelCoord + 2 * ivec2(1, 0));
    loadDepthOffsets(depthOffsetsTopLeft,     4 * depthOffsetPixelCoord + 2 * ivec2(0, 1));
    loadDepthOffsets(depthOffsetsTopRight,    4 * depthOffsetPixelCoord + 2 * ivec2(1, 1));

    createSurfel(surfelBottomLeft, surfelPixelCoordsBottomLeft, depthOffsetsBottomLeft, proxyPlanePt, proxyPlaneNormal);
    createSurfel(surfelBottomRight, surfelPixelCoordsBottomRight, depthOffsetsBottomRight, proxyPlanePt, proxyPlaneNormal);
    createSurfel(surfelTopLeft, surfelPixelCoordsTopLeft, depthOffsetsTopLeft, proxyPlanePt, proxyPlaneNormal);
    createSurfel(surfelTopRight, surfelPixelCoordsTopRight, depthOffsetsTopRight, proxyPlanePt, proxyPlaneNormal);
}

void storeQuad(Quad quad) {
    /************************

            tl -- tr
            |   / |
            | /   |
            bl -- br

    ************************/

    uint vertexIdxBase = atomicAdd(numVertices, VERTICES_IN_A_QUAD);

    uint vertexIndexTopLeft = vertexIdxBase + 0u;
    vertices[vertexIndexTopLeft].position = viewToWorld(viewInverse, quad.topLeft);
    vertices[vertexIndexTopLeft].color = vec3(1.0, 1.0, 1.0);
    vertices[vertexIndexTopLeft].texCoords = worldToScreen(view, projection, vertices[vertexIndexTopLeft].position);

    uint vertexIndexTopRight = vertexIdxBase + 1u;
    vertices[vertexIndexTopRight].position = viewToWorld(viewInverse, quad.topRight);
    vertices[vertexIndexTopRight].color = vec3(1.0, 1.0, 1.0);
    vertices[vertexIndexTopRight].texCoords = worldToScreen(view, projection, vertices[vertexIndexTopRight].position);

    uint vertexIndexBottomLeft = vertexIdxBase + 2u;
    vertices[vertexIndexBottomLeft].position = viewToWorld(viewInverse, quad.bottomLeft);
    vertices[vertexIndexBottomLeft].color = vec3(1.0, 1.0, 1.0);
    vertices[vertexIndexBottomLeft].texCoords = worldToScreen(view, projection, vertices[vertexIndexBottomLeft].position);

    uint vertexIndexBottomRight = vertexIdxBase + 3u;
    vertices[vertexIndexBottomRight].position = viewToWorld(viewInverse, quad.bottomRight);
    vertices[vertexIndexBottomRight].color = vec3(1.0, 1.0, 1.0);
    vertices[vertexIndexBottomRight].texCoords = worldToScreen(view, projection, vertices[vertexIndexBottomRight].position);

    verticesWireframe[vertexIndexTopLeft] = vertices[vertexIndexTopLeft];
    verticesWireframe[vertexIndexTopRight] = vertices[vertexIndexTopRight];
    verticesWireframe[vertexIndexBottomLeft] = vertices[vertexIndexBottomLeft];
    verticesWireframe[vertexIndexBottomRight] = vertices[vertexIndexBottomRight];

    uint indexIdxBase = atomicAdd(numIndices, INDICES_IN_A_QUAD);

    indices[indexIdxBase + 0u] = vertexIndexTopLeft;
    indices[indexIdxBase + 1u] = vertexIndexBottomLeft;
    indices[indexIdxBase + 2u] = vertexIndexTopRight;

    indices[indexIdxBase + 3u] = vertexIndexTopRight;
    indices[indexIdxBase + 4u] = vertexIndexBottomLeft;
    indices[indexIdxBase + 5u] = vertexIndexBottomRight;

    indicesWireframe[indexIdxBase + 0u] = indices[indexIdxBase + 0u];
    indicesWireframe[indexIdxBase + 1u] = indices[indexIdxBase + 1u];
    indicesWireframe[indexIdxBase + 2u] = indices[indexIdxBase + 2u];
    indicesWireframe[indexIdxBase + 3u] = indices[indexIdxBase + 3u];
    indicesWireframe[indexIdxBase + 4u] = indices[indexIdxBase + 4u];
    indicesWireframe[indexIdxBase + 5u] = indices[indexIdxBase + 5u];
}

void main() {
    /**********************

      (stl)  ------- (str)
        |             |
        |     sc      |
        |             |
      (sbl) ------- (sbl)

    **********************/

    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);

    QuadMapData quadMapData = loadQuadMap(pixelCoord);

    Quad q1, q2, q3, q4;
    loadSurfelsFromQuadMap(
        q1, q2, q3, q4,
        quadMapData
    );

    storeQuad(q1);
    storeQuad(q2);
    storeQuad(q3);
    storeQuad(q4);
}
