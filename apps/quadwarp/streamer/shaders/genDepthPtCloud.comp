layout(local_size_x = THREADS_PER_LOCALGROUP, local_size_y = THREADS_PER_LOCALGROUP, local_size_z = 1) in;

precision highp sampler2D;
precision highp image2D;

layout(binding = 0) uniform sampler2D depthMap;

struct Vertex {
    uint id;
    vec3 position;
    vec3 color;
    vec3 normal;
    vec2 texCoords;
    vec3 tangent;
    vec3 bitangent;
};

uniform vec2 remoteWindowSize;

uniform mat4 view;
uniform mat4 projection;
uniform mat4 viewInverse;
uniform mat4 projectionInverse;

uniform float near;
uniform float far;

#define MAX_DEPTH 0.9999

layout(std430, binding = 0) buffer VertexBufferDepth {
    Vertex verticesDepth[];
};

vec3 ndcToView(mat4 projectionInverse, vec2 ndc, float depth) {
    vec4 ndcPos;
    ndcPos.xy = ndc;
    ndcPos.z = depth * 2.0 - 1.0;
    ndcPos.w = 1.0;

    vec4 viewCoord = projectionInverse * ndcPos;
    viewCoord = viewCoord / viewCoord.w;
    return viewCoord.xyz;
}

vec3 viewToNDC(mat4 projection, vec3 viewCoord) {
    vec4 ndcCoord = projection * vec4(viewCoord, 1.0);
    ndcCoord = ndcCoord / ndcCoord.w;
    ndcCoord.z = (ndcCoord.z + 1.0) / 2.0;
    return ndcCoord.xyz;
}

vec3 viewToWorld(mat4 viewInverse, vec3 viewCoord) {
    vec4 worldCoord = viewInverse * vec4(viewCoord, 1.0);
    worldCoord = worldCoord / worldCoord.w;
    return worldCoord.xyz;
}

vec3 worldToView(mat4 view, vec3 worldCoord) {
    vec4 viewCoord = view * vec4(worldCoord, 1.0);
    viewCoord = viewCoord / viewCoord.w;
    return viewCoord.xyz;
}

vec2 viewToScreen(mat4 projection, vec3 viewCoord) {
    vec2 ndc = viewToNDC(projection, viewCoord).xy;
    vec2 uv = (ndc + 1.0) / 2.0;
    return uv;
}

float sampleDepth(sampler2D depthMap, vec2 sampleCoord) {
    float depth = texture(depthMap, sampleCoord).x;
    depth = clamp(depth, 0.0, MAX_DEPTH);
    return depth;
}

float LinearizeDepth(float depth) {
    float z = depth * 2.0 - 1.0; // back to NDC
    return (2.0 * near * far) / (far + near - z * (far - near));
}

float NormalizeDepth(float depth) {
    depth = clamp(depth, near, far);
    float z = (depth - near) / (far - near);
    return (1.0 - (1.0 / (1.0 + z * (far - near) / near)));
}

vec3 sampleNormal(sampler2D normalMap, vec2 sampleCoord) {
    return normalize(texture(normalMap, sampleCoord).xyz);
}

void main() {
    uint shaderIndex = uint(gl_GlobalInvocationID.y * remoteWindowSize.x + gl_GlobalInvocationID.x);

    vec2 surfelCoordBottomLeft = vec2(gl_GlobalInvocationID.xy);
    vec2 pixelCoordsCenter     = surfelCoordBottomLeft + vec2(0.5, 0.5) + vec2(+0.0, +0.0);
    vec2 uvCenter              = pixelCoordsCenter / remoteWindowSize;
    vec2 pixelCoordsNDC        = 2.0 * uvCenter - 1.0;
    float pixelDepth           = sampleDepth(depthMap, uvCenter);
    vec3 pixelCoordsViewCenter = ndcToView(projectionInverse, pixelCoordsNDC, pixelDepth);

    // store depth
    verticesDepth[shaderIndex].position = viewToWorld(viewInverse, pixelCoordsViewCenter);
    verticesDepth[shaderIndex].color = vec3(1.0, 1.0, 1.0);
    verticesDepth[shaderIndex].texCoords = viewToScreen(projection, pixelCoordsViewCenter);
}
