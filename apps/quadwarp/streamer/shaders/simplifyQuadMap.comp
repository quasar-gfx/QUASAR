layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

precision highp sampler2D;
precision highp image2D;

struct QuadMapData {
    bool flattened;
    vec3 normal;
    vec2 uv;
    float depth;
    ivec2 offset;
    uint size;
};

uniform vec2 quadMapSize;

uniform mat4 view;
uniform mat4 projection;
uniform mat4 viewInverse;
uniform mat4 projectionInverse;

uniform float near;
uniform float far;

uniform float similarityThreshold;

#define MAX_DEPTH 0.9999

layout(std430, binding = 0) buffer QuadMapBuffer {
    QuadMapData quadMap[];
};

layout(std430, binding = 1) buffer OutputQuadMapBuffer {
    QuadMapData outputQuadMap[];
};

layout(std430, binding = 2) buffer QuadMap2SizeBuffer {
    uint quadMap2Size;
};

layout(std430, binding = 7) buffer DepthOffsetBuffer {
    float depthOffsetBuffer[];
};

vec3 ndcToView(mat4 projectionInverse, vec2 ndc, float depth) {
    depth = clamp(depth, 0.0, MAX_DEPTH);

    vec4 ndcPos;
    ndcPos.xy = ndc;
    ndcPos.z = 2.0 * depth - 1.0;
    ndcPos.w = 1.0;

    vec4 viewCoord = projectionInverse * ndcPos;
    viewCoord = viewCoord / viewCoord.w;
    return viewCoord.xyz;
}

vec3 viewToWorld(mat4 viewInverse, vec3 viewCoord) {
    vec4 worldCoord = viewInverse * vec4(viewCoord, 1.0);
    worldCoord = worldCoord / worldCoord.w;
    return worldCoord.xyz;
}

vec3 worldToView(mat4 view, vec3 worldCoord) {
    vec4 viewCoord = view * vec4(worldCoord, 1.0);
    viewCoord = viewCoord / viewCoord.w;
    return viewCoord.xyz;
}

vec2 viewToNDC(mat4 projection, vec3 viewCoord) {
    vec4 ndcCoord = projection * vec4(viewCoord, 1.0);
    ndcCoord = ndcCoord / ndcCoord.w;
    return ndcCoord.xy;
}

vec2 ndcToScreen(vec2 ndc) {
    return (ndc + 1.0) / 2.0;
}

vec2 worldToScreen(mat4 view, mat4 projection, vec3 worldCoord) {
    vec2 ndc = viewToNDC(projection, worldToView(view, worldCoord));
    return ndcToScreen(ndc);
}

QuadMapData loadQuadMap(ivec2 pixelCoord) {
    uint index = uint(pixelCoord.y) * uint(quadMapSize.x) + uint(pixelCoord.x);
    QuadMapData quadMapData = quadMap[index];
    return quadMapData;
}

QuadMapData mergeQuadMapData(QuadMapData quadMapDataBottomLeft, QuadMapData quadMapDataBottomRight, QuadMapData quadMapDataTopLeft, QuadMapData quadMapDataTopRight) {
    QuadMapData mergedQuadMapData;

    mergedQuadMapData.normal = (quadMapDataBottomLeft.normal + quadMapDataBottomRight.normal + quadMapDataTopLeft.normal + quadMapDataTopRight.normal) / 4.0;
    mergedQuadMapData.uv = (quadMapDataBottomLeft.uv + quadMapDataBottomRight.uv + quadMapDataTopLeft.uv + quadMapDataTopRight.uv) / 4.0;
    mergedQuadMapData.depth = (quadMapDataBottomLeft.depth + quadMapDataBottomRight.depth + quadMapDataTopLeft.depth + quadMapDataTopRight.depth) / 4.0;
    mergedQuadMapData.offset = quadMapDataBottomLeft.offset;
    mergedQuadMapData.size = (quadMapDataBottomLeft.size + quadMapDataBottomRight.size + quadMapDataTopLeft.size + quadMapDataTopRight.size);

    return mergedQuadMapData;
}

void main() {
    ivec2 pixelCoord = 2 * ivec2(gl_GlobalInvocationID.xy);

    uint outputIndex = atomicAdd(quadMap2Size, 4u);

    QuadMapData quadMapDataBottomLeft = loadQuadMap(pixelCoord + ivec2(0, 0));
    QuadMapData quadMapDataBottomRight = loadQuadMap(pixelCoord + ivec2(1, 0));
    QuadMapData quadMapDataTopLeft = loadQuadMap(pixelCoord + ivec2(0, 1));
    QuadMapData quadMapDataTopRight = loadQuadMap(pixelCoord + ivec2(1, 1));

    // if (!quadMapData.flattened) {
    //     return;
    // }

    outputQuadMap[outputIndex + 0u] = quadMapDataBottomLeft;
    outputQuadMap[outputIndex + 1u] = quadMapDataBottomRight;
    outputQuadMap[outputIndex + 2u] = quadMapDataTopLeft;
    outputQuadMap[outputIndex + 3u] = quadMapDataTopRight;
}
