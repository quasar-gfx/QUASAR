layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

precision highp sampler2D;
precision highp image2D;

struct QuadMapData {
    bool flattened;
    vec3 normal;
    vec2 uv;
    float depth;
    ivec2 offset;
    uint size;
};

struct Plane {
    vec3 normal;
    vec3 point;
};

struct PlaneEq {
    vec3 normal;
    float constant;
};

uniform vec2 remoteWinSize;
uniform vec2 quadMapSize;
uniform vec2 depthBufferSize;

uniform mat4 view;
uniform mat4 projection;
uniform mat4 viewInverse;
uniform mat4 projectionInverse;

uniform float near;
uniform float far;

uniform float similarityThreshold;

const float epilson = 1e-5;

const vec3 origin = vec3(0.0, 0.0, 0.0);

#define MAX_DEPTH 0.9999

layout(std430, binding = 0) buffer QuadMapBuffer {
    QuadMapData quadMap[];
};

layout(std430, binding = 1) buffer OutputQuadMapBuffer {
    QuadMapData outputQuadMap[];
};

layout(std430, binding = 2) buffer QuadMap2SizeBuffer {
    uint quadMap2Size;
};

layout(std430, binding = 3) buffer DepthOffsetBuffer {
    float depthOffsetBuffer[];
};

vec3 ndcToView(mat4 projectionInverse, vec2 ndc, float depth) {
    vec4 ndcPos;
    ndcPos.xy = ndc;
    ndcPos.z = depth * 2.0 - 1.0;
    ndcPos.w = 1.0;

    vec4 viewCoord = projectionInverse * ndcPos;
    viewCoord = viewCoord / viewCoord.w;
    return viewCoord.xyz;
}

vec3 viewToNDC(mat4 projection, vec3 viewCoord) {
    vec4 ndcCoord = projection * vec4(viewCoord, 1.0);
    ndcCoord = ndcCoord / ndcCoord.w;
    ndcCoord.z = (ndcCoord.z + 1.0) / 2.0;
    return ndcCoord.xyz;
}

vec3 viewToWorld(mat4 viewInverse, vec3 viewCoord) {
    vec4 worldCoord = viewInverse * vec4(viewCoord, 1.0);
    worldCoord = worldCoord / worldCoord.w;
    return worldCoord.xyz;
}

vec3 worldToView(mat4 view, vec3 worldCoord) {
    vec4 viewCoord = view * vec4(worldCoord, 1.0);
    viewCoord = viewCoord / viewCoord.w;
    return viewCoord.xyz;
}

vec2 worldToScreen(mat4 view, mat4 projection, vec3 worldCoord) {
    vec2 ndc = viewToNDC(projection, worldToView(view, worldCoord)).xy;
    vec2 uv = (ndc + 1.0) / 2.0;
    return uv;
}

vec3 rayPlaneIntersection(vec3 rayOrigin, vec3 rayDirection, Plane plane) {
    float denominator = dot(rayDirection, plane.normal);
    if (abs(denominator) < epilson) {
        return vec3(1.0/0.0, 1.0/0.0, 1.0/0.0);
    }

    float t = dot(plane.point - rayOrigin, plane.normal) / denominator;
    if (t < 0.0) {
        return vec3(1.0/0.0, 1.0/0.0, 1.0/0.0);
    }

    vec3 intersection = rayOrigin + t * rayDirection;
    return intersection;
}

vec3 pointPlaneIntersection(vec3 pt, Plane plane) {
    vec3 rayDirection = normalize(pt);
    return rayPlaneIntersection(origin, rayDirection, plane);
}

QuadMapData loadQuadMap(ivec2 pixelCoord) {
    uint index = uint(pixelCoord.y) * uint(quadMapSize.x) + uint(pixelCoord.x);
    QuadMapData quadMapData = quadMap[index];
    return quadMapData;
}

Plane quadMapDataToPlane(in QuadMapData quadMapData) {
    Plane proxyPlane;

    vec2 proxyPlaneUV = quadMapData.uv;
    float proxyPlaneDepth = quadMapData.depth;
    proxyPlane.normal = quadMapData.normal;

    vec2 proxyPlaneNDC = proxyPlaneUV * 2.0 - 1.0;
    proxyPlane.point = ndcToView(projectionInverse, proxyPlaneNDC, proxyPlaneDepth);

    return proxyPlane;
}

bool planeEquationsSimilar(in PlaneEq planeEq1, in PlaneEq planeEq2) {
    float similarity = distance(planeEq1.normal, planeEq2.normal) + abs(planeEq1.constant - planeEq2.constant);
    return similarity > similarityThreshold;
}

PlaneEq planeToPlaneEq(in Plane plane) {
    PlaneEq planeEq;
    planeEq.normal = plane.normal;
    planeEq.constant = -dot(plane.point, plane.normal);
    return planeEq;
}

bool shouldMerge(in Plane proxyPlaneBottomLeft, in Plane proxyPlaneBottomRight, in Plane proxyPlaneTopLeft, in Plane proxyPlaneTopRight) {
    PlaneEq proxyPlaneEqBottomLeft  = planeToPlaneEq(proxyPlaneBottomLeft);
    PlaneEq proxyPlaneEqBottomRight = planeToPlaneEq(proxyPlaneBottomRight);
    PlaneEq proxyPlaneEqTopLeft     = planeToPlaneEq(proxyPlaneTopLeft);
    PlaneEq proxyPlaneEqTopRight    = planeToPlaneEq(proxyPlaneTopRight);

    return planeEquationsSimilar(proxyPlaneEqBottomLeft, proxyPlaneEqBottomRight) &&
           planeEquationsSimilar(proxyPlaneEqBottomLeft, proxyPlaneEqTopLeft) &&
           planeEquationsSimilar(proxyPlaneEqBottomLeft, proxyPlaneEqTopRight) &&
           planeEquationsSimilar(proxyPlaneEqBottomRight, proxyPlaneEqTopLeft) &&
           planeEquationsSimilar(proxyPlaneEqBottomRight, proxyPlaneEqTopRight) &&
           planeEquationsSimilar(proxyPlaneEqTopLeft, proxyPlaneEqTopRight);
}

void mergeQuadMapData(
    out QuadMapData mergedQuadMapData,
    in QuadMapData quadMapDataBottomLeft, in QuadMapData quadMapDataBottomRight, in QuadMapData quadMapDataTopLeft, in QuadMapData quadMapDataTopRight,
    in Plane proxyPlaneBottomLeft, in Plane proxyPlaneBottomRight, in Plane proxyPlaneTopLeft, in Plane proxyPlaneTopRight
) {
    // get average plane normal and point
    Plane proxyPlane;
    proxyPlane.normal = (proxyPlaneBottomLeft.normal + proxyPlaneBottomRight.normal + proxyPlaneTopLeft.normal + proxyPlaneTopRight.normal) / 4.0;
    proxyPlane.point = (proxyPlaneBottomLeft.point + proxyPlaneBottomRight.point + proxyPlaneTopLeft.point + proxyPlaneTopRight.point) / 4.0;

    // find what depth the average uv maps to on the new plane
    float halfQuadSize = float(quadMapDataBottomLeft.size / 2);

    vec2 averageUV = (quadMapDataBottomLeft.uv + halfQuadSize / remoteWinSize);
    vec2 averageNDC = averageUV * 2.0 - 1.0;
    vec3 averageFarPlane = ndcToView(projectionInverse, averageNDC, 1.0);

    vec3 planeCenterPt = pointPlaneIntersection(averageFarPlane, proxyPlane);
    vec3 proxyPlaneNDC = viewToNDC(projection, planeCenterPt);
    vec2 proxyPlaneUV = (proxyPlaneNDC.xy + 1.0) / 2.0;

    float proxyPlaneDepth = proxyPlaneNDC.z;

    mergedQuadMapData.flattened = true;
    mergedQuadMapData.normal = proxyPlane.normal;
    mergedQuadMapData.uv = averageUV;
    mergedQuadMapData.depth = proxyPlaneDepth;
    mergedQuadMapData.offset = quadMapDataBottomLeft.offset;
    mergedQuadMapData.size = 2 * quadMapDataBottomLeft.size;
}

void main() {
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);

    QuadMapData quadMapDataBottomLeft  = loadQuadMap(2 * pixelCoord + ivec2(0, 0));
    QuadMapData quadMapDataBottomRight = loadQuadMap(2 * pixelCoord + ivec2(1, 0));
    QuadMapData quadMapDataTopLeft     = loadQuadMap(2 * pixelCoord + ivec2(0, 1));
    QuadMapData quadMapDataTopRight    = loadQuadMap(2 * pixelCoord + ivec2(1, 1));

    // create proxy planes
    Plane proxyPlaneBottomLeft  = quadMapDataToPlane(quadMapDataBottomLeft);
    Plane proxyPlaneBottomRight = quadMapDataToPlane(quadMapDataBottomRight);
    Plane proxyPlaneTopLeft     = quadMapDataToPlane(quadMapDataTopLeft);
    Plane proxyPlaneTopRight    = quadMapDataToPlane(quadMapDataTopRight);

    if (shouldMerge(proxyPlaneBottomLeft, proxyPlaneBottomRight, proxyPlaneTopLeft, proxyPlaneTopRight) &&
            quadMapDataBottomLeft.flattened && quadMapDataBottomRight.flattened && quadMapDataTopLeft.flattened && quadMapDataTopRight.flattened) {
        QuadMapData mergedQuadMapData;
        mergeQuadMapData(
            mergedQuadMapData, quadMapDataBottomLeft, quadMapDataBottomRight, quadMapDataTopLeft, quadMapDataTopRight,
            proxyPlaneBottomLeft, proxyPlaneBottomRight, proxyPlaneTopLeft, proxyPlaneTopRight
        );
        uint outputIndex = atomicAdd(quadMap2Size, 1);
        outputQuadMap[outputIndex] = mergedQuadMapData;
    }
    else {
        uint outputIndex = atomicAdd(quadMap2Size, 4);
        outputQuadMap[outputIndex + 0u] = quadMapDataBottomLeft;
        outputQuadMap[outputIndex + 1] = quadMapDataBottomRight;
        outputQuadMap[outputIndex + 2] = quadMapDataTopLeft;
        outputQuadMap[outputIndex + 3] = quadMapDataTopRight;
    }
}
