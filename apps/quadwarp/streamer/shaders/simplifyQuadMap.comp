layout(local_size_x = THREADS_PER_LOCALGROUP, local_size_y = THREADS_PER_LOCALGROUP, local_size_z = 1) in;

precision highp float;
precision highp sampler2D;
precision highp image2D;

struct QuadMapData {
    vec3 normal;
    float depth;
    vec2 uv;
    ivec2 offset;
    uint size;
    bool flattened;
};

struct Quad {
    vec3 bottomLeft;
    vec3 bottomRight;
    vec3 topLeft;
    vec3 topRight;
};

struct Quad1D {
    float bottomLeft;
    float bottomRight;
    float topLeft;
    float topRight;
};

struct Quad2D {
    vec2 bottomLeft;
    vec2 bottomRight;
    vec2 topLeft;
    vec2 topRight;
};

// a Quad subdivided into 4 smaller Quads
struct MultiQuad {
    vec3 bottomLeft;
    vec3 bottom;
    vec3 bottomRight;
    vec3 left;
    vec3 center;
    vec3 right;
    vec3 topLeft;
    vec3 top;
    vec3 topRight;
};

struct MultiQuad1D {
    float bottomLeft;
    float bottom;
    float bottomRight;
    float left;
    float center;
    float right;
    float topLeft;
    float top;
    float topRight;
};

struct MultiQuad2D {
    vec2 bottomLeft;
    vec2 bottom;
    vec2 bottomRight;
    vec2 left;
    vec2 center;
    vec2 right;
    vec2 topLeft;
    vec2 top;
    vec2 topRight;
};

struct Plane {
    vec3 normal;
    vec3 point;
};

struct PlaneEq {
    vec3 normal;
    float constant;
};

uniform vec2 remoteWindowSize;
uniform vec2 inputQuadMapSize;
uniform vec2 outputQuadMapSize;
uniform vec2 depthBufferSize;

uniform mat4 view;
uniform mat4 projection;
uniform mat4 viewInverse;
uniform mat4 projectionInverse;

uniform float near;
uniform float far;

uniform float flatThreshold;
uniform float proxySimilarityThreshold;

#define MAX_DEPTH 0.9999

const float epsilon = 1e-5;

const float surfelSize = 0.5;
const vec3 origin = vec3(0.0, 0.0, 0.0);

layout(std430, binding = 0) buffer InputQuadMapBuffer {
    QuadMapData inputQuadMap[];
};

layout(std430, binding = 1) writeonly buffer OutputQuadMapBuffer {
    QuadMapData outputQuadMap[];
};

layout(r16f, binding = 2) uniform image2D depthOffsetBuffer;

vec3 ndcToView(mat4 projectionInverse, vec2 ndc, float depth) {
    vec4 ndcPos;
    ndcPos.xy = ndc;
    ndcPos.z = depth * 2.0 - 1.0;
    ndcPos.w = 1.0;

    vec4 viewCoord = projectionInverse * ndcPos;
    viewCoord = viewCoord / viewCoord.w;
    return viewCoord.xyz;
}

vec3 viewToNDC(mat4 projection, vec3 viewCoord) {
    vec4 ndcCoord = projection * vec4(viewCoord, 1.0);
    ndcCoord = ndcCoord / ndcCoord.w;
    ndcCoord.z = (ndcCoord.z + 1.0) / 2.0;
    return ndcCoord.xyz;
}

vec3 viewToWorld(mat4 viewInverse, vec3 viewCoord) {
    vec4 worldCoord = viewInverse * vec4(viewCoord, 1.0);
    worldCoord = worldCoord / worldCoord.w;
    return worldCoord.xyz;
}

vec3 worldToView(mat4 view, vec3 worldCoord) {
    vec4 viewCoord = view * vec4(worldCoord, 1.0);
    viewCoord = viewCoord / viewCoord.w;
    return viewCoord.xyz;
}

vec2 viewToScreen(mat4 projection, vec3 viewCoord) {
    vec2 ndc = viewToNDC(projection, viewCoord).xy;
    vec2 uv = (ndc + 1.0) / 2.0;
    return uv;
}

float signedDistance(vec3 p1, vec3 p2) {
    float dist = distance(p1, p2);
    return (length(p1) > length(p2)) ? dist : -dist;
}

float normalizeDepth(float depth) {
    depth = clamp(depth, near, far);
    float z = (depth - near) / (far - near);
    return (1.0 - (1.0 / (1.0 + z * (far - near) / near)));
}

vec3 rayPlaneIntersection(vec3 rayOrigin, vec3 rayDirection, Plane plane) {
    float denominator = dot(rayDirection, plane.normal);
    if (abs(denominator) < epsilon) {
        return vec3(1.0/0.0);
    }

    float t = dot(plane.point - rayOrigin, plane.normal) / denominator;
    if (t < 0.0) {
        return vec3(1.0/0.0);
    }

    vec3 intersection = rayOrigin + t * rayDirection;
    return intersection;
}

vec3 pointPlaneIntersection(vec3 pt, Plane plane) {
    vec3 rayDirection = normalize(pt);
    return rayPlaneIntersection(origin, rayDirection, plane);
}

QuadMapData loadInputQuadMap(ivec2 pixelCoord) {
    uint index = uint(pixelCoord.y) * uint(inputQuadMapSize.x) + uint(pixelCoord.x);
    QuadMapData quadMapData = inputQuadMap[index];
    return quadMapData;
}

float loadDepthOffset(in ivec2 pixelCoord) {
    return imageLoad(depthOffsetBuffer, pixelCoord).x;
}

void storeInInputQuadMap(in ivec2 pixelCoord, in QuadMapData quadMapData) {
    uint index = uint(pixelCoord.y) * uint(inputQuadMapSize.x) + uint(pixelCoord.x);
    inputQuadMap[index] = quadMapData;
}

void storeInOutputQuadMap(in ivec2 pixelCoord, in QuadMapData quadMapData) {
    uint index = uint(pixelCoord.y) * uint(outputQuadMapSize.x) + uint(pixelCoord.x);
    outputQuadMap[index] = quadMapData;
}

void storeInDepthOffsetBuffer(in ivec2 pixelCoord, in float depthOffset) {
    imageStore(depthOffsetBuffer, pixelCoord, vec4(depthOffset));
}

void ignoreInputQuadMapData(in ivec2 pixelCoord) {
    uint index = uint(pixelCoord.y) * uint(inputQuadMapSize.x) + uint(pixelCoord.x);
    inputQuadMap[index].size = 0;
}

void loadDepthOffsets(out Quad1D depthOffsets, in ivec2 pixelCoord) {
    depthOffsets.bottomLeft  = loadDepthOffset(pixelCoord + ivec2(0, 0));
    depthOffsets.bottomRight = loadDepthOffset(pixelCoord + ivec2(1, 0));
    depthOffsets.topLeft     = loadDepthOffset(pixelCoord + ivec2(0, 1));
    depthOffsets.topRight    = loadDepthOffset(pixelCoord + ivec2(1, 1));
}

Plane quadMapDataToPlane(in QuadMapData quadMapData) {
    Plane proxyPlane;

    vec2 proxyPlaneUV = quadMapData.uv;
    float proxyPlaneDepth = quadMapData.depth;
    proxyPlane.normal = quadMapData.normal;

    vec2 proxyPlaneNDC = proxyPlaneUV * 2.0 - 1.0;
    proxyPlane.point = ndcToView(projectionInverse, proxyPlaneNDC, proxyPlaneDepth);

    return proxyPlane;
}

Quad1D findDepthOffsets(in Quad quadView, in Plane proxyPlane) {
    Quad quadPtsOnPlane;
    quadPtsOnPlane.bottomLeft  = pointPlaneIntersection(quadView.bottomLeft,  proxyPlane);
    quadPtsOnPlane.bottomRight = pointPlaneIntersection(quadView.bottomRight, proxyPlane);
    quadPtsOnPlane.topLeft     = pointPlaneIntersection(quadView.topLeft,     proxyPlane);
    quadPtsOnPlane.topRight    = pointPlaneIntersection(quadView.topRight,    proxyPlane);

    Quad1D depthOffsets;
    depthOffsets.bottomLeft  = signedDistance(quadPtsOnPlane.bottomLeft,  quadView.bottomLeft);
    depthOffsets.bottomRight = signedDistance(quadPtsOnPlane.bottomRight, quadView.bottomRight);
    depthOffsets.topLeft     = signedDistance(quadPtsOnPlane.topLeft,     quadView.topLeft);
    depthOffsets.topRight    = signedDistance(quadPtsOnPlane.topRight,    quadView.topRight);

    return depthOffsets;
}

void storeDepthOffsets(in ivec2 pixelCoord, in Quad1D depthOffsets) {
    storeInDepthOffsetBuffer(pixelCoord + ivec2(0, 0), depthOffsets.bottomLeft);
    storeInDepthOffsetBuffer(pixelCoord + ivec2(1, 0), depthOffsets.bottomRight);
    storeInDepthOffsetBuffer(pixelCoord + ivec2(0, 1), depthOffsets.topLeft);
    storeInDepthOffsetBuffer(pixelCoord + ivec2(1, 1), depthOffsets.topRight);
}

void createSurfel(out Quad surfel, in Quad2D surfelPixelCoords, in Quad1D depthOffsets, in Plane proxyPlane) {
    Quad2D surfelUVs;
    surfelUVs.bottomLeft  = surfelPixelCoords.bottomLeft / remoteWindowSize;
    surfelUVs.bottomRight = surfelPixelCoords.bottomRight / remoteWindowSize;
    surfelUVs.topLeft     = surfelPixelCoords.topLeft / remoteWindowSize;
    surfelUVs.topRight    = surfelPixelCoords.topRight / remoteWindowSize;

    Quad2D surfelNDCs;
    surfelNDCs.bottomLeft  = surfelUVs.bottomLeft * 2.0 - 1.0;
    surfelNDCs.bottomRight = surfelUVs.bottomRight * 2.0 - 1.0;
    surfelNDCs.topLeft     = surfelUVs.topLeft * 2.0 - 1.0;
    surfelNDCs.topRight    = surfelUVs.topRight * 2.0 - 1.0;

    Quad surfelNearPlane;
    surfelNearPlane.bottomLeft  = ndcToView(projectionInverse, surfelNDCs.bottomLeft, 0.0);
    surfelNearPlane.bottomRight = ndcToView(projectionInverse, surfelNDCs.bottomRight, 0.0);
    surfelNearPlane.topLeft     = ndcToView(projectionInverse, surfelNDCs.topLeft, 0.0);
    surfelNearPlane.topRight    = ndcToView(projectionInverse, surfelNDCs.topRight, 0.0);

    // shoot rays from corners of the surfel to the plane to find the 3D intersection points
    Quad quadPtsOnPlane;
    quadPtsOnPlane.bottomLeft  = pointPlaneIntersection(surfelNearPlane.bottomLeft,  proxyPlane);
    quadPtsOnPlane.bottomRight = pointPlaneIntersection(surfelNearPlane.bottomRight, proxyPlane);
    quadPtsOnPlane.topLeft     = pointPlaneIntersection(surfelNearPlane.topLeft,     proxyPlane);
    quadPtsOnPlane.topRight    = pointPlaneIntersection(surfelNearPlane.topRight,    proxyPlane);

    // apply depth offsets to the quad points
    surfel.bottomLeft  = quadPtsOnPlane.bottomLeft  - depthOffsets.bottomLeft  * normalize(quadPtsOnPlane.bottomLeft);
    surfel.bottomRight = quadPtsOnPlane.bottomRight - depthOffsets.bottomRight * normalize(quadPtsOnPlane.bottomRight);
    surfel.topLeft     = quadPtsOnPlane.topLeft     - depthOffsets.topLeft     * normalize(quadPtsOnPlane.topLeft);
    surfel.topRight    = quadPtsOnPlane.topRight    - depthOffsets.topRight    * normalize(quadPtsOnPlane.topRight);
}

bool planeEquationsSimilar(in PlaneEq planeEq1, in PlaneEq planeEq2) {
    vec4 planeEq1Vec = vec4(planeEq1.normal, planeEq1.constant);
    vec4 planeEq2Vec = vec4(planeEq2.normal, planeEq2.constant);
    float similarity = distance(planeEq1Vec, planeEq2Vec);
    return similarity < proxySimilarityThreshold;
}

PlaneEq planeToPlaneEq(in Plane plane) {
    PlaneEq planeEq;
    planeEq.normal = plane.normal;
    planeEq.constant = -dot(planeEq.normal, plane.point);
    return planeEq;
}

Plane planeEqToPlane(in PlaneEq planeEq) {
    Plane plane;
    plane.normal = planeEq.normal;
    if (planeEq.normal.z != 0.0) {
        float z = -planeEq.constant / planeEq.normal.z;
        plane.point = vec3(0.0, 0.0, z);
    }
    else if (planeEq.normal.y != 0.0) {
        float y = -planeEq.constant / planeEq.normal.y;
        plane.point = vec3(0.0, y, 0.0);
    }
    else if (planeEq.normal.x != 0.0) {
        float x = -planeEq.constant / planeEq.normal.x;
        plane.point = vec3(x, 0.0, 0.0);
    }
    return plane;
}

PlaneEq averagePlaneEqs(in PlaneEq planeEq1, in PlaneEq planeEq2, in PlaneEq planeEq3, in PlaneEq planeEq4) {
    PlaneEq averagePlaneEq;
    averagePlaneEq.normal = (planeEq1.normal + planeEq2.normal + planeEq3.normal + planeEq4.normal) / 4.0;
    averagePlaneEq.constant = (planeEq1.constant + planeEq2.constant + planeEq3.constant + planeEq4.constant) / 4.0;

    float normalLength = length(averagePlaneEq.normal);
    averagePlaneEq.normal /= normalLength;
    averagePlaneEq.constant /= normalLength;

    return averagePlaneEq;
}

bool shouldMerge(in Plane proxyPlaneBottomLeft, in Plane proxyPlaneBottomRight, in Plane proxyPlaneTopLeft, in Plane proxyPlaneTopRight) {
    PlaneEq proxyPlaneEqBottomLeft  = planeToPlaneEq(proxyPlaneBottomLeft);
    PlaneEq proxyPlaneEqBottomRight = planeToPlaneEq(proxyPlaneBottomRight);
    PlaneEq proxyPlaneEqTopLeft     = planeToPlaneEq(proxyPlaneTopLeft);
    PlaneEq proxyPlaneEqTopRight    = planeToPlaneEq(proxyPlaneTopRight);

    return planeEquationsSimilar(proxyPlaneEqBottomLeft, proxyPlaneEqBottomRight) &&
           planeEquationsSimilar(proxyPlaneEqBottomLeft, proxyPlaneEqTopLeft) &&
           planeEquationsSimilar(proxyPlaneEqBottomLeft, proxyPlaneEqTopRight) &&
           planeEquationsSimilar(proxyPlaneEqBottomRight, proxyPlaneEqTopLeft) &&
           planeEquationsSimilar(proxyPlaneEqBottomRight, proxyPlaneEqTopRight) &&
           planeEquationsSimilar(proxyPlaneEqTopLeft, proxyPlaneEqTopRight);
}

void mergeQuadMapData(
    out QuadMapData mergedQuadMapData,
    in Plane proxyPlaneBottomLeft, in Plane proxyPlaneBottomRight, in Plane proxyPlaneTopLeft, in Plane proxyPlaneTopRight,
    in QuadMapData quadMapDataBottomLeft, in QuadMapData quadMapDataBottomRight, in QuadMapData quadMapDataTopLeft, in QuadMapData quadMapDataTopRight
) {
    // get average plane normal and point
    PlaneEq planeEqBottomLeft = planeToPlaneEq(proxyPlaneBottomLeft);
    PlaneEq planeEqBottomRight = planeToPlaneEq(proxyPlaneBottomRight);
    PlaneEq planeEqTopLeft = planeToPlaneEq(proxyPlaneTopLeft);
    PlaneEq planeEqTopRight = planeToPlaneEq(proxyPlaneTopRight);

    PlaneEq averagePlaneEq = averagePlaneEqs(planeEqBottomLeft, planeEqBottomRight, planeEqTopLeft, planeEqTopRight);
    Plane newProxyPlane = planeEqToPlane(averagePlaneEq);

    // find what depth the average uv maps to on the new plane
    vec2 averageUV = (quadMapDataBottomLeft.uv + quadMapDataBottomRight.uv + quadMapDataTopLeft.uv + quadMapDataTopRight.uv) / 4.0;
    vec2 averageNDC = averageUV * 2.0 - 1.0;
    vec3 averageNearPlane = ndcToView(projectionInverse, averageNDC, 0.0);

    vec3 planeCenterPt = pointPlaneIntersection(averageNearPlane, newProxyPlane);
    vec3 newProxyPlaneNDC = viewToNDC(projection, planeCenterPt);
    vec2 newProxyPlaneUV = (newProxyPlaneNDC.xy + 1.0) / 2.0;

    float newProxyPlaneDepth = min(newProxyPlaneNDC.z, MAX_DEPTH);

    // recalculate the new merged proxy plane's surfel's depth offsets
    int numBelowThreshold = 0;
    int total = 0;
    QuadMapData quadMapDatas[4] = QuadMapData[](quadMapDataBottomLeft, quadMapDataBottomRight, quadMapDataTopLeft, quadMapDataTopRight);
    Plane proxyPlanes[4] = Plane[](proxyPlaneBottomLeft, proxyPlaneBottomRight, proxyPlaneTopLeft, proxyPlaneTopRight);
    for (int i = 0; i < 4; i++) {
        QuadMapData quadMapData = quadMapDatas[i];
        Plane proxyPlane = proxyPlanes[i];

        vec2 proxyPlaneUV = quadMapData.uv;
        vec2 proxyPlanePixelCoords = vec2(proxyPlaneUV * remoteWindowSize);

        uint size = quadMapData.size;
        float halfGridSize = float(size) * surfelSize / 2;

        // calculate new depth offsets relative to new proxy plane
        vec2 start = vec2(proxyPlanePixelCoords - vec2(halfGridSize, halfGridSize));
        for (int i = 0; i < size; i++) {
            for (int j = 0; j < size; j++) {
                Quad2D surfelPixelCoords;
                surfelPixelCoords.bottomLeft  = start + vec2(float(i) * 0.5, float(j) * 0.5);
                surfelPixelCoords.bottomRight = surfelPixelCoords.bottomLeft + vec2(0.5, 0.0);
                surfelPixelCoords.topLeft     = surfelPixelCoords.bottomLeft + vec2(0.0, 0.5);
                surfelPixelCoords.topRight    = surfelPixelCoords.bottomLeft + vec2(0.5, 0.5);

                Quad1D oldDepthOffsets;
                loadDepthOffsets(oldDepthOffsets, 4 * quadMapData.offset + 2 * ivec2(i, j));

                Quad surfel;
                createSurfel(surfel, surfelPixelCoords, oldDepthOffsets, proxyPlane);

                Quad1D newDepthOffsets = findDepthOffsets(surfel, newProxyPlane);
                storeDepthOffsets(4 * quadMapData.offset + 2 * ivec2(i, j), newDepthOffsets);

                if (abs(newDepthOffsets.bottomLeft)  < flatThreshold) numBelowThreshold++;
                if (abs(newDepthOffsets.bottomRight) < flatThreshold) numBelowThreshold++;
                if (abs(newDepthOffsets.topLeft)     < flatThreshold) numBelowThreshold++;
                if (abs(newDepthOffsets.topRight)    < flatThreshold) numBelowThreshold++;
                total += 4;
            }
        }
    }

    // if more than half the surfels are below the threshold, then the plane is considered flattened
    bool flattened = numBelowThreshold > total / 2;

    mergedQuadMapData.flattened = flattened;
    mergedQuadMapData.normal = newProxyPlane.normal;
    mergedQuadMapData.uv = newProxyPlaneUV;
    mergedQuadMapData.depth = newProxyPlaneDepth;
    mergedQuadMapData.offset = quadMapDataBottomLeft.offset;
    mergedQuadMapData.size = 2 * quadMapDataBottomLeft.size;
}

void main() {
    ivec2 pixelCoord             = ivec2(gl_GlobalInvocationID.xy);
    ivec2 pixelCoordsBottomLeft  = 2 * pixelCoord + ivec2(0, 0);
    ivec2 pixelCoordsBottomRight = 2 * pixelCoord + ivec2(1, 0);
    ivec2 pixelCoordsTopLeft     = 2 * pixelCoord + ivec2(0, 1);
    ivec2 pixelCoordsTopRight    = 2 * pixelCoord + ivec2(1, 1);

    QuadMapData quadMapDataBottomLeft  = loadInputQuadMap(pixelCoordsBottomLeft);
    QuadMapData quadMapDataBottomRight = loadInputQuadMap(pixelCoordsBottomRight);
    QuadMapData quadMapDataTopLeft     = loadInputQuadMap(pixelCoordsTopLeft);
    QuadMapData quadMapDataTopRight    = loadInputQuadMap(pixelCoordsTopRight);

    // create proxy planes
    Plane proxyPlaneBottomLeft  = quadMapDataToPlane(quadMapDataBottomLeft);
    Plane proxyPlaneBottomRight = quadMapDataToPlane(quadMapDataBottomRight);
    Plane proxyPlaneTopLeft     = quadMapDataToPlane(quadMapDataTopLeft);
    Plane proxyPlaneTopRight    = quadMapDataToPlane(quadMapDataTopRight);

    QuadMapData mergedQuadMapData;
    mergedQuadMapData.size = 0; // by default, ignore the quad
    if (shouldMerge(proxyPlaneBottomLeft, proxyPlaneBottomRight, proxyPlaneTopLeft, proxyPlaneTopRight)) {
        // merge the proxy planes
        mergeQuadMapData(
            mergedQuadMapData,
            proxyPlaneBottomLeft, proxyPlaneBottomRight, proxyPlaneTopLeft, proxyPlaneTopRight,
            quadMapDataBottomLeft, quadMapDataBottomRight, quadMapDataTopLeft, quadMapDataTopRight
        );

        // ignore the previous proxy planes that have been merged
        ignoreInputQuadMapData(pixelCoordsBottomLeft);
        ignoreInputQuadMapData(pixelCoordsBottomRight);
        ignoreInputQuadMapData(pixelCoordsTopLeft);
        ignoreInputQuadMapData(pixelCoordsTopRight);
    }

    storeInOutputQuadMap(pixelCoord, mergedQuadMapData);
}
