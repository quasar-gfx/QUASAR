layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

precision highp sampler2D;
precision highp image2D;
precision highp float;

layout(binding = 0) uniform sampler2D normalMap;
layout(binding = 1) uniform sampler2D depthMap;

struct Vertex {
    uint id;
    vec3 position;
    vec3 color;
    vec3 normal;
    vec2 texCoords;
    vec3 tangent;
    vec3 bitangent;
};

struct QuadMapData {
    vec3 normal;
    vec2 uv;
    float depth;
};

struct Plane {
    vec3 normal;
    float constant;
};

struct Quad {
    vec3 bottomLeft;
    vec3 bottomRight;
    vec3 topLeft;
    vec3 topRight;
};

struct Quad1D {
    float bottomLeft;
    float bottomRight;
    float topLeft;
    float topRight;
};

struct Quad2D {
    vec2 bottomLeft;
    vec2 bottomRight;
    vec2 topLeft;
    vec2 topRight;
};

// a Quad subdivided into 4 smaller Quads
struct MultiQuad {
    vec3 bottomLeft;
    vec3 bottom;
    vec3 bottomRight;
    vec3 left;
    vec3 center;
    vec3 right;
    vec3 topLeft;
    vec3 top;
    vec3 topRight;
};

struct MultiQuad1D {
    float bottomLeft;
    float bottom;
    float bottomRight;
    float left;
    float center;
    float right;
    float topLeft;
    float top;
    float topRight;
};

struct MultiQuad2D {
    vec2 bottomLeft;
    vec2 bottom;
    vec2 bottomRight;
    vec2 left;
    vec2 center;
    vec2 right;
    vec2 topLeft;
    vec2 top;
    vec2 topRight;
};

uniform vec2 remoteWinSize;
uniform vec2 quadMapSize;

uniform mat4 view;
uniform mat4 projection;
uniform mat4 viewInverse;
uniform mat4 projectionInverse;

uniform float near;
uniform float far;

uniform bool doAverageNormal;
uniform bool doOrientationCorrection;
uniform float distanceThreshold;
uniform float angleThreshold;

const float epilson = 1e-5;

const vec3 origin = vec3(0.0, 0.0, 0.0);
const vec3 forward = vec3(0.0, 0.0, -1.0);
const vec3 up = vec3(0.0, 1.0, 0.0);
const vec3 left = vec3(-1.0, 0.0, 0.0);
const vec3 right = vec3(1.0, 0.0, 0.0);

#define MAX_DEPTH 0.9999

#define VERTICES_IN_A_QUAD  4u
#define INDICES_IN_A_QUAD   6u
#define NUM_SUB_QUADS       4u

layout(std430, binding = 0) buffer QuadMapBuffer {
    QuadMapData quadMap[];
};

layout(std430, binding = 1) buffer VertexCounterBuffer {
    uint numVertices;
};

layout(std430, binding = 2) buffer IndexCounterBuffer {
    uint numIndices;
};

layout(std430, binding = 3) buffer VertexBuffer {
    Vertex vertices[];
};

layout(std430, binding = 4) buffer IndexBuffer {
    uint indices[];
};

layout(std430, binding = 5) buffer VertexBufferWireframe {
    Vertex verticesWireframe[];
};

layout(std430, binding = 6) buffer IndexBufferWireframe {
    uint indicesWireframe[];
};

layout(std430, binding = 7) buffer DepthOffsetBuffer {
    float depthOffsetBuffer[];
};

vec3 ndcToView(mat4 projectionInverse, vec2 ndc, float depth) {
    vec4 ndcPos;
    ndcPos.xy = ndc;
    ndcPos.z = depth * 2.0 - 1.0;
    ndcPos.w = 1.0;

    vec4 viewCoord = projectionInverse * ndcPos;
    viewCoord = viewCoord / viewCoord.w;
    return viewCoord.xyz;
}

vec3 viewToNDC(mat4 projection, vec3 viewCoord) {
    vec4 ndcCoord = projection * vec4(viewCoord, 1.0);
    ndcCoord = ndcCoord / ndcCoord.w;
    ndcCoord.z = (ndcCoord.z + 1.0) / 2.0;
    return ndcCoord.xyz;
}

vec3 viewToWorld(mat4 viewInverse, vec3 viewCoord) {
    vec4 worldCoord = viewInverse * vec4(viewCoord, 1.0);
    worldCoord = worldCoord / worldCoord.w;
    return worldCoord.xyz;
}

vec3 worldToView(mat4 view, vec3 worldCoord) {
    vec4 viewCoord = view * vec4(worldCoord, 1.0);
    viewCoord = viewCoord / viewCoord.w;
    return viewCoord.xyz;
}

vec2 ndcToScreen(vec2 ndc) {
    return (ndc + 1.0) / 2.0;
}

vec2 worldToScreen(mat4 view, mat4 projection, vec3 worldCoord) {
    vec2 ndc = viewToNDC(projection, worldToView(view, worldCoord)).xy;
    return ndcToScreen(ndc);
}

float signedDistance(vec3 p1, vec3 p2) {
    float dist = distance(p1, p2);
    return (length(p1) > length(p2)) ? dist : -dist;
}

float sampleDepth(sampler2D depthMap, vec2 sampleCoord) {
    float depth = texture(depthMap, sampleCoord).x;
    depth = clamp(depth, 0.0, MAX_DEPTH);
    return depth;
}

float NormalizeDepth(float depth) {
    depth = clamp(depth, near, far);
    float z = (depth - near) / (far - near);
    return (1.0 - (1.0 / (1.0 + z * (far - near) / near)));
}

vec3 sampleNormal(sampler2D normalMap, vec2 sampleCoord) {
    return normalize(texture(normalMap, sampleCoord).xyz);
}

vec3 normalToView(mat4 view, vec3 normalWorld) {
    // skybox normals might be NaN, just set normal to face the camera
    if (any(isnan(normalWorld))) {
        return -forward;
    }

    // extract the rotation part of the view matrix
    mat3 rotationMatrix = mat3(view);
    return normalize(rotationMatrix * normalWorld);
}

vec3 averageNormals(MultiQuad pixelNormalsView, MultiQuad pixelCoordsView) {
    vec3 normal = pixelNormalsView.center;
    int n = 1;
    if (NormalizeDepth(distance(pixelCoordsView.center, pixelCoordsView.bottomLeft)) < distanceThreshold) {
        normal += pixelNormalsView.bottomLeft; n++;
    }
    if (NormalizeDepth(distance(pixelCoordsView.center, pixelCoordsView.bottom)) < distanceThreshold) {
        normal += pixelNormalsView.bottom; n++;
    }
    if (NormalizeDepth(distance(pixelCoordsView.center, pixelCoordsView.bottomRight)) < distanceThreshold) {
        normal += pixelNormalsView.bottomRight; n++;
    }
    if (NormalizeDepth(distance(pixelCoordsView.center, pixelCoordsView.left)) < distanceThreshold) {
        normal += pixelNormalsView.left; n++;
    }
    if (NormalizeDepth(distance(pixelCoordsView.center, pixelCoordsView.right)) < distanceThreshold) {
        normal += pixelNormalsView.right; n++;
    }
    if (NormalizeDepth(distance(pixelCoordsView.center, pixelCoordsView.topLeft)) < distanceThreshold) {
        normal += pixelNormalsView.topLeft; n++;
    }
    if (NormalizeDepth(distance(pixelCoordsView.center, pixelCoordsView.top)) < distanceThreshold) {
        normal += pixelNormalsView.top; n++;
    }
    if (NormalizeDepth(distance(pixelCoordsView.center, pixelCoordsView.topRight)) < distanceThreshold) {
        normal += pixelNormalsView.topRight; n++;
    }
    normal /= float(n);
    normal = normalize(normal);
    return normal;
}

vec3 constrainToMaxAngle(vec3 vectorNormalized, vec3 axisNormalized, float maxAngle) {
    float dotProduct = dot(vectorNormalized, axisNormalized);
    float angle = acos(dotProduct);
    if (angle > maxAngle) {
        vec3 rotationAxis = normalize(cross(vectorNormalized, axisNormalized));
        float cosMaxAngle = cos(maxAngle);
        float sinMaxAngle = sin(maxAngle);
        vec3 crossProduct = cross(rotationAxis, vectorNormalized);
        vectorNormalized = vectorNormalized * cosMaxAngle + \
                           cross(rotationAxis, vectorNormalized) * sinMaxAngle + \
                           rotationAxis * dot(rotationAxis, vectorNormalized) * (1.0 - cosMaxAngle);
    }

    return normalize(vectorNormalized);
}

vec3 rayPlaneIntersection(vec3 rayOrigin, vec3 rayDirection, vec3 planePoint, vec3 planeNormal) {
    float denominator = dot(rayDirection, planeNormal);
    if (abs(denominator) < epilson) {
        return vec3(1.0/0.0, 1.0/0.0, 1.0/0.0);
    }

    float t = dot(planePoint - rayOrigin, planeNormal) / denominator;
    if (t < 0.0) {
        return vec3(1.0/0.0, 1.0/0.0, 1.0/0.0);
    }

    vec3 intersection = rayOrigin + t * rayDirection;
    return intersection;
}

vec3 pointPlaneIntersection(vec3 pt, vec3 planePoint, vec3 planeNormal) {
    vec3 rayDirection = normalize(pt);
    return rayPlaneIntersection(origin, rayDirection, planePoint, planeNormal);
}

vec3 findQuadPointCorner(
    vec2 surfelNDC,
    vec3 surfelViewPlane,
    vec3 surfelViewPlanePixelNeighbor1,
    vec3 surfelViewPlanePixelNeighbor2,
    vec3 surfelViewPlanePixelNeighbor3,
    float pixelDepthCenter, float pixelDepthNeighbor1, float pixelDepthNeighbor2, float pixelDepthNeighbor3)
{
    if (surfelNDC.x <= -1.0 || surfelNDC.x >= 1.0 ||
        surfelNDC.y <= -1.0 || surfelNDC.y >= 1.0) {
        return surfelViewPlane;
    }

    // find distance of depth of point on this pixel's plane to the same point on neighboring pixels' planes
    float dist1 = NormalizeDepth(distance(surfelViewPlane, surfelViewPlanePixelNeighbor1));
    float dist2 = NormalizeDepth(distance(surfelViewPlane, surfelViewPlanePixelNeighbor2));
    float dist3 = NormalizeDepth(distance(surfelViewPlane, surfelViewPlanePixelNeighbor3));

    // add the contribution of each neighboring pixel to interpolated depth, if it is within distanceThreshold
    float depth = pixelDepthCenter;
    int n = 1;
    if (dist1 < distanceThreshold) {
        depth += pixelDepthNeighbor1; n++;
    }
    if (dist2 < distanceThreshold) {
        depth += pixelDepthNeighbor2; n++;
    }
    if (dist3 < distanceThreshold) {
        depth += pixelDepthNeighbor3; n++;
    }
    depth /= float(n);

    // only return the interpolated point if all neighboring pixels are within distanceThreshold
    vec3 surfelViewBottomLeftInterp = ndcToView(projectionInverse, surfelNDC, depth);
    if (n >= 3) {
        return surfelViewBottomLeftInterp;
    }
    return surfelViewPlane;
}

vec3 findQuadPointEdge(
    vec2 surfelNDC,
    vec3 surfelViewPlane,
    vec3 surfelViewPlanePixelNeighbor,
    float pixelDepthCenter, float pixelDepthNeighbor)
{
    if (surfelNDC.x <= -1.0 || surfelNDC.x >= 1.0 ||
        surfelNDC.y <= -1.0 || surfelNDC.y >= 1.0) {
        return surfelViewPlane;
    }

    // return interpolated point if neighboring pixel's depth is within distanceThreshold
    if (NormalizeDepth(distance(surfelViewPlane, surfelViewPlanePixelNeighbor)) < distanceThreshold) {
        float depth = (pixelDepthCenter + pixelDepthNeighbor) / 2.0;
        return ndcToView(projectionInverse, surfelNDC, depth);
    }
    return surfelViewPlane;
}

float distanceAlongAxis(vec3 a, vec3 b, vec3 axis) {
    vec3 aProj = dot(a, axis) * axis;
    vec3 bProj = dot(b, axis) * axis;
    return distance(aProj, bProj);
}

bool quadHasExtremeOrientation(in MultiQuad quad, vec3 frustumNormalView) {
    float avgDist = 0.0;
    avgDist += distanceAlongAxis(quad.center, quad.bottomLeft, frustumNormalView);
    avgDist += distanceAlongAxis(quad.center, quad.bottom, frustumNormalView);
    avgDist += distanceAlongAxis(quad.center, quad.bottomRight, frustumNormalView);
    avgDist += distanceAlongAxis(quad.center, quad.left, frustumNormalView);
    avgDist += distanceAlongAxis(quad.center, quad.right, frustumNormalView);
    avgDist += distanceAlongAxis(quad.center, quad.topLeft, frustumNormalView);
    avgDist += distanceAlongAxis(quad.center, quad.top, frustumNormalView);
    avgDist += distanceAlongAxis(quad.center, quad.topRight, frustumNormalView);
    avgDist /= 8.0;
    if (NormalizeDepth(avgDist) > distanceThreshold) {
        return true;
    }
    return false;
}

void createSurfels(out MultiQuad surfelView, in MultiQuad2D surfelNDCs, in MultiQuad surfelViewFarPlane, in MultiQuad pixelCoordsView, in MultiQuad pixelNormalsView, in MultiQuad1D pixelDepths) {
    // find all points on a ray going through each coordinate intersecting a plane defined by neighboring pixels
    vec3 surfelViewBottomLeftPlane                = pointPlaneIntersection(surfelViewFarPlane.bottomLeft, pixelCoordsView.center,     pixelNormalsView.center    );
    vec3 surfelViewBottomLeftPlanePixelBottomLeft = pointPlaneIntersection(surfelViewFarPlane.bottomLeft, pixelCoordsView.bottomLeft, pixelNormalsView.bottomLeft);
    vec3 surfelViewBottomLeftPlanePixelBottom     = pointPlaneIntersection(surfelViewFarPlane.bottomLeft, pixelCoordsView.bottom,     pixelNormalsView.bottom    );
    vec3 surfelViewBottomLeftPlanePixelLeft       = pointPlaneIntersection(surfelViewFarPlane.bottomLeft, pixelCoordsView.left,       pixelNormalsView.left      );

    vec3 surfelViewBottomPlane            = pointPlaneIntersection(surfelViewFarPlane.bottom, pixelCoordsView.center, pixelNormalsView.center);
    vec3 surfelViewBottomPlanePixelBottom = pointPlaneIntersection(surfelViewFarPlane.bottom, pixelCoordsView.bottom, pixelNormalsView.bottom);

    vec3 surfelViewBottomRightPlane                 = pointPlaneIntersection(surfelViewFarPlane.bottomRight, pixelCoordsView.center,      pixelNormalsView.center     );
    vec3 surfelViewBottomRightPlanePixelBottomRight = pointPlaneIntersection(surfelViewFarPlane.bottomRight, pixelCoordsView.bottomRight, pixelNormalsView.bottomRight);
    vec3 surfelViewBottomRightPlanePixelBottom      = pointPlaneIntersection(surfelViewFarPlane.bottomRight, pixelCoordsView.bottom,      pixelNormalsView.bottom     );
    vec3 surfelViewBottomRightPlanePixelRight       = pointPlaneIntersection(surfelViewFarPlane.bottomRight, pixelCoordsView.right,       pixelNormalsView.right      );

    vec3 surfelViewLeftPlane          = pointPlaneIntersection(surfelViewFarPlane.left, pixelCoordsView.center, pixelNormalsView.center);
    vec3 surfelViewLeftPlanePixelLeft = pointPlaneIntersection(surfelViewFarPlane.left, pixelCoordsView.left,   pixelNormalsView.left  );

    vec3 surfelViewRightPlane           = pointPlaneIntersection(surfelViewFarPlane.right, pixelCoordsView.center, pixelNormalsView.center);
    vec3 surfelViewRightPlanePixelRight = pointPlaneIntersection(surfelViewFarPlane.right, pixelCoordsView.right,  pixelNormalsView.right );

    vec3 surfelViewTopLeftPlane             = pointPlaneIntersection(surfelViewFarPlane.topLeft, pixelCoordsView.center,  pixelNormalsView.center );
    vec3 surfelViewTopLeftPlanePixelTopLeft = pointPlaneIntersection(surfelViewFarPlane.topLeft, pixelCoordsView.topLeft, pixelNormalsView.topLeft);
    vec3 surfelViewTopLeftPlanePixelLeft    = pointPlaneIntersection(surfelViewFarPlane.topLeft, pixelCoordsView.left,    pixelNormalsView.left   );
    vec3 surfelViewTopLeftPlanePixelTop     = pointPlaneIntersection(surfelViewFarPlane.topLeft, pixelCoordsView.top,     pixelNormalsView.top    );

    vec3 surfelViewTopPlane         = pointPlaneIntersection(surfelViewFarPlane.top, pixelCoordsView.center, pixelNormalsView.center);
    vec3 surfelViewTopPlanePixelTop = pointPlaneIntersection(surfelViewFarPlane.top, pixelCoordsView.top,    pixelNormalsView.top   );

    vec3 surfelViewTopRightPlane              = pointPlaneIntersection(surfelViewFarPlane.topRight, pixelCoordsView.center,   pixelNormalsView.center  );
    vec3 surfelViewTopRightPlanePixelTopRight = pointPlaneIntersection(surfelViewFarPlane.topRight, pixelCoordsView.topRight, pixelNormalsView.topRight);
    vec3 surfelViewTopRightPlanePixelTop      = pointPlaneIntersection(surfelViewFarPlane.topRight, pixelCoordsView.top,      pixelNormalsView.top     );
    vec3 surfelViewTopRightPlanePixelRight    = pointPlaneIntersection(surfelViewFarPlane.topRight, pixelCoordsView.right,    pixelNormalsView.right   );

    /**********************************

      (ptl)  ----   (pt) ----  (ptr)
        |            |           |
        |  - stl -  st  -  str - |
        |            |           |
     (pl)  - sl - (pc/sc) - sr - (pr)
        |            |           |
        |  - sbl -  sb  -  sbr - |
        |            |           |
      (pbl)  ----   (pb) ----  (pbr)

    **********************************/

    // adjust points
    vec3 surfelViewBottomLeft = findQuadPointCorner(
        surfelNDCs.bottomLeft,
        surfelViewBottomLeftPlane,
        surfelViewBottomLeftPlanePixelBottomLeft, surfelViewBottomLeftPlanePixelBottom, surfelViewBottomLeftPlanePixelLeft,
        pixelDepths.center, pixelDepths.bottomLeft, pixelDepths.bottom, pixelDepths.left
    );

    vec3 surfelViewBottom = findQuadPointEdge(
        surfelNDCs.bottom,
        surfelViewBottomPlane,
        surfelViewBottomPlanePixelBottom,
        pixelDepths.center, pixelDepths.bottom
    );

    vec3 surfelViewBottomRight = findQuadPointCorner(
        surfelNDCs.bottomRight,
        surfelViewBottomRightPlane,
        surfelViewBottomRightPlanePixelBottomRight, surfelViewBottomRightPlanePixelBottom, surfelViewBottomRightPlanePixelRight,
        pixelDepths.center, pixelDepths.bottomRight, pixelDepths.bottom, pixelDepths.right
    );

    vec3 surfelViewLeft = findQuadPointEdge(
        surfelNDCs.left,
        surfelViewLeftPlane,
        surfelViewLeftPlanePixelLeft,
        pixelDepths.center, pixelDepths.left
    );

    vec3 surfelViewCenter = pixelCoordsView.center;

    vec3 surfelViewRight = findQuadPointEdge(
        surfelNDCs.right,
        surfelViewRightPlane,
        surfelViewRightPlanePixelRight,
        pixelDepths.center, pixelDepths.right
    );

    vec3 surfelViewTopLeft = findQuadPointCorner(
        surfelNDCs.topLeft,
        surfelViewTopLeftPlane,
        surfelViewTopLeftPlanePixelTopLeft, surfelViewTopLeftPlanePixelTop, surfelViewTopLeftPlanePixelLeft,
        pixelDepths.center, pixelDepths.topLeft, pixelDepths.top, pixelDepths.left
    );

    vec3 surfelViewTop = findQuadPointEdge(
        surfelNDCs.top,
        surfelViewTopPlane,
        surfelViewTopPlanePixelTop,
        pixelDepths.center, pixelDepths.top
    );

    vec3 surfelViewTopRight = findQuadPointCorner(
        surfelNDCs.topRight,
        surfelViewTopRightPlane,
        surfelViewTopRightPlanePixelTopRight, surfelViewTopRightPlanePixelTop, surfelViewTopRightPlanePixelRight,
        pixelDepths.center, pixelDepths.topRight, pixelDepths.top, pixelDepths.right
    );

    surfelView.bottomLeft  = surfelViewBottomLeft;
    surfelView.bottom      = surfelViewBottom;
    surfelView.bottomRight = surfelViewBottomRight;
    surfelView.left        = surfelViewLeft;
    surfelView.center      = surfelViewCenter;
    surfelView.right       = surfelViewRight;
    surfelView.topLeft     = surfelViewTopLeft;
    surfelView.top         = surfelViewTop;
    surfelView.topRight    = surfelViewTopRight;
}

void storeInQuadMap(in ivec2 pixelCoord, in QuadMapData quadMapData) {
    uint index = uint(pixelCoord.y) * uint(quadMapSize.x) + uint(pixelCoord.x);
    quadMap[index] = quadMapData;
}

QuadMapData sampleQuadMap(ivec2 pixelCoord) {
    uint index = uint(pixelCoord.y) * uint(quadMapSize.x) + uint(pixelCoord.x);
    QuadMapData quadMapData = quadMap[index];
    return quadMapData;
}

float sampleDepthOffset(in ivec2 pixelCoord) {
    uint index = uint(pixelCoord.y) * 2u * uint(quadMapSize.x) + uint(pixelCoord.x);
    return depthOffsetBuffer[index];
}

void storeInDepthOffsetBuffer(in ivec2 pixelCoord, in float data) {
    uint index = uint(pixelCoord.y) * 2u * uint(quadMapSize.x) + uint(pixelCoord.x);
    depthOffsetBuffer[index] = data;
}

void storeDepthOffsets(in ivec2 pixelCoord, in Quad1D depthOffsets) {
    storeInDepthOffsetBuffer(pixelCoord + ivec2(0, 0), depthOffsets.bottomLeft);
    storeInDepthOffsetBuffer(pixelCoord + ivec2(1, 0), depthOffsets.bottomRight);
    storeInDepthOffsetBuffer(pixelCoord + ivec2(0, 1), depthOffsets.topLeft);
    storeInDepthOffsetBuffer(pixelCoord + ivec2(1, 1), depthOffsets.topRight);
}

void storeQuadInQuadMap(in ivec2 pixelCoord, in MultiQuad pixelNormalsView, in Quad quadView, out Quad1D depthOffets) {
    vec3 proxyPlaneNormal = pixelNormalsView.center;
    vec3 proxyPlanePt = (quadView.bottomLeft + quadView.bottomRight + quadView.topLeft + quadView.topRight) / 4.0;

    Quad quadPtsOnPlane;
    quadPtsOnPlane.bottomLeft  = pointPlaneIntersection(quadView.bottomLeft, proxyPlanePt, proxyPlaneNormal);
    quadPtsOnPlane.bottomRight = pointPlaneIntersection(quadView.bottomRight, proxyPlanePt, proxyPlaneNormal);
    quadPtsOnPlane.topLeft     = pointPlaneIntersection(quadView.topLeft, proxyPlanePt, proxyPlaneNormal);
    quadPtsOnPlane.topRight    = pointPlaneIntersection(quadView.topRight, proxyPlanePt, proxyPlaneNormal);

    depthOffets.bottomLeft  = signedDistance(quadPtsOnPlane.bottomLeft,  quadView.bottomLeft);
    depthOffets.bottomRight = signedDistance(quadPtsOnPlane.bottomRight, quadView.bottomRight);
    depthOffets.topLeft     = signedDistance(quadPtsOnPlane.topLeft,     quadView.topLeft);
    depthOffets.topRight    = signedDistance(quadPtsOnPlane.topRight,    quadView.topRight);

    // find uv for bottom left corner of quad
    vec3 quadNDCBottomLeft = viewToNDC(projection, quadView.bottomLeft);
    vec2 quadUVBottomLeft = (quadNDCBottomLeft.xy + 1.0) / 2.0;
    vec2 quadPixelCoordBottomLeft = quadUVBottomLeft * remoteWinSize;

    // find 3d point of center of quad
    vec2 quadCenterPixelCoord = (quadPixelCoordBottomLeft + vec2(0.25, 0.25));
    vec2 quadCenterUV = quadCenterPixelCoord / remoteWinSize;
    vec2 quadCenterNDC = quadCenterUV * 2.0 - 1.0;
    vec3 quadCenterFarPlane = ndcToView(projectionInverse, quadCenterNDC, 1.0);

    // project the center of the quad onto the proxy plane to find uv for proxy plane
    vec3 planeCenterPt = pointPlaneIntersection(quadCenterFarPlane, proxyPlanePt, proxyPlaneNormal);
    vec3 proxyPlaneNDC = viewToNDC(projection, planeCenterPt);
    vec2 proxyPlaneUV = (proxyPlaneNDC.xy + 1.0) / 2.0;

    float proxyPlaneDepth = proxyPlaneNDC.z;

    QuadMapData quadMapData;
    quadMapData.uv = proxyPlaneUV;
    quadMapData.depth = proxyPlaneNDC.z;
    quadMapData.normal = proxyPlaneNormal;
    storeInQuadMap(pixelCoord, quadMapData);
}

void loadDepthOffsets(out Quad1D depthOffsets, in ivec2 pixelCoord) {
    depthOffsets.bottomLeft  = sampleDepthOffset(pixelCoord + ivec2(0, 0)).r;
    depthOffsets.bottomRight = sampleDepthOffset(pixelCoord + ivec2(1, 0)).r;
    depthOffsets.topLeft     = sampleDepthOffset(pixelCoord + ivec2(0, 1)).r;
    depthOffsets.topRight    = sampleDepthOffset(pixelCoord + ivec2(1, 1)).r;
}

void loadFromQuadMap(out Quad surfel, in ivec2 pixelCoord, in Quad1D depthOffets) {
    // extract the plane normal and point from the quad map
    QuadMapData quadMapData = sampleQuadMap(pixelCoord);
    vec2 proxyPlaneUV = quadMapData.uv;
    float proxyPlaneDepth = quadMapData.depth;
    vec3 proxyPlaneNormal = quadMapData.normal;

    vec2 proxyPlaneNDC = proxyPlaneUV * 2.0 - 1.0;
    vec3 proxyPlanePt = ndcToView(projectionInverse, proxyPlaneNDC, proxyPlaneDepth);

    vec2 proxyPlanePixelCoords = proxyPlaneUV * remoteWinSize;

    // find the pixel coordinates of the surfel corners
    Quad2D surfelPixelCoords;
    surfelPixelCoords.bottomLeft  = proxyPlanePixelCoords + vec2(-0.25, -0.25);
    surfelPixelCoords.bottomRight = proxyPlanePixelCoords + vec2(+0.25, -0.25);
    surfelPixelCoords.topLeft     = proxyPlanePixelCoords + vec2(-0.25, +0.25);
    surfelPixelCoords.topRight    = proxyPlanePixelCoords + vec2(+0.25, +0.25);

    Quad2D surfelUVs;
    surfelUVs.bottomLeft  = surfelPixelCoords.bottomLeft / remoteWinSize;
    surfelUVs.bottomRight = surfelPixelCoords.bottomRight / remoteWinSize;
    surfelUVs.topLeft     = surfelPixelCoords.topLeft / remoteWinSize;
    surfelUVs.topRight    = surfelPixelCoords.topRight / remoteWinSize;

    Quad2D surfelNDCs;
    surfelNDCs.bottomLeft  = surfelUVs.bottomLeft * 2.0 - 1.0;
    surfelNDCs.bottomRight = surfelUVs.bottomRight * 2.0 - 1.0;
    surfelNDCs.topLeft     = surfelUVs.topLeft * 2.0 - 1.0;
    surfelNDCs.topRight    = surfelUVs.topRight * 2.0 - 1.0;

    Quad surfelFarPlane;
    surfelFarPlane.bottomLeft  = ndcToView(projectionInverse, surfelNDCs.bottomLeft, 1.0);
    surfelFarPlane.bottomRight = ndcToView(projectionInverse, surfelNDCs.bottomRight, 1.0);
    surfelFarPlane.topLeft     = ndcToView(projectionInverse, surfelNDCs.topLeft, 1.0);
    surfelFarPlane.topRight    = ndcToView(projectionInverse, surfelNDCs.topRight, 1.0);

    // shoot rays from corners of the surfel to the plane to find the 3D intersection points
    Quad quadPtsOnPlane;
    quadPtsOnPlane.bottomLeft  = pointPlaneIntersection(surfelFarPlane.bottomLeft,  proxyPlanePt, proxyPlaneNormal);
    quadPtsOnPlane.bottomRight = pointPlaneIntersection(surfelFarPlane.bottomRight, proxyPlanePt, proxyPlaneNormal);
    quadPtsOnPlane.topLeft     = pointPlaneIntersection(surfelFarPlane.topLeft,     proxyPlanePt, proxyPlaneNormal);
    quadPtsOnPlane.topRight    = pointPlaneIntersection(surfelFarPlane.topRight,    proxyPlanePt, proxyPlaneNormal);

    // apply depth offsets to the quad points
    surfel.bottomLeft  = quadPtsOnPlane.bottomLeft  - depthOffets.bottomLeft  * normalize(quadPtsOnPlane.bottomLeft);
    surfel.bottomRight = quadPtsOnPlane.bottomRight - depthOffets.bottomRight * normalize(quadPtsOnPlane.bottomRight);
    surfel.topLeft     = quadPtsOnPlane.topLeft     - depthOffets.topLeft     * normalize(quadPtsOnPlane.topLeft);
    surfel.topRight    = quadPtsOnPlane.topRight    - depthOffets.topRight    * normalize(quadPtsOnPlane.topRight);
}

void storeQuad(Quad quad) {
    /************************

            tl -- tr
            |   / |
            | /   |
            bl -- br

    ************************/

    uint vertexIdxBase = atomicAdd(numVertices, VERTICES_IN_A_QUAD);

    uint vertexIndexTopLeft = vertexIdxBase + 0u;
    vertices[vertexIndexTopLeft].position = viewToWorld(viewInverse, quad.topLeft);
    vertices[vertexIndexTopLeft].color = vec3(1.0, 1.0, 1.0);
    vertices[vertexIndexTopLeft].texCoords = worldToScreen(view, projection, vertices[vertexIndexTopLeft].position);

    uint vertexIndexTopRight = vertexIdxBase + 1u;
    vertices[vertexIndexTopRight].position = viewToWorld(viewInverse, quad.topRight);
    vertices[vertexIndexTopRight].color = vec3(1.0, 1.0, 1.0);
    vertices[vertexIndexTopRight].texCoords = worldToScreen(view, projection, vertices[vertexIndexTopRight].position);

    uint vertexIndexBottomLeft = vertexIdxBase + 2u;
    vertices[vertexIndexBottomLeft].position = viewToWorld(viewInverse, quad.bottomLeft);
    vertices[vertexIndexBottomLeft].color = vec3(1.0, 1.0, 1.0);
    vertices[vertexIndexBottomLeft].texCoords = worldToScreen(view, projection, vertices[vertexIndexBottomLeft].position);

    uint vertexIndexBottomRight = vertexIdxBase + 3u;
    vertices[vertexIndexBottomRight].position = viewToWorld(viewInverse, quad.bottomRight);
    vertices[vertexIndexBottomRight].color = vec3(1.0, 1.0, 1.0);
    vertices[vertexIndexBottomRight].texCoords = worldToScreen(view, projection, vertices[vertexIndexBottomRight].position);

    verticesWireframe[vertexIndexTopLeft] = vertices[vertexIndexTopLeft];
    verticesWireframe[vertexIndexTopRight] = vertices[vertexIndexTopRight];
    verticesWireframe[vertexIndexBottomLeft] = vertices[vertexIndexBottomLeft];
    verticesWireframe[vertexIndexBottomRight] = vertices[vertexIndexBottomRight];

    uint indexIdxBase = atomicAdd(numIndices, INDICES_IN_A_QUAD);

    indices[indexIdxBase + 0u] = vertexIndexTopLeft;
    indices[indexIdxBase + 1u] = vertexIndexBottomLeft;
    indices[indexIdxBase + 2u] = vertexIndexTopRight;

    indices[indexIdxBase + 3u] = vertexIndexTopRight;
    indices[indexIdxBase + 4u] = vertexIndexBottomLeft;
    indices[indexIdxBase + 5u] = vertexIndexBottomRight;

    indicesWireframe[indexIdxBase + 0u] = indices[indexIdxBase + 0u];
    indicesWireframe[indexIdxBase + 1u] = indices[indexIdxBase + 1u];
    indicesWireframe[indexIdxBase + 2u] = indices[indexIdxBase + 2u];
    indicesWireframe[indexIdxBase + 3u] = indices[indexIdxBase + 3u];
    indicesWireframe[indexIdxBase + 4u] = indices[indexIdxBase + 4u];
    indicesWireframe[indexIdxBase + 5u] = indices[indexIdxBase + 5u];
}

void main() {
    /**********************************

      (ptl)  ----   (pt) ----  (ptr)
        |            |           |
        |  - stl -  st  -  str - |
        |            |           |
     (pl)  - sl - (pc/sc) - sr - (pr)
        |            |           |
        |  - sbl -  sb  -  sbr - |
        |            |           |
      (pbl)  ----   (pb) ----  (pbr)

    **********************************/

    // get coords (see above)
    vec2 surfelCornerCoordBottomLeft  = vec2(gl_GlobalInvocationID.xy);

    MultiQuad2D pixelCenterCoords;
    pixelCenterCoords.bottomLeft  = surfelCornerCoordBottomLeft + vec2(0.5, 0.5) + vec2(-1.0, -1.0);
    pixelCenterCoords.bottom      = surfelCornerCoordBottomLeft + vec2(0.5, 0.5) + vec2(+0.0, -1.0);
    pixelCenterCoords.bottomRight = surfelCornerCoordBottomLeft + vec2(0.5, 0.5) + vec2(+1.0, -1.0);
    pixelCenterCoords.left        = surfelCornerCoordBottomLeft + vec2(0.5, 0.5) + vec2(-1.0, +0.0);
    pixelCenterCoords.center      = surfelCornerCoordBottomLeft + vec2(0.5, 0.5) + vec2(+0.0, +0.0);
    pixelCenterCoords.right       = surfelCornerCoordBottomLeft + vec2(0.5, 0.5) + vec2(+1.0, +0.0);
    pixelCenterCoords.topLeft     = surfelCornerCoordBottomLeft + vec2(0.5, 0.5) + vec2(-1.0, +1.0);
    pixelCenterCoords.top         = surfelCornerCoordBottomLeft + vec2(0.5, 0.5) + vec2(+0.0, +1.0);
    pixelCenterCoords.topRight    = surfelCornerCoordBottomLeft + vec2(0.5, 0.5) + vec2(+1.0, +1.0);

    MultiQuad2D surfelCoords;
    surfelCoords.bottomLeft  = surfelCornerCoordBottomLeft + vec2(0.0, 0.0) + vec2(0.0, 0.0);
    surfelCoords.bottom      = surfelCornerCoordBottomLeft + vec2(0.0, 0.0) + vec2(0.5, 0.0);
    surfelCoords.bottomRight = surfelCornerCoordBottomLeft + vec2(0.0, 0.0) + vec2(1.0, 0.0);
    surfelCoords.left        = surfelCornerCoordBottomLeft + vec2(0.0, 0.0) + vec2(0.0, 0.5);
    surfelCoords.center      = pixelCenterCoords.center;
    surfelCoords.right       = surfelCornerCoordBottomLeft + vec2(0.0, 0.0) + vec2(1.0, 0.5);
    surfelCoords.topLeft     = surfelCornerCoordBottomLeft + vec2(0.0, 0.0) + vec2(0.0, 1.0);
    surfelCoords.top         = surfelCornerCoordBottomLeft + vec2(0.0, 0.0) + vec2(0.5, 1.0);
    surfelCoords.topRight    = surfelCornerCoordBottomLeft + vec2(0.0, 0.0) + vec2(1.0, 1.0);

    // sample texture maps
    MultiQuad2D uvs;
    uvs.bottomLeft  = pixelCenterCoords.bottomLeft  / remoteWinSize;
    uvs.bottom      = pixelCenterCoords.bottom      / remoteWinSize;
    uvs.bottomRight = pixelCenterCoords.bottomRight / remoteWinSize;
    uvs.left        = pixelCenterCoords.left        / remoteWinSize;
    uvs.center      = pixelCenterCoords.center      / remoteWinSize;
    uvs.right       = pixelCenterCoords.right       / remoteWinSize;
    uvs.topLeft     = pixelCenterCoords.topLeft     / remoteWinSize;
    uvs.top         = pixelCenterCoords.top         / remoteWinSize;
    uvs.topRight    = pixelCenterCoords.topRight    / remoteWinSize;

    MultiQuad1D pixelDepths;
    pixelDepths.bottomLeft  = sampleDepth(depthMap, uvs.bottomLeft);
    pixelDepths.bottom      = sampleDepth(depthMap, uvs.bottom);
    pixelDepths.bottomRight = sampleDepth(depthMap, uvs.bottomRight);
    pixelDepths.left        = sampleDepth(depthMap, uvs.left);
    pixelDepths.center      = sampleDepth(depthMap, uvs.center);
    pixelDepths.right       = sampleDepth(depthMap, uvs.right);
    pixelDepths.topLeft     = sampleDepth(depthMap, uvs.topLeft);
    pixelDepths.top         = sampleDepth(depthMap, uvs.top);
    pixelDepths.topRight    = sampleDepth(depthMap, uvs.topRight);

    // project 2D points to 3D view space
    MultiQuad2D pixelCenterNDCs;
    pixelCenterNDCs.bottomLeft  = (pixelCenterCoords.bottomLeft / remoteWinSize) * 2.0 - 1.0;
    pixelCenterNDCs.bottom      = (pixelCenterCoords.bottom / remoteWinSize) * 2.0 - 1.0;
    pixelCenterNDCs.bottomRight = (pixelCenterCoords.bottomRight / remoteWinSize) * 2.0 - 1.0;
    pixelCenterNDCs.left        = (pixelCenterCoords.left / remoteWinSize) * 2.0 - 1.0;
    pixelCenterNDCs.center      = (pixelCenterCoords.center / remoteWinSize) * 2.0 - 1.0;
    pixelCenterNDCs.right       = (pixelCenterCoords.right / remoteWinSize) * 2.0 - 1.0;
    pixelCenterNDCs.topLeft     = (pixelCenterCoords.topLeft / remoteWinSize) * 2.0 - 1.0;
    pixelCenterNDCs.top         = (pixelCenterCoords.top / remoteWinSize) * 2.0 - 1.0;
    pixelCenterNDCs.topRight    = (pixelCenterCoords.topRight / remoteWinSize) * 2.0 - 1.0;

    MultiQuad2D surfelNDCs;
    surfelNDCs.bottomLeft  = (surfelCoords.bottomLeft / remoteWinSize) * 2.0 - 1.0;
    surfelNDCs.bottom      = (surfelCoords.bottom / remoteWinSize) * 2.0 - 1.0;
    surfelNDCs.bottomRight = (surfelCoords.bottomRight / remoteWinSize) * 2.0 - 1.0;
    surfelNDCs.left        = (surfelCoords.left / remoteWinSize) * 2.0 - 1.0;
    surfelNDCs.center      = (surfelCoords.center / remoteWinSize) * 2.0 - 1.0;
    surfelNDCs.right       = (surfelCoords.right / remoteWinSize) * 2.0 - 1.0;
    surfelNDCs.topLeft     = (surfelCoords.topLeft / remoteWinSize) * 2.0 - 1.0;
    surfelNDCs.top         = (surfelCoords.top / remoteWinSize) * 2.0 - 1.0;
    surfelNDCs.topRight    = (surfelCoords.topRight / remoteWinSize) * 2.0 - 1.0;

    MultiQuad pixelCoordsView;
    pixelCoordsView.bottomLeft  = ndcToView(projectionInverse, pixelCenterNDCs.bottomLeft, pixelDepths.bottomLeft);
    pixelCoordsView.bottom      = ndcToView(projectionInverse, pixelCenterNDCs.bottom, pixelDepths.bottom);
    pixelCoordsView.bottomRight = ndcToView(projectionInverse, pixelCenterNDCs.bottomRight, pixelDepths.bottomRight);
    pixelCoordsView.left        = ndcToView(projectionInverse, pixelCenterNDCs.left, pixelDepths.left);
    pixelCoordsView.center      = ndcToView(projectionInverse, pixelCenterNDCs.center, pixelDepths.center);
    pixelCoordsView.right       = ndcToView(projectionInverse, pixelCenterNDCs.right, pixelDepths.right);
    pixelCoordsView.topLeft     = ndcToView(projectionInverse, pixelCenterNDCs.topLeft, pixelDepths.topLeft);
    pixelCoordsView.top         = ndcToView(projectionInverse, pixelCenterNDCs.top, pixelDepths.top);
    pixelCoordsView.topRight    = ndcToView(projectionInverse, pixelCenterNDCs.topRight, pixelDepths.topRight);

    // transform normals to view space
    MultiQuad pixelNormalsView;
    pixelNormalsView.bottomLeft  = normalToView(view, sampleNormal(normalMap, uvs.bottomLeft));
    pixelNormalsView.bottom      = normalToView(view, sampleNormal(normalMap, uvs.bottom));
    pixelNormalsView.bottomRight = normalToView(view, sampleNormal(normalMap, uvs.bottomRight));
    pixelNormalsView.left        = normalToView(view, sampleNormal(normalMap, uvs.left));
    pixelNormalsView.center      = normalToView(view, sampleNormal(normalMap, uvs.center));
    pixelNormalsView.right       = normalToView(view, sampleNormal(normalMap, uvs.right));
    pixelNormalsView.topLeft     = normalToView(view, sampleNormal(normalMap, uvs.topLeft));
    pixelNormalsView.top         = normalToView(view, sampleNormal(normalMap, uvs.top));
    pixelNormalsView.topRight    = normalToView(view, sampleNormal(normalMap, uvs.topRight));

    if (doAverageNormal) {
        pixelNormalsView.center = averageNormals(pixelNormalsView, pixelCoordsView);
    }

    // project all points to far plane
    MultiQuad surfelViewFarPlane;
    surfelViewFarPlane.bottomLeft  = ndcToView(projectionInverse, surfelNDCs.bottomLeft, 1.0);
    surfelViewFarPlane.bottom      = ndcToView(projectionInverse, surfelNDCs.bottom, 1.0);
    surfelViewFarPlane.bottomRight = ndcToView(projectionInverse, surfelNDCs.bottomRight, 1.0);
    surfelViewFarPlane.left        = ndcToView(projectionInverse, surfelNDCs.left, 1.0);
    surfelViewFarPlane.center      = ndcToView(projectionInverse, surfelNDCs.center, 1.0);
    surfelViewFarPlane.right       = ndcToView(projectionInverse, surfelNDCs.right, 1.0);
    surfelViewFarPlane.topLeft     = ndcToView(projectionInverse, surfelNDCs.topLeft, 1.0);
    surfelViewFarPlane.top         = ndcToView(projectionInverse, surfelNDCs.top, 1.0);
    surfelViewFarPlane.topRight    = ndcToView(projectionInverse, surfelNDCs.topRight, 1.0);

    MultiQuad surfelView;

    // create surfels
    createSurfels(surfelView, surfelNDCs, surfelViewFarPlane, pixelCoordsView, pixelNormalsView, pixelDepths);

    vec3 frustumNormalView = normalize(origin - surfelView.center);
    if (doOrientationCorrection && quadHasExtremeOrientation(surfelView, frustumNormalView)) {
        // recreate surfels with rotated normal
        pixelNormalsView.center = constrainToMaxAngle(pixelNormalsView.center, frustumNormalView, angleThreshold);
        createSurfels(surfelView, surfelNDCs, surfelViewFarPlane, pixelCoordsView, pixelNormalsView, pixelDepths);
    }

    /**********************

        stl -  st - str
        |      |     |
       (sl) - (sc) - sr
        |      |     |
      (sbl) - (sb) - sbr

    **********************/
    Quad subQuadBottomLeft;
    subQuadBottomLeft.topLeft = surfelView.left;
    subQuadBottomLeft.topRight = surfelView.center;
    subQuadBottomLeft.bottomLeft = surfelView.bottomLeft;
    subQuadBottomLeft.bottomRight = surfelView.bottom;

    /**********************

        stl -  st - str
        |      |     |
        sl - (sc) - (sr)
        |      |     |
       sbl - (sb) - (sbr)

    **********************/
    Quad subQuadBottomRight;
    subQuadBottomRight.topLeft = surfelView.center;
    subQuadBottomRight.topRight = surfelView.right;
    subQuadBottomRight.bottomLeft = surfelView.bottom;
    subQuadBottomRight.bottomRight = surfelView.bottomRight;

    /**********************

     (stl) - (st) - str
        |     |     |
      (sl) - (sc) - sr
        |     |     |
       sbl - sb - sbr

    **********************/
    Quad subQuadTopLeft;
    subQuadTopLeft.topLeft = surfelView.topLeft;
    subQuadTopLeft.topRight = surfelView.top;
    subQuadTopLeft.bottomLeft = surfelView.left;
    subQuadTopLeft.bottomRight = surfelView.center;

    /**********************

       stl - (st) - (str)
        |     |       |
        sl - (sc) - (sr)
        |     |       |
       sbl -  sb  -  sbr

    **********************/
    Quad subQuadTopRight;
    subQuadTopRight.topLeft = surfelView.top;
    subQuadTopRight.topRight = surfelView.topRight;
    subQuadTopRight.bottomLeft = surfelView.center;
    subQuadTopRight.bottomRight = surfelView.right;

    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);

    Quad1D depthOffsets1, depthOffsets2, depthOffsets3, depthOffsets4;

    // save quads in quad map
    storeQuadInQuadMap(2 * pixelCoord + ivec2(0, 0), pixelNormalsView, subQuadBottomLeft, depthOffsets1);
    storeQuadInQuadMap(2 * pixelCoord + ivec2(1, 0), pixelNormalsView, subQuadBottomRight, depthOffsets2);
    storeQuadInQuadMap(2 * pixelCoord + ivec2(0, 1), pixelNormalsView, subQuadTopLeft, depthOffsets3);
    storeQuadInQuadMap(2 * pixelCoord + ivec2(1, 1), pixelNormalsView, subQuadTopRight, depthOffsets4);

    storeDepthOffsets(4 * pixelCoord + 2 * ivec2(0, 0), depthOffsets1);
    storeDepthOffsets(4 * pixelCoord + 2 * ivec2(1, 0), depthOffsets2);
    storeDepthOffsets(4 * pixelCoord + 2 * ivec2(0, 1), depthOffsets3);
    storeDepthOffsets(4 * pixelCoord + 2 * ivec2(1, 1), depthOffsets4);

    // Quad1D depthOffsets1_, depthOffsets2_, depthOffsets3_, depthOffsets4_;
    // // loadDepthOffsets(depthOffsets1, 4 * pixelCoord + 2 * ivec2(0, 0));
    // // loadDepthOffsets(depthOffsets2, 4 * pixelCoord + 2 * ivec2(1, 0));
    // // loadDepthOffsets(depthOffsets3, 4 * pixelCoord + 2 * ivec2(0, 1));
    // // loadDepthOffsets(depthOffsets4, 4 * pixelCoord + 2 * ivec2(1, 1));

    // Quad q1, q2, q3, q4;
    // loadFromQuadMap(q1, 2 * pixelCoord + ivec2(0, 0), depthOffsets1_);
    // loadFromQuadMap(q2, 2 * pixelCoord + ivec2(1, 0), depthOffsets2_);
    // loadFromQuadMap(q3, 2 * pixelCoord + ivec2(0, 1), depthOffsets3_);
    // loadFromQuadMap(q4, 2 * pixelCoord + ivec2(1, 1), depthOffsets4_);

    // storeQuad(q1);
    // storeQuad(q2);
    // storeQuad(q3);
    // storeQuad(q4);
}
