layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(binding = 0) uniform sampler2D positionMap;
layout(binding = 1) uniform sampler2D normalMap;
layout(binding = 2) uniform sampler2D idMap;
layout(binding = 3) uniform sampler2D depthMap;

struct Vertex {
    uint id;
    vec3 position;
    vec3 color;
    vec3 normal;
    vec2 texCoords;
    vec3 tangent;
    vec3 bitangent;
};

layout(std430, binding = 0) buffer VertexBuffer {
    Vertex vertices[];
};

layout(std430, binding = 1) buffer IndexBuffer {
    uint indices[];
};

uniform vec2 screenSize;

uniform mat4 view;
uniform mat4 projection;
uniform mat4 viewInverse;
uniform mat4 projectionInverse;

uniform float near;
uniform float far;

uniform int surfelSize;

#define VERTICES_IN_A_QUAD 4
#define NUM_SUB_QUADS 4

vec3 ndcToView(vec2 ndc, float depth) {
    vec4 ndcPos;
    ndcPos.xy = ndc;
    ndcPos.z = 2.0 * depth - 1.0;
    ndcPos.w = 1.0;

    vec4 viewCoord = projectionInverse * ndcPos;
    viewCoord = viewCoord / viewCoord.w;
    return viewCoord.xyz;
}

vec3 viewToWorld(vec3 viewspaceCoord) {
    vec4 worldCoord = viewInverse * vec4(viewspaceCoord, 1.0);
    worldCoord = worldCoord / worldCoord.w;
    return worldCoord.xyz;
}

vec3 worldToView(mat4 view, vec3 worldCoord) {
    vec4 viewCoord = view * vec4(worldCoord, 1.0);
    viewCoord = viewCoord / viewCoord.w;
    return viewCoord.xyz;
}

vec2 viewToNDC(vec3 viewCoord) {
    vec4 ndcCoord = projection * vec4(viewCoord, 1.0);
    ndcCoord = ndcCoord / ndcCoord.w;
    return ndcCoord.xy;
}

vec2 ndcToScreen(vec2 ndc) {
    return (ndc + 1.0) / 2.0;
}

vec2 worldToScreen(mat4 view, vec3 worldCoord) {
    vec2 ndc = viewToNDC(worldToView(view, worldCoord));
    return ndcToScreen(ndc);
}

vec3 sampleNormal(sampler2D normalMap, vec2 sampleCoord) {
    return normalize(texture(normalMap, sampleCoord).xyz);
}

float sampleDepth(sampler2D depthMap, vec2 sampleCoord) {
    return texture(depthMap, sampleCoord).x;
}

float LinearizeDepth(float depth) {
    float z = depth * 2.0 - 1.0; // back to NDC
    return (2.0 * near * far) / (far + near - z * (far - near));
}

vec3 planeRayIntersection(vec3 rayOrigin, vec3 rayDirection, vec3 planeNormal, vec3 planePoint) {
    float t = dot(planeNormal, planePoint - rayOrigin) / dot(planeNormal, rayDirection);
    return rayOrigin + t * rayDirection;
}

float sobel(float tl, float t, float tr, float l, float c, float r, float bl, float b, float br) {
    float sobelX = tr + 2.0 * r + br - tl - 2.0 * l - bl;
    float sobelY = tl + 2.0 * t + tr - bl - 2.0 * b - br;
    return sqrt(sobelX * sobelX + sobelY * sobelY);
}

void main() {
    vec2 size = vec2(screenSize) / float(surfelSize);

    uint shaderIndex = uint(gl_GlobalInvocationID.y * size.x + gl_GlobalInvocationID.x);

    vec2 surfelCenterCoords = vec2(gl_GlobalInvocationID.xy) + vec2(0.5, 0.5);

    /************************

        tll -- tl -- tr -- trr
        |      |    / |     |
        |      |   c  |     |
        |      |  /   |     |
       bll -- (bl) -- br -- brr
        |      |      |     |
        |      |      |     |
        |      |      |     |
      bbll -- bbl -- bbr -- bbrr

    ************************/

    vec2 pixelCoordBottomBottomLeftLeft   = surfelSize * (surfelCenterCoords + vec2(-1.0, -1.0));
    vec2 pixelCoordBottomBottomLeft       = surfelSize * (surfelCenterCoords + vec2(0.0, -1.0));
    vec2 pixelCoordBottomBottomRight      = surfelSize * (surfelCenterCoords + vec2(1.0, -1.0));
    vec2 pixelCoordBottomBottomRightRight = surfelSize * (surfelCenterCoords + vec2(2.0, -1.0));
    vec2 pixelCoordBottomLeftLeft         = surfelSize * (surfelCenterCoords + vec2(-1.0, 0.0));
    vec2 pixelCoordBottomLeft             = surfelSize * (surfelCenterCoords + vec2(0.0, 0.0));
    vec2 pixelCoordBottomRight            = surfelSize * (surfelCenterCoords + vec2(1.0, 0.0));
    vec2 pixelCoordBottomRightRight       = surfelSize * (surfelCenterCoords + vec2(2.0, 0.0));
    vec2 pixelCoordTopLeftLeft            = surfelSize * (surfelCenterCoords + vec2(-1.0, 1.0));
    vec2 pixelCoordTopLeft                = surfelSize * (surfelCenterCoords + vec2(0.0, 1.0));
    vec2 pixelCoordTopRight               = surfelSize * (surfelCenterCoords + vec2(1.0, 1.0));
    vec2 pixelCoordTopRightRight          = surfelSize * (surfelCenterCoords + vec2(2.0, 1.0));
    // vec2 pixelCoordCenter     = surfelSize * (surfelCenterCoords + vec2(0.5, 0.5));

    vec2 pixelCoordBottomBottomLeftLeftNormalized   = pixelCoordBottomBottomLeftLeft / screenSize;
    vec2 pixelCoordBottomBottomLeftNormalized       = pixelCoordBottomBottomLeft / screenSize;
    vec2 pixelCoordBottomBottomRightNormalized      = pixelCoordBottomBottomRight / screenSize;
    vec2 pixelCoordBottomBottomRightRightNormalized = pixelCoordBottomBottomRightRight / screenSize;
    vec2 pixelCoordBottomLeftLeftNormalized         = pixelCoordBottomLeftLeft / screenSize;
    vec2 pixelCoordBottomLeftNormalized             = pixelCoordBottomLeft / screenSize;
    vec2 pixelCoordBottomRightNormalized            = pixelCoordBottomRight / screenSize;
    vec2 pixelCoordBottomRightRightNormalized       = pixelCoordBottomRightRight / screenSize;
    vec2 pixelCoordTopLeftLeftNormalized            = pixelCoordTopLeftLeft / screenSize;
    vec2 pixelCoordTopLeftNormalized                = pixelCoordTopLeft / screenSize;
    vec2 pixelCoordTopRightNormalized               = pixelCoordTopRight / screenSize;
    vec2 pixelCoordTopRightRightNormalized          = pixelCoordTopRightRight / screenSize;
    // vec2 pixelCoordCenterNormalized     = pixelCoordCenter / screenSize;

    // vec3 normalBottomLeft  = sampleNormal(normalMap, pixelCoordBottomLeft);
    // vec3 normalBottomRight = sampleNormal(normalMap, pixelCoordBottomRight);
    // vec3 normalTopLeft  = sampleNormal(normalMap, pixelCoordTopLeft);
    // vec3 normalTopRight = sampleNormal(normalMap, pixelCoordTopRight);
    // vec3 normalCenter     = sampleNormal(normalMap, pixelCoordCenter);

    // uint idBottomLeft  = uint(texture(idMap, pixelCoordBottomLeftNormalized).x);
    // uint idBottomRight = uint(texture(idMap, pixelCoordBottomRightNormalized).x);
    // uint idTopLeft  = uint(texture(idMap, pixelCoordTopLeftNormalized).x);
    // uint idTopRight = uint(texture(idMap, pixelCoordTopRightNormalized).x);
    // uint idCenter     = uint(texture(idMap, pixelCoordCenterNormalized).x);

    vec2 ndcBottomBottomLeftLeft   = 2.0 * pixelCoordBottomBottomLeftLeftNormalized - 1.0;
    vec2 ndcBottomBottomLeft       = 2.0 * pixelCoordBottomBottomLeftNormalized - 1.0;
    vec2 ndcBottomBottomRight      = 2.0 * pixelCoordBottomBottomRightNormalized - 1.0;
    vec2 ndcBottomBottomRightRight = 2.0 * pixelCoordBottomBottomRightRightNormalized - 1.0;
    vec2 ndcBottomLeftLeft         = 2.0 * pixelCoordBottomLeftLeftNormalized - 1.0;
    vec2 ndcBottomLeft             = 2.0 * pixelCoordBottomLeftNormalized - 1.0;
    vec2 ndcBottomRight            = 2.0 * pixelCoordBottomRightNormalized - 1.0;
    vec2 ndcBottomRightRight       = 2.0 * pixelCoordBottomRightRightNormalized - 1.0;
    vec2 ndcTopLeftLeft            = 2.0 * pixelCoordTopLeftLeftNormalized - 1.0;
    vec2 ndcTopLeft                = 2.0 * pixelCoordTopLeftNormalized - 1.0;
    vec2 ndcTopRight               = 2.0 * pixelCoordTopRightNormalized - 1.0;
    vec2 ndcTopRightRight          = 2.0 * pixelCoordTopRightRightNormalized - 1.0;
    // vec2 ndcCenter     = 2.0 * pixelCoordCenterNormalized - 1.0;

    float depthBottomBottomLeftLeft = sampleDepth(depthMap, pixelCoordBottomBottomLeftLeftNormalized);
    float depthBottomBottomLeft  = sampleDepth(depthMap, pixelCoordBottomBottomLeftNormalized);
    float depthBottomBottomRight = sampleDepth(depthMap, pixelCoordBottomBottomRightNormalized);
    float depthBottomBottomRightRight = sampleDepth(depthMap, pixelCoordBottomBottomRightRightNormalized);
    float depthBottomLeftLeft = sampleDepth(depthMap, pixelCoordBottomLeftLeftNormalized);
    float depthBottomLeft  = sampleDepth(depthMap, pixelCoordBottomLeftNormalized);
    float depthBottomRight = sampleDepth(depthMap, pixelCoordBottomRightNormalized);
    float depthBottomRightRight = sampleDepth(depthMap, pixelCoordBottomRightRightNormalized);
    float depthTopLeftLeft = sampleDepth(depthMap, pixelCoordTopLeftLeftNormalized);
    float depthTopLeft  = sampleDepth(depthMap, pixelCoordTopLeftNormalized);
    float depthTopRight = sampleDepth(depthMap, pixelCoordTopRightNormalized);
    float depthTopRightRight = sampleDepth(depthMap, pixelCoordTopRightRightNormalized);
    // float depthCenter     = sampleDepth(depthMap, pixelCoordCenterNormalized);

    vec3 viewCoordBottomBottomLeftLeft = ndcToView(ndcBottomBottomLeftLeft, depthBottomBottomLeftLeft);
    vec3 viewCoordBottomBottomLeft  = ndcToView(ndcBottomBottomLeft, depthBottomBottomLeft);
    vec3 viewCoordBottomBottomRight = ndcToView(ndcBottomBottomRight, depthBottomBottomRight);
    vec3 viewCoordBottomBottomRightRight = ndcToView(ndcBottomBottomRightRight, depthBottomBottomRightRight);
    vec3 viewCoordBottomLeftLeft = ndcToView(ndcBottomLeftLeft, depthBottomLeftLeft);
    vec3 viewCoordBottomLeft  = ndcToView(ndcBottomLeft, depthBottomLeft);
    vec3 viewCoordBottomRight = ndcToView(ndcBottomRight, depthBottomRight);
    vec3 viewCoordBottomRightRight = ndcToView(ndcBottomRightRight, depthBottomRightRight);
    vec3 viewCoordTopLeftLeft = ndcToView(ndcTopLeftLeft, depthTopLeftLeft);
    vec3 viewCoordTopLeft  = ndcToView(ndcTopLeft, depthTopLeft);
    vec3 viewCoordTopRight = ndcToView(ndcTopRight, depthTopRight);
    vec3 viewCoordTopRightRight = ndcToView(ndcTopRightRight, depthTopRightRight);
    // vec3 viewCoordCenter     = ndcToView(ndcCenter, depthCenter);

    // if (sobel(
    //         depthTopLeftLeft, depthTopLeft, depthTopRight,
    //         depthBottomLeftLeft, depthBottomLeft, depthBottomRight,
    //         depthBottomBottomLeftLeft, depthBottomBottomLeft, depthBottomRight
    //     ) > 0.005) {
    //     return;
    // }
    //
    // if (sobel(
    //         depthTopLeft, depthTopRight, depthTopRightRight,
    //         depthBottomLeft, depthBottomRight, depthBottomRightRight,
    //         depthBottomBottomLeft, depthBottomBottomRight, depthBottomBottomRightRight
    //     ) > 0.005) {
    //     return;
    // }

    // if (idBottomLeft != idBottomRight || idBottomRight != idTopRight || idTopRight != idTopLeft) {
    //     return;
    // }

    uint vertexIndexTopLeft     = shaderIndex * VERTICES_IN_A_QUAD + 0;
    uint vertexIndexTopRight    = shaderIndex * VERTICES_IN_A_QUAD + 1;
    uint vertexIndexBottomLeft  = shaderIndex * VERTICES_IN_A_QUAD + 2;
    uint vertexIndexBottomRight = shaderIndex * VERTICES_IN_A_QUAD + 3;

    vertices[vertexIndexTopLeft]    .position = viewToWorld(viewCoordTopLeft);
    vertices[vertexIndexTopRight]   .position = viewToWorld(viewCoordTopRight);
    vertices[vertexIndexBottomLeft] .position = viewToWorld(viewCoordBottomLeft);
    vertices[vertexIndexBottomRight].position = viewToWorld(viewCoordBottomRight);

    vertices[vertexIndexTopLeft] .color = vec3(1.0, 1.0, 1.0);
    vertices[vertexIndexTopRight].color = vec3(1.0, 1.0, 1.0);
    vertices[vertexIndexBottomLeft] .color = vec3(1.0, 1.0, 1.0);
    vertices[vertexIndexBottomRight].color = vec3(1.0, 1.0, 1.0);

    uint x = shaderIndex % uint(size.x);
    uint y = shaderIndex / uint(size.x);

    vertices[vertexIndexTopLeft] .texCoords    = worldToScreen(view, viewToWorld(viewCoordTopLeft));
    vertices[vertexIndexTopRight].texCoords    = worldToScreen(view, viewToWorld(viewCoordTopRight));
    vertices[vertexIndexBottomLeft] .texCoords = worldToScreen(view, viewToWorld(viewCoordBottomLeft));
    vertices[vertexIndexBottomRight].texCoords = worldToScreen(view, viewToWorld(viewCoordBottomRight));

    indices[shaderIndex * 6 + 0] = vertexIndexTopLeft;
    indices[shaderIndex * 6 + 1] = vertexIndexTopRight;
    indices[shaderIndex * 6 + 2] = vertexIndexBottomLeft;

    indices[shaderIndex * 6 + 3] = vertexIndexTopRight;
    indices[shaderIndex * 6 + 4] = vertexIndexBottomRight;
    indices[shaderIndex * 6 + 5] = vertexIndexBottomLeft;
}
