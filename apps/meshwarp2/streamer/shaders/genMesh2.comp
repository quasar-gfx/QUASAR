layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(binding = 0) uniform sampler2D positionMap;
layout(binding = 1) uniform sampler2D normalMap;
layout(binding = 2) uniform sampler2D idMap;
layout(binding = 3) uniform sampler2D depthMap;

struct Vertex {
    uint id;
    vec3 position;
    vec3 color;
    vec3 normal;
    vec2 texCoords;
    vec3 tangent;
    vec3 bitangent;
};

layout(std430, binding = 0) buffer VertexBuffer {
    Vertex vertices[];
};

layout(std430, binding = 1) buffer IndexBuffer {
    uint indices[];
};

layout(std430, binding = 2) buffer VertexBufferDepth {
    Vertex verticesDepth[];
};

uniform vec2 screenSize;

uniform mat4 view;
uniform mat4 projection;
uniform mat4 viewInverse;
uniform mat4 projectionInverse;

uniform float near;
uniform float far;

uniform int surfelSize;

uniform float threshold;

#define VERTICES_IN_A_QUAD  4
#define INDICES_IN_A_QUAD   6
#define NUM_SUB_QUADS       4

vec3 ndcToView(vec2 ndc, float depth) {
    vec4 ndcPos;
    ndcPos.xy = ndc;
    ndcPos.z = 2.0 * depth - 1.0;
    ndcPos.w = 1.0;

    vec4 viewCoord = projectionInverse * ndcPos;
    viewCoord = viewCoord / viewCoord.w;
    return viewCoord.xyz;
}

vec3 viewToWorld(vec3 viewspaceCoord) {
    vec4 worldCoord = viewInverse * vec4(viewspaceCoord, 1.0);
    worldCoord = worldCoord / worldCoord.w;
    return worldCoord.xyz;
}

vec3 worldToView(mat4 view, vec3 worldCoord) {
    vec4 viewCoord = view * vec4(worldCoord, 1.0);
    viewCoord = viewCoord / viewCoord.w;
    return viewCoord.xyz;
}

vec2 viewToNDC(vec3 viewCoord) {
    vec4 ndcCoord = projection * vec4(viewCoord, 1.0);
    ndcCoord = ndcCoord / ndcCoord.w;
    return ndcCoord.xy;
}

vec2 ndcToScreen(vec2 ndc) {
    return (ndc + 1.0) / 2.0;
}

vec2 worldToScreen(mat4 view, vec3 worldCoord) {
    vec2 ndc = viewToNDC(worldToView(view, worldCoord));
    return ndcToScreen(ndc);
}

vec3 sampleNormal(sampler2D normalMap, vec2 sampleCoord) {
    return normalize(texture(normalMap, sampleCoord).xyz);
}

float sampleDepth(sampler2D depthMap, vec2 sampleCoord) {
    float depth = texture(depthMap, sampleCoord).x;
    depth = clamp(depth, 0.0, 0.99999);
    return depth;
}

float LinearizeDepth(float depth) {
    float z = depth * 2.0 - 1.0; // back to NDC
    return (2.0 * near * far) / (far + near - z * (far - near));
}

float NormalizeDepth(float depth) {
    depth = clamp(depth, near, far);
    float z = (depth - near) / (far - near);
    return (1.0 - (1.0 / (1.0 + z * (far - near) / near)));
}

vec3 planeRayIntersection(vec3 rayOrigin, vec3 rayDirection, vec3 planePoint, vec3 planeNormal) {
    float denominator = dot(rayDirection, planeNormal);

    if (abs(denominator) < 0.0001) {
        return vec3(1.0/0.0, 1.0/0.0, 1.0/0.0);
    }

    float t = dot(planePoint - rayOrigin, planeNormal) / denominator;

    if (t < 0.0) {
        return vec3(1.0/0.0, 1.0/0.0, 1.0/0.0);
    }

    vec3 intersection = rayOrigin + t * rayDirection;

    return intersection;
}

void createSubQuad(
        vec3 viewCoordTopLeft, vec3 viewCoordTopRight, vec3 viewCoordBottomLeft, vec3 viewCoordBottomRight,
        float x, float y, vec2 size,
        uint shaderIndex, uint vertexOffset, uint indexOffset)
{
    /************************

            tl -- tr
            |   / |
            | /   |
            bl -- br

    ************************/

    uint vertexIndexTopLeft = shaderIndex * NUM_SUB_QUADS * VERTICES_IN_A_QUAD + vertexOffset + 0;
    vertices[vertexIndexTopLeft].position = viewToWorld(viewCoordTopLeft);
    vertices[vertexIndexTopLeft].color = vec3(1.0, 1.0, 1.0);
    vertices[vertexIndexTopLeft].texCoords = worldToScreen(view, viewToWorld(viewCoordTopLeft));

    uint vertexIndexTopRight = shaderIndex * NUM_SUB_QUADS * VERTICES_IN_A_QUAD + vertexOffset + 1;
    vertices[vertexIndexTopRight].position = viewToWorld(viewCoordTopRight);
    vertices[vertexIndexTopRight].color = vec3(1.0, 1.0, 1.0);
    vertices[vertexIndexTopRight].texCoords = worldToScreen(view, viewToWorld(viewCoordTopRight));

    uint vertexIndexBottomLeft = shaderIndex * NUM_SUB_QUADS * VERTICES_IN_A_QUAD + vertexOffset + 2;
    vertices[vertexIndexBottomLeft].position = viewToWorld(viewCoordBottomLeft);
    vertices[vertexIndexBottomLeft].color = vec3(1.0, 1.0, 1.0);
    vertices[vertexIndexBottomLeft].texCoords = worldToScreen(view, viewToWorld(viewCoordBottomLeft));

    uint vertexIndexBottomRight = shaderIndex * NUM_SUB_QUADS * VERTICES_IN_A_QUAD + vertexOffset + 3;
    vertices[vertexIndexBottomRight].position = viewToWorld(viewCoordBottomRight);
    vertices[vertexIndexBottomRight].color = vec3(1.0, 1.0, 1.0);
    vertices[vertexIndexBottomRight].texCoords = worldToScreen(view, viewToWorld(viewCoordBottomRight));

    indices[shaderIndex * NUM_SUB_QUADS * 6 + indexOffset + 0] = vertexIndexTopLeft;
    indices[shaderIndex * NUM_SUB_QUADS * 6 + indexOffset + 1] = vertexIndexTopRight;
    indices[shaderIndex * NUM_SUB_QUADS * 6 + indexOffset + 2] = vertexIndexBottomLeft;

    indices[shaderIndex * NUM_SUB_QUADS * 6 + indexOffset + 3] = vertexIndexTopRight;
    indices[shaderIndex * NUM_SUB_QUADS * 6 + indexOffset + 4] = vertexIndexBottomRight;
    indices[shaderIndex * NUM_SUB_QUADS * 6 + indexOffset + 5] = vertexIndexBottomLeft;
}

bool pointsLieOnLine(vec3 p1, vec3 p2, vec3 d, float epsilon) {
    // Avoid division by zero by checking if any component of the direction vector is zero
    bool checkX = abs(d.x) > epsilon;
    bool checkY = abs(d.y) > epsilon;
    bool checkZ = abs(d.z) > epsilon;

    float t1_x = checkX ? p1.x / d.x : 0.0;
    float t1_y = checkY ? p1.y / d.y : 0.0;
    float t1_z = checkZ ? p1.z / d.z : 0.0;

    float t2_x = checkX ? p2.x / d.x : 0.0;
    float t2_y = checkY ? p2.y / d.y : 0.0;
    float t2_z = checkZ ? p2.z / d.z : 0.0;

    // If a component of d is zero, only compare components that are not zero
    bool t1Consistent = (checkX && checkY) ? (abs(t1_x - t1_y) < epsilon) : true;
    t1Consistent = (checkX && checkZ) ? (t1Consistent && (abs(t1_x - t1_z) < epsilon)) : t1Consistent;
    t1Consistent = (checkY && checkZ) ? (t1Consistent && (abs(t1_y - t1_z) < epsilon)) : t1Consistent;

    bool t2Consistent = (checkX && checkY) ? (abs(t2_x - t2_y) < epsilon) : true;
    t2Consistent = (checkX && checkZ) ? (t2Consistent && (abs(t2_x - t2_z) < epsilon)) : t2Consistent;
    t2Consistent = (checkY && checkZ) ? (t2Consistent && (abs(t2_y - t2_z) < epsilon)) : t2Consistent;

    return t1Consistent && t2Consistent;
}


void main() {
    vec2 size = vec2(screenSize) / float(surfelSize);

    uint shaderIndex = uint(gl_GlobalInvocationID.y * size.x + gl_GlobalInvocationID.x);

    /**********************************

      (ptl)  ----   (pt) ----  (ptr)
        |            |           |
        |  - stl -  st  -  str - |
        |            |           |
     (pl)  - sl - (pc/sc) - sr - (pr)
        |            |           |
        |  - sbl -  sb  -  sbr - |
        |            |           |
      (pbl)  ----   (pb) ----  (pbr)

    **********************************/

    // get coords
    vec2 surfelCoordBottomLeft  = vec2(gl_GlobalInvocationID.xy);

    vec2 pixelCoordBottomLeft  = surfelSize * (surfelCoordBottomLeft + vec2(0.5, 0.5) + vec2(-1.0, -1.0));
    vec2 pixelCoordBottom      = surfelSize * (surfelCoordBottomLeft + vec2(0.5, 0.5) + vec2(+0.0, -1.0));
    vec2 pixelCoordBottomRight = surfelSize * (surfelCoordBottomLeft + vec2(0.5, 0.5) + vec2(+1.0, -1.0));
    vec2 pixelCoordLeft        = surfelSize * (surfelCoordBottomLeft + vec2(0.5, 0.5) + vec2(-1.0, +0.0));
    vec2 pixelCoordCenter      = surfelSize * (surfelCoordBottomLeft + vec2(0.5, 0.5) + vec2(+0.0, +0.0));
    vec2 pixelCoordRight       = surfelSize * (surfelCoordBottomLeft + vec2(0.5, 0.5) + vec2(+1.0, +0.0));
    vec2 pixelCoordTopLeft     = surfelSize * (surfelCoordBottomLeft + vec2(0.5, 0.5) + vec2(-1.0, +1.0));
    vec2 pixelCoordTop         = surfelSize * (surfelCoordBottomLeft + vec2(0.5, 0.5) + vec2(+0.0, +1.0));
    vec2 pixelCoordTopRight    = surfelSize * (surfelCoordBottomLeft + vec2(0.5, 0.5) + vec2(+1.0, +1.0));

    vec2 surfelCoordBottom      = surfelSize * (surfelCoordBottomLeft + vec2(0.0, 0.0) + vec2(0.5, 0.0));
    vec2 surfelCoordBottomRight = surfelSize * (surfelCoordBottomLeft + vec2(0.0, 0.0) + vec2(1.0, 0.0));
    vec2 surfelCoordLeft        = surfelSize * (surfelCoordBottomLeft + vec2(0.0, 0.0) + vec2(0.0, 0.5));
    vec2 surfelCoordCenter      = pixelCoordCenter;
    vec2 surfelCoordRight       = surfelSize * (surfelCoordBottomLeft + vec2(0.0, 0.0) + vec2(1.0, 0.5));
    vec2 surfelCoordTopLeft     = surfelSize * (surfelCoordBottomLeft + vec2(0.0, 0.0) + vec2(0.0, 1.0));
    vec2 surfelCoordTop         = surfelSize * (surfelCoordBottomLeft + vec2(0.0, 0.0) + vec2(0.5, 1.0));
    vec2 surfelCoordTopRight    = surfelSize * (surfelCoordBottomLeft + vec2(0.0, 0.0) + vec2(1.0, 1.0));

    // sample texture maps
    vec2 uvBottomLeft  = pixelCoordBottomLeft  / screenSize;
    vec2 uvBottom      = pixelCoordBottom      / screenSize;
    vec2 uvBottomRight = pixelCoordBottomRight / screenSize;
    vec2 uvLeft        = pixelCoordLeft        / screenSize;
    vec2 uvCenter      = pixelCoordCenter      / screenSize;
    vec2 uvRight       = pixelCoordRight       / screenSize;
    vec2 uvTopLeft     = pixelCoordTopLeft     / screenSize;
    vec2 uvTop         = pixelCoordTop         / screenSize;
    vec2 uvTopRight    = pixelCoordTopRight    / screenSize;

    float pixelDepthBottomLeft  = sampleDepth(depthMap, uvBottomLeft);
    float pixelDepthBottom      = sampleDepth(depthMap, uvBottom);
    float pixelDepthBottomRight = sampleDepth(depthMap, uvBottomRight);
    float pixelDepthLeft        = sampleDepth(depthMap, uvLeft);
    float pixelDepthCenter      = sampleDepth(depthMap, uvCenter);
    float pixelDepthRight       = sampleDepth(depthMap, uvRight);
    float pixelDepthTopLeft     = sampleDepth(depthMap, uvTopLeft);
    float pixelDepthTop         = sampleDepth(depthMap, uvTop);
    float pixelDepthTopRight    = sampleDepth(depthMap, uvTopRight);

    // project points to view space
    vec2 pixelNDCBottomLeft  = 2.0 * uvBottomLeft - 1.0;
    vec2 pixelNDCBottom      = 2.0 * uvBottom - 1.0;
    vec2 pixelNDCBottomRight = 2.0 * uvBottomRight - 1.0;
    vec2 pixelNDCLeft        = 2.0 * uvLeft - 1.0;
    vec2 pixelNDCCenter      = 2.0 * uvCenter - 1.0;
    vec2 pixelNDCRight       = 2.0 * uvRight - 1.0;
    vec2 pixelNDCTopLeft     = 2.0 * uvTopLeft - 1.0;
    vec2 pixelNDCTop         = 2.0 * uvTop - 1.0;
    vec2 pixelNDCTopRight    = 2.0 * uvTopRight - 1.0;

    vec2 surfelNDCBottomLeft  = 2.0 * (surfelCoordBottomLeft / screenSize) - 1.0;
    vec2 surfelNDCBottom      = 2.0 * (surfelCoordBottom / screenSize) - 1.0;
    vec2 surfelNDCBottomRight = 2.0 * (surfelCoordBottomRight / screenSize) - 1.0;
    vec2 surfelNDCLeft        = 2.0 * (surfelCoordLeft / screenSize) - 1.0;
    vec2 surfelNDCCenter      = 2.0 * (surfelCoordCenter / screenSize) - 1.0;
    vec2 surfelNDCRight       = 2.0 * (surfelCoordRight / screenSize) - 1.0;
    vec2 surfelNDCTopLeft     = 2.0 * (surfelCoordTopLeft / screenSize) - 1.0;
    vec2 surfelNDCTop         = 2.0 * (surfelCoordTop / screenSize) - 1.0;
    vec2 surfelNDCTopRight    = 2.0 * (surfelCoordTopRight / screenSize) - 1.0;

    vec3 pixelViewBottomLeft  = ndcToView(pixelNDCBottomLeft, pixelDepthBottomLeft);
    vec3 pixelViewBottom      = ndcToView(pixelNDCBottom, pixelDepthBottom);
    vec3 pixelViewBottomRight = ndcToView(pixelNDCBottomRight, pixelDepthBottomRight);
    vec3 pixelViewLeft        = ndcToView(pixelNDCLeft, pixelDepthLeft);
    vec3 pixelViewCenter      = ndcToView(pixelNDCCenter, pixelDepthCenter);
    vec3 pixelViewRight       = ndcToView(pixelNDCRight, pixelDepthRight);
    vec3 pixelViewTopLeft     = ndcToView(pixelNDCTopLeft, pixelDepthTopLeft);
    vec3 pixelViewTop         = ndcToView(pixelNDCTop, pixelDepthTop);
    vec3 pixelViewTopRight    = ndcToView(pixelNDCTopRight, pixelDepthTopRight);

    // mat3 B = mat3(
    //     1.0, 0.0, 0.0,
    //     0.0, 1.0, 0.0,
    //     surfelNDCCenter.x / near, surfelNDCCenter.y / near, 1.0
    // );
    mat3 B = mat3(
        1.0, 0.0, 0.0,
        0.0, 1.0, 0.0,
        0.0, 0.0, 1.0
    );
    // B = transpose(B);
    mat3 Binv = inverse(B);

    vec3 pixelCoordQFSBottomLeft  = B * pixelViewBottomLeft;
    vec3 pixelCoordQFSBottom      = B * pixelViewBottom;
    vec3 pixelCoordQFSBottomRight = B * pixelViewBottomRight;
    vec3 pixelCoordQFSLeft        = B * pixelViewLeft;
    vec3 pixelCoordQFSCenter      = B * pixelViewCenter;
    vec3 pixelCoordQFSRight       = B * pixelViewRight;
    vec3 pixelCoordQFSTopLeft     = B * pixelViewTopLeft;
    vec3 pixelCoordQFSTop         = B * pixelViewTop;
    vec3 pixelCoordQFSTopRight    = B * pixelViewTopRight;

    vec3 surfelQFSCenter          = pixelCoordQFSCenter;

    /**********************************

      (ptl)  ----   (pt) ----  (ptr)
        |            |           |
        |  - stl -  st  -  str - |
        |            |           |
     (pl)  - sl - (pc/sc) - sr - (pr)
        |            |           |
        |  - sbl -  sb  -  sbr - |
        |            |           |
      (pbl)  ----   (pb) ----  (pbr)

    **********************************/

    // sample normal map
    vec3 pixelNormalBottomLeft = sampleNormal(normalMap, uvBottomLeft);
    vec3 pixelNormalBottom = sampleNormal(normalMap, uvBottom);
    vec3 pixelNormalBottomRight = sampleNormal(normalMap, uvBottomRight);
    vec3 pixelNormalLeft = sampleNormal(normalMap, uvLeft);
    vec3 pixelNormalCenter = sampleNormal(normalMap, uvCenter);
    vec3 pixelNormalRight = sampleNormal(normalMap, uvRight);
    vec3 pixelNormalTopLeft = sampleNormal(normalMap, uvTopLeft);
    vec3 pixelNormalTop = sampleNormal(normalMap, uvTop);
    vec3 pixelNormalTopRight = sampleNormal(normalMap, uvTopRight);

    // find plane points
    vec3 rayOrigin = vec3(0.0, 0.0, 0.0);
    vec3 rayDirection;

    rayDirection = normalize(ndcToView(surfelNDCBottomLeft, 1.0) - rayOrigin);
    vec3 surfelQFSBottomLeftPlane = planeRayIntersection(rayOrigin, rayDirection, pixelCoordQFSCenter, pixelNormalCenter);
    vec3 surfelQFSBottomLeftPlanePixelBottomLeft = planeRayIntersection(rayOrigin, rayDirection, pixelCoordQFSBottomLeft, pixelNormalBottomLeft);
    vec3 surfelQFSBottomLeftPlanePixelBottom = planeRayIntersection(rayOrigin, rayDirection, pixelCoordQFSBottom, pixelNormalBottom);
    vec3 surfelQFSBottomLeftPlanePixelLeft = planeRayIntersection(rayOrigin, rayDirection, pixelCoordQFSLeft, pixelNormalLeft);

    rayDirection = normalize(ndcToView(surfelNDCBottom, 1.0) - rayOrigin);
    vec3 surfelQFSBottomPlane = planeRayIntersection(rayOrigin, rayDirection, pixelCoordQFSCenter, pixelNormalCenter);
    vec3 surfelQFSBottomPlanePixelBottom = planeRayIntersection(rayOrigin, rayDirection, pixelCoordQFSBottom, pixelNormalBottom);

    rayDirection = normalize(ndcToView(surfelNDCBottomRight, 1.0) - rayOrigin);
    vec3 surfelQFSBottomRightPlane = planeRayIntersection(rayOrigin, rayDirection, pixelCoordQFSCenter, pixelNormalCenter);
    vec3 surfelQFSBottomRightPlanePixelBottomRight = planeRayIntersection(rayOrigin, rayDirection, pixelCoordQFSBottomRight, pixelNormalBottomRight);
    vec3 surfelQFSBottomRightPlanePixelBottom = planeRayIntersection(rayOrigin, rayDirection, pixelCoordQFSBottom, pixelNormalBottom);
    vec3 surfelQFSBottomRightPlanePixelRight = planeRayIntersection(rayOrigin, rayDirection, pixelCoordQFSRight, pixelNormalRight);

    rayDirection = normalize(ndcToView(surfelNDCLeft, 1.0) - rayOrigin);
    vec3 surfelQFSLeftPlane = planeRayIntersection(rayOrigin, rayDirection, pixelCoordQFSCenter, pixelNormalCenter);
    vec3 surfelQFSLeftPlanePixelLeft = planeRayIntersection(rayOrigin, rayDirection, pixelCoordQFSLeft, pixelNormalLeft);

    rayDirection = normalize(ndcToView(surfelNDCRight, 1.0) - rayOrigin);
    vec3 surfelQFSRightPlane = planeRayIntersection(rayOrigin, rayDirection, pixelCoordQFSCenter, pixelNormalCenter);
    vec3 surfelQFSRightPlanePixelRight = planeRayIntersection(rayOrigin, rayDirection, pixelCoordQFSRight, pixelNormalRight);

    rayDirection = normalize(ndcToView(surfelNDCTopLeft, 1.0) - rayOrigin);
    vec3 surfelQFSTopLeftPlane = planeRayIntersection(rayOrigin, rayDirection, pixelCoordQFSCenter, pixelNormalCenter);
    vec3 surfelQFSTopLeftPlanePixelTopLeft = planeRayIntersection(rayOrigin, rayDirection, pixelCoordQFSTopLeft, pixelNormalTopLeft);
    vec3 surfelQFSTopLeftPlanePixelLeft = planeRayIntersection(rayOrigin, rayDirection, pixelCoordQFSLeft, pixelNormalLeft);
    vec3 surfelQFSTopLeftPlanePixelTop = planeRayIntersection(rayOrigin, rayDirection, pixelCoordQFSTop, pixelNormalTop);

    rayDirection = normalize(ndcToView(surfelNDCTop, 1.0) - rayOrigin);
    vec3 surfelQFSTopPlane = planeRayIntersection(rayOrigin, rayDirection, pixelCoordQFSCenter, pixelNormalCenter);
    vec3 surfelQFSTopPlanePixelTop = planeRayIntersection(rayOrigin, rayDirection, pixelCoordQFSTop, pixelNormalTop);

    rayDirection = normalize(ndcToView(surfelNDCTopRight, 1.0) - rayOrigin);
    vec3 surfelQFSTopRightPlane = planeRayIntersection(rayOrigin, rayDirection, pixelCoordQFSCenter, pixelNormalCenter);
    vec3 surfelQFSTopRightPlanePixelTopRight = planeRayIntersection(rayOrigin, rayDirection, pixelCoordQFSTopRight, pixelNormalTopRight);
    vec3 surfelQFSTopRightPlanePixelTop = planeRayIntersection(rayOrigin, rayDirection, pixelCoordQFSTop, pixelNormalTop);
    vec3 surfelQFSTopRightPlanePixelRight = planeRayIntersection(rayOrigin, rayDirection, pixelCoordQFSRight, pixelNormalRight);

    // adjust points
    float dist1, dist2, dist3, minDist;

    vec3 surfelQFSBottomLeft;
    // find plane with closest distance to surfel point
    dist1 = NormalizeDepth(distance(surfelQFSBottomLeftPlane.z, surfelQFSBottomLeftPlanePixelBottomLeft.z));
    dist2 = NormalizeDepth(distance(surfelQFSBottomLeftPlane.z, surfelQFSBottomLeftPlanePixelBottom.z));
    dist3 = NormalizeDepth(distance(surfelQFSBottomLeftPlane.z, surfelQFSBottomLeftPlanePixelLeft.z));
    minDist = min(dist1, min(dist2, dist3));
    if (minDist <= threshold) {
        float surfelDepthBottomLeft = pixelDepthCenter;
        float n = 1;
        if (dist1 <= threshold) {
            surfelDepthBottomLeft += pixelDepthBottomLeft;
            n++;
        }
        if (dist2 <= threshold) {
            surfelDepthBottomLeft += pixelDepthBottom;
            n++;
        }
        if (dist3 <= threshold) {
            surfelDepthBottomLeft += pixelDepthLeft;
            n++;
        }
        surfelDepthBottomLeft /= n;
        vec3 surfelQFSBottomLeftInterp = B * ndcToView(surfelNDCBottomLeft, surfelDepthBottomLeft);
        surfelQFSBottomLeft = surfelQFSBottomLeftInterp;
    }
    else {
        surfelQFSBottomLeft = surfelQFSBottomLeftPlane;
    }

    float surfelDepthBottom = (pixelDepthCenter + pixelDepthBottom) / 2;
    vec3 surfelQFSBottom = B * ndcToView(surfelNDCBottom, surfelDepthBottom);
    if (NormalizeDepth(distance(surfelQFSBottomPlane.z, surfelQFSBottomPlanePixelBottom.z)) >= threshold) {
        surfelQFSBottom = surfelQFSBottomPlane;
    }

    vec3 surfelQFSBottomRight;
    // find plane with closest distance to surfel point
    dist1 = NormalizeDepth(distance(surfelQFSBottomRightPlane.z, surfelQFSBottomRightPlanePixelBottomRight.z));
    dist2 = NormalizeDepth(distance(surfelQFSBottomRightPlane.z, surfelQFSBottomRightPlanePixelBottom.z));
    dist3 = NormalizeDepth(distance(surfelQFSBottomRightPlane.z, surfelQFSBottomRightPlanePixelRight.z));
    minDist = min(dist1, min(dist2, dist3));
    if (minDist <= threshold) {
        float surfelDepthBottomRight = pixelDepthCenter;
        float n = 1;
        if (dist1 <= threshold) {
            surfelDepthBottomRight += pixelDepthBottomRight;
            n++;
        }
        if (dist2 <= threshold) {
            surfelDepthBottomRight += pixelDepthBottom;
            n++;
        }
        if (dist3 <= threshold) {
            surfelDepthBottomRight += pixelDepthRight;
            n++;
        }
        surfelDepthBottomRight /= n;
        vec3 surfelQFSBottomRightInterp = B * ndcToView(surfelNDCBottomRight, surfelDepthBottomRight);
        surfelQFSBottomRight = surfelQFSBottomRightInterp;
    }
    else {
        surfelQFSBottomRight = surfelQFSBottomRightPlane;
    }

    float surfelDepthLeft = (pixelDepthCenter + pixelDepthLeft) / 2;
    vec3 surfelQFSLeft = B * ndcToView(surfelNDCLeft, surfelDepthLeft);
    if (NormalizeDepth(distance(surfelQFSLeftPlane.z, surfelQFSLeftPlanePixelLeft.z)) >= threshold) {
        surfelQFSLeft = surfelQFSLeftPlane;
    }
    float surfelDepthRight = (pixelDepthCenter + pixelDepthRight) / 2;
    vec3 surfelQFSRight = B * ndcToView(surfelNDCRight, surfelDepthRight);
    if (NormalizeDepth(distance(surfelQFSRightPlane.z, surfelQFSRightPlanePixelRight.z)) >= threshold) {
        surfelQFSRight = surfelQFSRightPlane;
    }

    vec3 surfelQFSTopLeft;
    // find plane with closest distance to surfel point
    dist1 = NormalizeDepth(distance(surfelQFSTopLeftPlane.z, surfelQFSTopLeftPlanePixelTopLeft.z));
    dist2 = NormalizeDepth(distance(surfelQFSTopLeftPlane.z, surfelQFSTopLeftPlanePixelTop.z));
    dist3 = NormalizeDepth(distance(surfelQFSTopLeftPlane.z, surfelQFSTopLeftPlanePixelLeft.z));
    minDist = min(dist1, min(dist2, dist3));
    if (minDist <= threshold) {
        float surfelDepthTopLeft = pixelDepthCenter;
        float n = 1;
        if (dist1 <= threshold) {
            surfelDepthTopLeft += pixelDepthTopLeft;
            n++;
        }
        if (dist2 <= threshold) {
            surfelDepthTopLeft += pixelDepthTop;
            n++;
        }
        if (dist3 <= threshold) {
            surfelDepthTopLeft += pixelDepthLeft;
            n++;
        }
        surfelDepthTopLeft /= n;
        vec3 surfelQFSTopLeftInterp = B * ndcToView(surfelNDCTopLeft, surfelDepthTopLeft);
        surfelQFSTopLeft = surfelQFSTopLeftInterp;
    }
    else {
        surfelQFSTopLeft = surfelQFSTopLeftPlane;
    }

    float surfelDepthTop = (pixelDepthCenter + pixelDepthTop) / 2;
    vec3 surfelQFSTop = B * ndcToView(surfelNDCTop, surfelDepthTop);
    if (NormalizeDepth(distance(surfelQFSTopPlane.z, surfelQFSTopPlanePixelTop.z)) >= threshold) {
        surfelQFSTop = surfelQFSTopPlane;
    }

    vec3 surfelQFSTopRight;
    // find plane with closest distance to surfel point
    dist1 = NormalizeDepth(distance(surfelQFSTopRightPlane.z, surfelQFSTopRightPlanePixelTopRight.z));
    dist2 = NormalizeDepth(distance(surfelQFSTopRightPlane.z, surfelQFSTopRightPlanePixelTop.z));
    dist3 = NormalizeDepth(distance(surfelQFSTopRightPlane.z, surfelQFSTopRightPlanePixelRight.z));
    minDist = min(dist1, min(dist2, dist3));
    if (minDist <= threshold) {
        float surfelDepthTopRight = pixelDepthCenter;
        float n = 1;
        if (dist1 <= threshold) {
            surfelDepthTopRight += pixelDepthTopRight;
            n++;
        }
        if (dist2 <= threshold) {
            surfelDepthTopRight += pixelDepthTop;
            n++;
        }
        if (dist3 <= threshold) {
            surfelDepthTopRight += pixelDepthRight;
            n++;
        }
        surfelDepthTopRight /= n;
        vec3 surfelQFSTopRightInterp = B * ndcToView(surfelNDCTopRight, surfelDepthTopRight);
        surfelQFSTopRight = surfelQFSTopRightInterp;
    }
    else {
        surfelQFSTopRight = surfelQFSTopRightPlane;
    }

    vec3 surfelViewBottomLeft  = Binv * surfelQFSBottomLeft;
    vec3 surfelViewBottom      = Binv * surfelQFSBottom;
    vec3 surfelViewBottomRight = Binv * surfelQFSBottomRight;
    vec3 surfelViewLeft        = Binv * surfelQFSLeft;
    vec3 surfelViewCenter      = Binv * surfelQFSCenter;
    vec3 surfelViewRight       = Binv * surfelQFSRight;
    vec3 surfelViewTopLeft     = Binv * surfelQFSTopLeft;
    vec3 surfelViewTop         = Binv * surfelQFSTop;
    vec3 surfelViewTopRight    = Binv * surfelQFSTopRight;

    uint x = shaderIndex % uint(size.x);
    uint y = shaderIndex / uint(size.x);

    /**********************

     (stl) - (st) - str
        |     |     |
      (sl) - (sc) - sr
        |     |     |
       sbl - sb - sbr

    **********************/
    createSubQuad(
        surfelViewTopLeft, surfelViewTop, surfelViewLeft, surfelViewCenter,
        x, y + 0.5, size,
        shaderIndex, 0 * VERTICES_IN_A_QUAD, 0 * INDICES_IN_A_QUAD
    );

    /**********************

       stl - (st) - (str)
        |     |       |
        sl - (sc) - (sr)
        |     |       |
       sbl -  sb  -  sbr

    **********************/
    createSubQuad(
        surfelViewTop, surfelViewTopRight, surfelViewCenter, surfelViewRight,
        x + 0.5, y + 0.5, size,
        shaderIndex, 1 * VERTICES_IN_A_QUAD, 1 * INDICES_IN_A_QUAD
    );

    /**********************

        stl -  st - str
        |      |     |
       (sl) - (sc) - sr
        |      |     |
      (sbl) - (sb) - sbr

    **********************/
    createSubQuad(
        surfelViewLeft, surfelViewCenter, surfelViewBottomLeft, surfelViewBottom,
        x, y, size,
        shaderIndex, 2 * VERTICES_IN_A_QUAD, 2 * INDICES_IN_A_QUAD
    );

    /**********************

        stl -  st - str
        |      |     |
        sl - (sc) - (sr)
        |      |     |
       sbl - (sb) - (sbr)

    **********************/
    createSubQuad(
        surfelViewCenter, surfelViewRight, surfelViewBottom, surfelViewBottomRight,
        x + 0.5, y, size,
        shaderIndex, 3 * VERTICES_IN_A_QUAD, 3 * INDICES_IN_A_QUAD
    );

    verticesDepth[shaderIndex].position = viewToWorld(pixelViewCenter);
    verticesDepth[shaderIndex].color = vec3(1.0, 1.0, 1.0);
    verticesDepth[shaderIndex].texCoords = worldToScreen(view, viewToWorld(pixelViewCenter));
}
