layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(binding = 0) uniform sampler2D positionMap;
layout(binding = 1) uniform sampler2D normalMap;
layout(binding = 2) uniform sampler2D idMap;
layout(binding = 3) uniform sampler2D depthMap;

layout(std430, binding = 0) buffer VertexBuffer {
    vec4 vertices[];
};

layout(std430, binding = 1) buffer IndexBuffer {
    uint indices[];
};

uniform vec2 screenSize;

uniform mat4 viewInverse;
uniform mat4 projectionInverse;

uniform float near;
uniform float far;

uniform int surfelSize;

#define VERTICES_IN_A_QUAD 4

vec3 ndcToView(vec2 ndc, float depth) {
    vec4 ndcPos;
    ndcPos.xy = ndc;
    ndcPos.z = 2.0 * depth - 1.0;
    ndcPos.w = 1.0;

    vec4 viewCoord = projectionInverse * ndcPos;
    viewCoord = viewCoord / viewCoord.w;
    return viewCoord.xyz;
}

vec3 viewToWorld(vec3 viewspaceCoord) {
    vec4 worldCoord = viewInverse * vec4(viewspaceCoord, 1.0);
    worldCoord = worldCoord / worldCoord.w;
    return worldCoord.xyz;
}

vec3 sampleNormal(sampler2D normalMap, ivec2 pixelCoord) {
    vec2 sampleCoord = (vec2(pixelCoord) + 0.5) / screenSize;
    return texture(normalMap, sampleCoord).xyz;
}

float sampleDepth(sampler2D depthMap, ivec2 pixelCoord) {
    vec2 sampleCoord = (vec2(pixelCoord) + 0.5) / screenSize;
    return texture(depthMap, sampleCoord).x;
}

vec3 planeRayIntersection(vec3 rayOrigin, vec3 rayDirection, vec3 planeNormal, vec3 planePoint) {
    float t = dot(planeNormal, planePoint - rayOrigin) / dot(planeNormal, rayDirection);
    return rayOrigin + t * rayDirection;
}

void main() {
    vec2 size = vec2(screenSize) / float(surfelSize);

    uint shaderIndex = uint(gl_GlobalInvocationID.y * size.x + gl_GlobalInvocationID.x);

    ivec2 surfelCoords = ivec2(gl_GlobalInvocationID.xy);

    /************************

            ul -- ur
            |    / |
            |   c  |
            |  /   |
       -->  ll -- lr

    ************************/

    ivec2 pixelCoordLowerLeft  = ivec2(surfelSize * (surfelCoords + vec2(0.0, 0.0)));
    ivec2 pixelCoordLowerRight = ivec2(surfelSize * (surfelCoords + vec2(1.0, 0.0)));
    ivec2 pixelCoordUpperLeft  = ivec2(surfelSize * (surfelCoords + vec2(0.0, 1.0)));
    ivec2 pixelCoordUpperRight = ivec2(surfelSize * (surfelCoords + vec2(1.0, 1.0)));
    ivec2 pixelCoordCenter     = ivec2(surfelSize * (surfelCoords + vec2(0.5, 0.5)));

    vec2 pixelCoordLowerLeftNormalized  = pixelCoordLowerLeft / screenSize;
    vec2 pixelCoordLowerRightNormalized = pixelCoordLowerRight / screenSize;
    vec2 pixelCoordUpperLeftNormalized  = pixelCoordUpperLeft / screenSize;
    vec2 pixelCoordUpperRightNormalized = pixelCoordUpperRight / screenSize;
    vec2 pixelCoordCenterNormalized     = pixelCoordCenter / screenSize;

    // vec3 positionUpperLeft  = texture(positionMap, pixelCoordUpperLeft / screenSize).xyz;
    // vec3 positionUpperRight = texture(positionMap, pixelCoordUpperRight / screenSize).xyz;
    // vec3 positionLowerLeft  = texture(positionMap, pixelCoordLowerLeft / screenSize).xyz;
    // vec3 positionLowerRight = texture(positionMap, pixelCoordLowerRight / screenSize).xyz;
    // vec3 positionCenter     = texture(positionMap, pixelCoordCenter / screenSize).xyz;

    vec3 normalLowerLeft  = sampleNormal(normalMap, pixelCoordLowerLeft);
    vec3 normalLowerRight = sampleNormal(normalMap, pixelCoordLowerRight);
    vec3 normalUpperLeft  = sampleNormal(normalMap, pixelCoordUpperLeft);
    vec3 normalUpperRight = sampleNormal(normalMap, pixelCoordUpperRight);
    vec3 normalCenter     = sampleNormal(normalMap, pixelCoordCenter);

    vec3 avgNormal = (normalLowerLeft + normalLowerRight + normalUpperLeft + normalUpperRight) / 4.0;
    avgNormal = normalize(avgNormal);

    uint idLowerLeft  = uint(texture(idMap, pixelCoordLowerLeftNormalized).x);
    uint idLowerRight = uint(texture(idMap, pixelCoordLowerRightNormalized).x);
    uint idUpperLeft  = uint(texture(idMap, pixelCoordUpperLeftNormalized).x);
    uint idUpperRight = uint(texture(idMap, pixelCoordUpperRightNormalized).x);
    uint idCenter     = uint(texture(idMap, pixelCoordCenterNormalized).x);

    float depthLowerLeft  = sampleDepth(depthMap, pixelCoordLowerLeft);
    float depthLowerRight = sampleDepth(depthMap, pixelCoordLowerRight);
    float depthUpperLeft  = sampleDepth(depthMap, pixelCoordUpperLeft);
    float depthUpperRight = sampleDepth(depthMap, pixelCoordUpperRight);
    float depthCenter     = sampleDepth(depthMap, pixelCoordCenter);

    vec2 ndcLowerLeft  = 2.0 * pixelCoordLowerLeftNormalized - 1.0;
    vec2 ndcLowerRight = 2.0 * pixelCoordLowerRightNormalized - 1.0;
    vec2 ndcUpperLeft  = 2.0 * pixelCoordUpperLeftNormalized - 1.0;
    vec2 ndcUpperRight = 2.0 * pixelCoordUpperRightNormalized - 1.0;
    vec2 ndcCenter     = 2.0 * pixelCoordCenterNormalized - 1.0;

    vec3 viewCoordLowerLeft  = ndcToView(ndcLowerLeft, depthLowerLeft);
    vec3 viewCoordLowerRight = ndcToView(ndcLowerRight, depthLowerRight);
    vec3 viewCoordUpperLeft  = ndcToView(ndcUpperLeft, depthUpperLeft);
    vec3 viewCoordUpperRight = ndcToView(ndcUpperRight, depthUpperRight);
    vec3 viewCoordCenter     = ndcToView(ndcCenter, depthCenter);

    // get quad normal
    // vec3 v1 = viewCoordLowerLeft - viewCoordUpperLeft;
    // vec3 v2 = viewCoordUpperRight - viewCoordUpperLeft;
    // vec3 quadNormal1 = normalize(cross(v1, v2));
    // if (dot(quadNormal1, avgNormal) < 0.9) {
    //     return;
    // }

    // vec3 v3 = viewCoordUpperRight - viewCoordLowerRight;
    // vec3 v4 = viewCoordLowerLeft - viewCoordLowerRight;
    // vec3 quadNormal2 = normalize(cross(v3, v4));
    // if (dot(quadNormal2, avgNormal) < 0.9) {
    //     return;
    // }

    viewCoordLowerLeft  = ndcToView(ndcLowerLeft, depthLowerLeft);
    viewCoordLowerRight = ndcToView(ndcLowerRight, depthLowerRight);
    viewCoordUpperLeft  = ndcToView(ndcUpperLeft, depthUpperLeft);
    viewCoordUpperRight = ndcToView(ndcUpperRight, depthUpperRight);
    if (idLowerLeft != idLowerRight || idLowerRight != idUpperRight || idUpperRight != idUpperLeft) {
        float avgDepth = 0.0;
        int n = 0;
        for (int y = pixelCoordLowerLeft.y; y <= pixelCoordUpperLeft.y; y++) {
            for (int x = pixelCoordUpperLeft.x; x <= pixelCoordUpperRight.x; x++) {
                avgDepth += sampleDepth(depthMap, ivec2(x, y));
                n++;
            }
        }
        avgDepth /= float(n);

        vec3 avgNormal = vec3(0.0);
        n = 0;
        for (int y = pixelCoordLowerLeft.y; y <= pixelCoordUpperLeft.y; y++) {
            for (int x = pixelCoordUpperLeft.x; x <= pixelCoordUpperRight.x; x++) {
                avgNormal += sampleNormal(normalMap, ivec2(x, y));
                n++;
            }
        }
        avgNormal /= float(n);
        avgNormal = normalize(avgNormal);

        vec3 planeNormal = avgNormal;
        vec3 planePoint = ndcToView(ndcCenter, avgDepth);

        vec3 rayOrigin = vec3(0.0);
        viewCoordUpperLeft = planeRayIntersection(rayOrigin, viewCoordUpperLeft, planeNormal, planePoint);
        viewCoordUpperRight = planeRayIntersection(rayOrigin, viewCoordUpperRight, planeNormal, planePoint);
        viewCoordLowerLeft = planeRayIntersection(rayOrigin, viewCoordLowerLeft, planeNormal, planePoint);
        viewCoordLowerRight = planeRayIntersection(rayOrigin, viewCoordLowerRight, planeNormal, planePoint);
    }

    vec4 vertexCoordUpperLeft  = vec4(viewToWorld(viewCoordUpperLeft), 1.0);
    vec4 vertexCoordUpperRight = vec4(viewToWorld(viewCoordUpperRight), 1.0);
    vec4 vertexCoordLowerLeft  = vec4(viewToWorld(viewCoordLowerLeft), 1.0);
    vec4 vertexCoordLowerRight = vec4(viewToWorld(viewCoordLowerRight), 1.0);

    uint vertexIndexUpperLeft  = shaderIndex * VERTICES_IN_A_QUAD + 0;
    uint vertexIndexUpperRight = shaderIndex * VERTICES_IN_A_QUAD + 1;
    uint vertexIndexLowerLeft  = shaderIndex * VERTICES_IN_A_QUAD + 2;
    uint vertexIndexLowerRight = shaderIndex * VERTICES_IN_A_QUAD + 3;

    vertices[vertexIndexUpperLeft]  = vertexCoordUpperLeft;
    vertices[vertexIndexUpperRight] = vertexCoordUpperRight;
    vertices[vertexIndexLowerLeft]  = vertexCoordLowerLeft;
    vertices[vertexIndexLowerRight] = vertexCoordLowerRight;

    indices[shaderIndex * 6 + 0] = vertexIndexUpperLeft;
    indices[shaderIndex * 6 + 1] = vertexIndexUpperRight;
    indices[shaderIndex * 6 + 2] = vertexIndexLowerLeft;

    indices[shaderIndex * 6 + 3] = vertexIndexUpperRight;
    indices[shaderIndex * 6 + 4] = vertexIndexLowerRight;
    indices[shaderIndex * 6 + 5] = vertexIndexLowerLeft;
}
