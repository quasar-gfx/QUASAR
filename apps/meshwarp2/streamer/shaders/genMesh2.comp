layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(binding = 0) uniform sampler2D positionMap;
layout(binding = 1) uniform sampler2D normalMap;
layout(binding = 2) uniform sampler2D idMap;
layout(binding = 3) uniform sampler2D depthMap;

struct Vertex {
    uint id;
    vec3 position;
    vec3 color;
    vec3 normal;
    vec2 texCoords;
    vec3 tangent;
    vec3 bitangent;
};

layout(std430, binding = 0) buffer VertexBuffer {
    Vertex vertices[];
};

layout(std430, binding = 1) buffer IndexBuffer {
    uint indices[];
};

layout(std430, binding = 2) buffer VertexBufferDepth {
    Vertex verticesDepth[];
};

struct Plane {
    vec3 normal;
    float constant;
};

struct Quad {
    vec3 bottomLeft;
    vec3 bottomRight;
    vec3 topLeft;
    vec3 topRight;
};

struct Quad2D {
    vec2 bottomLeft;
    vec2 bottomRight;
    vec2 topLeft;
    vec2 topRight;
};

// a Quad subdivided into 4 smaller Quads
struct MultiQuad {
    vec3 bottomLeft;
    vec3 bottom;
    vec3 bottomRight;
    vec3 left;
    vec3 center;
    vec3 right;
    vec3 topLeft;
    vec3 top;
    vec3 topRight;
};

struct MultiQuad2D {
    vec2 bottomLeft;
    vec2 bottom;
    vec2 bottomRight;
    vec2 left;
    vec2 center;
    vec2 right;
    vec2 topLeft;
    vec2 top;
    vec2 topRight;
};

uniform vec2 screenSize;

uniform mat4 view;
uniform mat4 projection;
uniform mat4 viewInverse;
uniform mat4 projectionInverse;

uniform float near;
uniform float far;

uniform int surfelSize;

uniform bool doOrientationCorrection;
uniform float distanceThreshold;

const float epilson = 1e-5;

const vec3 origin = vec3(0.0, 0.0, 0.0);
const vec3 forward = vec3(0.0, 0.0, -1.0);
const vec3 up = vec3(0.0, 1.0, 0.0);
const vec3 left = vec3(-1.0, 0.0, 0.0);
const vec3 right = vec3(1.0, 0.0, 0.0);

// define the corners of the near and far planes in normalized device coordinates
const vec3 nearCornersNDC[4] = vec3[4](
    vec3(-1, -1, -1), vec3(1, -1, -1), vec3(-1, 1, -1), vec3(1, 1, -1)
);
const vec3 farCornersNDC[4] = vec3[4](
    vec3(-1, -1, 1), vec3(1, -1, 1), vec3(-1, 1, 1), vec3(1, 1, 1)
);
// define the corners of the near and far planes in view space
vec3 nearPointsView[4], farPointsView[4];

#define MAX_DEPTH 0.9999

#define VERTICES_IN_A_QUAD  4
#define INDICES_IN_A_QUAD   6
#define NUM_SUB_QUADS       4

#define BOTTOM_LEFT  0
#define BOTTOM       1
#define BOTTOM_RIGHT 2
#define LEFT         3
#define CENTER       4
#define RIGHT        5
#define TOP_LEFT     6
#define TOP          7
#define TOP_RIGHT    8

vec3 ndcToView(mat4 projectionInverse, vec2 ndc, float depth) {
    depth = clamp(depth, 0.0, MAX_DEPTH);

    vec4 ndcPos;
    ndcPos.xy = ndc;
    ndcPos.z = 2.0 * depth - 1.0;
    ndcPos.w = 1.0;

    vec4 viewCoord = projectionInverse * ndcPos;
    viewCoord = viewCoord / viewCoord.w;
    return viewCoord.xyz;
}

vec3 viewToWorld(mat4 viewInverse, vec3 viewCoord) {
    vec4 worldCoord = viewInverse * vec4(viewCoord, 1.0);
    worldCoord = worldCoord / worldCoord.w;
    return worldCoord.xyz;
}

vec3 worldToView(mat4 view, vec3 worldCoord) {
    vec4 viewCoord = view * vec4(worldCoord, 1.0);
    viewCoord = viewCoord / viewCoord.w;
    return viewCoord.xyz;
}

vec2 viewToNDC(mat4 projection, vec3 viewCoord) {
    vec4 ndcCoord = projection * vec4(viewCoord, 1.0);
    ndcCoord = ndcCoord / ndcCoord.w;
    return ndcCoord.xy;
}

vec2 ndcToScreen(vec2 ndc) {
    return (ndc + 1.0) / 2.0;
}

vec2 worldToScreen(mat4 view, mat4 projection, vec3 worldCoord) {
    vec2 ndc = viewToNDC(projection, worldToView(view, worldCoord));
    return ndcToScreen(ndc);
}

float sampleDepth(sampler2D depthMap, vec2 sampleCoord) {
    float depth = texture(depthMap, sampleCoord).x;
    depth = clamp(depth, 0.0, MAX_DEPTH);
    return depth;
}

float LinearizeDepth(float depth) {
    float z = depth * 2.0 - 1.0; // back to NDC
    return (2.0 * near * far) / (far + near - z * (far - near));
}

float NormalizeDepth(float depth) {
    depth = clamp(depth, near, far);
    float z = (depth - near) / (far - near);
    return (1.0 - (1.0 / (1.0 + z * (far - near) / near)));
}

vec3 sampleNormal(sampler2D normalMap, vec2 sampleCoord) {
    vec3 normal = normalize(texture(normalMap, sampleCoord).xyz);
    // skybox normals might be NaN
    if (any(isnan(normal))) {
        return -forward;
    }
    return normal;
}

vec3 normalToView(mat4 view, vec3 normalWorld) {
    // extract the rotation part of the view matrix
    mat3 rotationMatrix = mat3(view);
    return normalize(rotationMatrix * normalWorld);
}

bool planeIntersectsQuad(Plane plane, vec3 p[4]) {
    // get signed distance of each point to the plane
    float signedDist1 = dot(plane.normal, p[0]) + plane.constant;
    float signedDist2 = dot(plane.normal, p[1]) + plane.constant;
    float signedDist3 = dot(plane.normal, p[2]) + plane.constant;
    float signedDist4 = dot(plane.normal, p[3]) + plane.constant;

    // check if all points are on the same side of the plane
    if ((signedDist1 > epilson && signedDist2 > epilson && signedDist3 > epilson && signedDist4 > epilson) ||
        (signedDist1 < -epilson && signedDist2 < -epilson && signedDist3 < -epilson && signedDist4 < -epilson)) {
        return false;
    }
    // else, the plane intersects the quad
    return true;
}

bool planeIntersectsNearFar(mat4 viewInverse, mat4 projectionInverse, vec3 planePointView, vec3 planeNormalView) {
    Plane plane = Plane(planeNormalView, -dot(planeNormalView, planePointView));

    // check if the plane intersects any of the four points of the near and far clipping planes
    bool intersectsNear = planeIntersectsQuad(plane, nearPointsView);
    bool intersectsFar = planeIntersectsQuad(plane, farPointsView);

    return intersectsNear || intersectsFar;
}

vec3 adjustNormal(
    vec3 normalView,
    vec3 pixelPointView
) {
    if (planeIntersectsNearFar(viewInverse, projectionInverse, pixelPointView, normalView)) {
        /************************

            2 ---------- 3
            |            |
            |   2 -- 3   |
            |   |    |   |
            |   0 -- 1   |
            |            |
            0 ---------- 1

        ************************/
        // get normals of diagonally opposite points of near and far clipping planes
        vec3 normal1 = normalize(cross(nearPointsView[1] - nearPointsView[0], farPointsView[2] - nearPointsView[0])); // up
        vec3 normal2 = normalize(cross(nearPointsView[2] - nearPointsView[3], farPointsView[1] - nearPointsView[3])); // down
        vec3 normal3 = normalize(cross(farPointsView[1] - nearPointsView[0], nearPointsView[2] - nearPointsView[0])); // left
        vec3 normal4 = normalize(cross(nearPointsView[3] - nearPointsView[1], farPointsView[0] - nearPointsView[1])); // right

        // find closest normal to normalView
        float dot1 = dot(normalView, normal1);
        float dot2 = dot(normalView, normal2);
        float dot3 = dot(normalView, normal3);
        float dot4 = dot(normalView, normal4);
        float maxDot = max(max(dot1, dot2), max(dot3, dot4));
        if (maxDot == dot1) {
            return normal1;
        } else if (maxDot == dot2) {
            return normal2;
        } else if (maxDot == dot3) {
            return normal3;
        } else if (maxDot == dot4) {
            return normal4;
        }
    }
    return normalView;
}

vec3 planeRayIntersection(vec3 rayOrigin, vec3 rayDirection, vec3 planePoint, vec3 planeNormal) {
    float denominator = dot(rayDirection, planeNormal);
    if (abs(denominator) < epilson) {
        return vec3(1.0/0.0, 1.0/0.0, 1.0/0.0);
    }

    float t = dot(planePoint - rayOrigin, planeNormal) / denominator;
    if (t < 0.0) {
        return vec3(1.0/0.0, 1.0/0.0, 1.0/0.0);
    }

    vec3 intersection = rayOrigin + t * rayDirection;
    return intersection;
}

vec3 findQuadPointCorner(
    vec2 surfelNDC,
    vec3 surfelViewPlane,
    vec3 surfelViewPlanePixelNeighbor1,
    vec3 surfelViewPlanePixelNeighbor2,
    vec3 surfelViewPlanePixelNeighbor3,
    float pixelDepthCenter, float pixelDepthNeighbor1, float pixelDepthNeighbor2, float pixelDepthNeighbor3
) {
    vec3 resultCoord;

    // find distance of depth of point on this pixel's plane to the same point on neighboring pixels' planes
    float dist1 = NormalizeDepth(distance(surfelViewPlane.z, surfelViewPlanePixelNeighbor1.z));
    float dist2 = NormalizeDepth(distance(surfelViewPlane.z, surfelViewPlanePixelNeighbor2.z));
    float dist3 = NormalizeDepth(distance(surfelViewPlane.z, surfelViewPlanePixelNeighbor3.z));

    // add the contribution of each neighboring pixel to interpolated depth, if it is within distanceThreshold
    float depth = pixelDepthCenter;
    int n = 1;
    if (dist1 <= distanceThreshold) {
        depth += pixelDepthNeighbor1; n++;
    }
    if (dist2 <= distanceThreshold) {
        depth += pixelDepthNeighbor2; n++;
    }
    if (dist3 <= distanceThreshold) {
        depth += pixelDepthNeighbor3; n++;
    }
    depth /= float(n);

    // only return the interpolated point if all neighboring pixels' depths are within distanceThreshold
    vec3 surfelViewBottomLeftInterp = ndcToView(projectionInverse, surfelNDC, depth);
    if (n >= 3) {
        return surfelViewBottomLeftInterp;
    }
    return surfelViewPlane;
}

vec3 findQuadPointEdge(
    vec2 surfelNDC,
    vec3 surfelViewPlane,
    vec3 surfelViewPlanePixelNeighbor,
    float pixelDepthCenter, float pixelDepthNeighbor
) {
    // return interpolated point if neighboring pixel's depth is within distanceThreshold
    if (NormalizeDepth(distance(surfelViewPlane.z, surfelViewPlanePixelNeighbor.z)) <= distanceThreshold) {
        float depth = (pixelDepthCenter + pixelDepthNeighbor) / 2.0;
        return ndcToView(projectionInverse, surfelNDC, depth);
    }
    return surfelViewPlane;
}

void storeQuad(
        Quad quad,
        uint shaderIndex, uint vertexOffset, uint indexOffset)
{
    /************************

            tl -- tr
            |   / |
            | /   |
            bl -- br

    ************************/

    uint vertexIndexTopLeft = shaderIndex * NUM_SUB_QUADS * VERTICES_IN_A_QUAD + vertexOffset + 0;
    vertices[vertexIndexTopLeft].position = viewToWorld(viewInverse, quad.topLeft);
    vertices[vertexIndexTopLeft].color = vec3(1.0, 1.0, 1.0);
    vertices[vertexIndexTopLeft].texCoords = worldToScreen(view, projection, viewToWorld(viewInverse, quad.topLeft));

    uint vertexIndexTopRight = shaderIndex * NUM_SUB_QUADS * VERTICES_IN_A_QUAD + vertexOffset + 1;
    vertices[vertexIndexTopRight].position = viewToWorld(viewInverse, quad.topRight);
    vertices[vertexIndexTopRight].color = vec3(1.0, 1.0, 1.0);
    vertices[vertexIndexTopRight].texCoords = worldToScreen(view, projection, viewToWorld(viewInverse, quad.topRight));

    uint vertexIndexBottomLeft = shaderIndex * NUM_SUB_QUADS * VERTICES_IN_A_QUAD + vertexOffset + 2;
    vertices[vertexIndexBottomLeft].position = viewToWorld(viewInverse, quad.bottomLeft);
    vertices[vertexIndexBottomLeft].color = vec3(1.0, 1.0, 1.0);
    vertices[vertexIndexBottomLeft].texCoords = worldToScreen(view, projection, viewToWorld(viewInverse, quad.bottomLeft));

    uint vertexIndexBottomRight = shaderIndex * NUM_SUB_QUADS * VERTICES_IN_A_QUAD + vertexOffset + 3;
    vertices[vertexIndexBottomRight].position = viewToWorld(viewInverse, quad.bottomRight);
    vertices[vertexIndexBottomRight].color = vec3(1.0, 1.0, 1.0);
    vertices[vertexIndexBottomRight].texCoords = worldToScreen(view, projection, viewToWorld(viewInverse, quad.bottomRight));

    indices[shaderIndex * NUM_SUB_QUADS * 6 + indexOffset + 0] = vertexIndexTopLeft;
    indices[shaderIndex * NUM_SUB_QUADS * 6 + indexOffset + 1] = vertexIndexTopRight;
    indices[shaderIndex * NUM_SUB_QUADS * 6 + indexOffset + 2] = vertexIndexBottomLeft;

    indices[shaderIndex * NUM_SUB_QUADS * 6 + indexOffset + 3] = vertexIndexTopRight;
    indices[shaderIndex * NUM_SUB_QUADS * 6 + indexOffset + 4] = vertexIndexBottomRight;
    indices[shaderIndex * NUM_SUB_QUADS * 6 + indexOffset + 5] = vertexIndexBottomLeft;
}

void main() {
    // transform the corners of the near and far clipping planes to view space
    for (int i = 0; i < 4; i++) {
        nearPointsView[i] = ndcToView(projectionInverse, nearCornersNDC[i].xy, nearCornersNDC[i].z);
        farPointsView[i] = ndcToView(projectionInverse, farCornersNDC[i].xy, farCornersNDC[i].z);
    }

    vec2 size = vec2(screenSize) / float(surfelSize);

    uint shaderIndex = uint(gl_GlobalInvocationID.y * size.x + gl_GlobalInvocationID.x);

    /**********************************

      (ptl)  ----   (pt) ----  (ptr)
        |            |           |
        |  - stl -  st  -  str - |
        |            |           |
     (pl)  - sl - (pc/sc) - sr - (pr)
        |            |           |
        |  - sbl -  sb  -  sbr - |
        |            |           |
      (pbl)  ----   (pb) ----  (pbr)

    **********************************/


    // get coords
    vec2 surfelCoordBottomLeft  = vec2(gl_GlobalInvocationID.xy);

    MultiQuad2D pixelsCoords;
    pixelsCoords.bottomLeft  = surfelSize * (surfelCoordBottomLeft + vec2(0.5, 0.5) + vec2(-1.0, -1.0));
    pixelsCoords.bottom      = surfelSize * (surfelCoordBottomLeft + vec2(0.5, 0.5) + vec2(+0.0, -1.0));
    pixelsCoords.bottomRight = surfelSize * (surfelCoordBottomLeft + vec2(0.5, 0.5) + vec2(+1.0, -1.0));
    pixelsCoords.left        = surfelSize * (surfelCoordBottomLeft + vec2(0.5, 0.5) + vec2(-1.0, +0.0));
    pixelsCoords.center      = surfelSize * (surfelCoordBottomLeft + vec2(0.5, 0.5) + vec2(+0.0, +0.0));
    pixelsCoords.right       = surfelSize * (surfelCoordBottomLeft + vec2(0.5, 0.5) + vec2(+1.0, +0.0));
    pixelsCoords.topLeft     = surfelSize * (surfelCoordBottomLeft + vec2(0.5, 0.5) + vec2(-1.0, +1.0));
    pixelsCoords.top         = surfelSize * (surfelCoordBottomLeft + vec2(0.5, 0.5) + vec2(+0.0, +1.0));
    pixelsCoords.topRight    = surfelSize * (surfelCoordBottomLeft + vec2(0.5, 0.5) + vec2(+1.0, +1.0));

    MultiQuad2D surfelCoords;
    surfelCoords.bottomLeft  = surfelSize * (surfelCoordBottomLeft + vec2(0.0, 0.0) + vec2(0.0, 0.0));
    surfelCoords.bottom      = surfelSize * (surfelCoordBottomLeft + vec2(0.0, 0.0) + vec2(0.5, 0.0));
    surfelCoords.bottomRight = surfelSize * (surfelCoordBottomLeft + vec2(0.0, 0.0) + vec2(1.0, 0.0));
    surfelCoords.left        = surfelSize * (surfelCoordBottomLeft + vec2(0.0, 0.0) + vec2(0.0, 0.5));
    surfelCoords.center      = pixelsCoords.center;
    surfelCoords.right       = surfelSize * (surfelCoordBottomLeft + vec2(0.0, 0.0) + vec2(1.0, 0.5));
    surfelCoords.topLeft     = surfelSize * (surfelCoordBottomLeft + vec2(0.0, 0.0) + vec2(0.0, 1.0));
    surfelCoords.top         = surfelSize * (surfelCoordBottomLeft + vec2(0.0, 0.0) + vec2(0.5, 1.0));
    surfelCoords.topRight    = surfelSize * (surfelCoordBottomLeft + vec2(0.0, 0.0) + vec2(1.0, 1.0));

    // sample texture maps
    MultiQuad2D uvs;
    uvs.bottomLeft  = pixelsCoords.bottomLeft  / screenSize;
    uvs.bottom      = pixelsCoords.bottom      / screenSize;
    uvs.bottomRight = pixelsCoords.bottomRight / screenSize;
    uvs.left        = pixelsCoords.left        / screenSize;
    uvs.center      = pixelsCoords.center      / screenSize;
    uvs.right       = pixelsCoords.right       / screenSize;
    uvs.topLeft     = pixelsCoords.topLeft     / screenSize;
    uvs.top         = pixelsCoords.top         / screenSize;
    uvs.topRight    = pixelsCoords.topRight    / screenSize;

    float pixelDepthBottomLeft  = sampleDepth(depthMap, uvs.bottomLeft);
    float pixelDepthBottom      = sampleDepth(depthMap, uvs.bottom);
    float pixelDepthBottomRight = sampleDepth(depthMap, uvs.bottomRight);
    float pixelDepthLeft        = sampleDepth(depthMap, uvs.left);
    float pixelDepthCenter      = sampleDepth(depthMap, uvs.center);
    float pixelDepthRight       = sampleDepth(depthMap, uvs.right);
    float pixelDepthTopLeft     = sampleDepth(depthMap, uvs.topLeft);
    float pixelDepthTop         = sampleDepth(depthMap, uvs.top);
    float pixelDepthTopRight    = sampleDepth(depthMap, uvs.topRight);

    // project points to view space
    MultiQuad2D pixelNDCs;
    pixelNDCs.bottomLeft  = 2.0 * (pixelsCoords.bottomLeft / screenSize) - 1.0;
    pixelNDCs.bottom      = 2.0 * (pixelsCoords.bottom / screenSize) - 1.0;
    pixelNDCs.bottomRight = 2.0 * (pixelsCoords.bottomRight / screenSize) - 1.0;
    pixelNDCs.left        = 2.0 * (pixelsCoords.left / screenSize) - 1.0;
    pixelNDCs.center      = 2.0 * (pixelsCoords.center / screenSize) - 1.0;
    pixelNDCs.right       = 2.0 * (pixelsCoords.right / screenSize) - 1.0;
    pixelNDCs.topLeft     = 2.0 * (pixelsCoords.topLeft / screenSize) - 1.0;
    pixelNDCs.top         = 2.0 * (pixelsCoords.top / screenSize) - 1.0;
    pixelNDCs.topRight    = 2.0 * (pixelsCoords.topRight / screenSize) - 1.0;

    MultiQuad2D surfelNDCs;
    surfelNDCs.bottomLeft  = 2.0 * (surfelCoords.bottomLeft / screenSize) - 1.0;
    surfelNDCs.bottom      = 2.0 * (surfelCoords.bottom / screenSize) - 1.0;
    surfelNDCs.bottomRight = 2.0 * (surfelCoords.bottomRight / screenSize) - 1.0;
    surfelNDCs.left        = 2.0 * (surfelCoords.left / screenSize) - 1.0;
    surfelNDCs.center      = 2.0 * (surfelCoords.center / screenSize) - 1.0;
    surfelNDCs.right       = 2.0 * (surfelCoords.right / screenSize) - 1.0;
    surfelNDCs.topLeft     = 2.0 * (surfelCoords.topLeft / screenSize) - 1.0;
    surfelNDCs.top         = 2.0 * (surfelCoords.top / screenSize) - 1.0;
    surfelNDCs.topRight    = 2.0 * (surfelCoords.topRight / screenSize) - 1.0;

    MultiQuad pixelCoordsView;
    pixelCoordsView.bottomLeft  = ndcToView(projectionInverse, pixelNDCs.bottomLeft, pixelDepthBottomLeft);
    pixelCoordsView.bottom      = ndcToView(projectionInverse, pixelNDCs.bottom, pixelDepthBottom);
    pixelCoordsView.bottomRight = ndcToView(projectionInverse, pixelNDCs.bottomRight, pixelDepthBottomRight);
    pixelCoordsView.left        = ndcToView(projectionInverse, pixelNDCs.left, pixelDepthLeft);
    pixelCoordsView.center      = ndcToView(projectionInverse, pixelNDCs.center, pixelDepthCenter);
    pixelCoordsView.right       = ndcToView(projectionInverse, pixelNDCs.right, pixelDepthRight);
    pixelCoordsView.topLeft     = ndcToView(projectionInverse, pixelNDCs.topLeft, pixelDepthTopLeft);
    pixelCoordsView.top         = ndcToView(projectionInverse, pixelNDCs.top, pixelDepthTop);
    pixelCoordsView.topRight    = ndcToView(projectionInverse, pixelNDCs.topRight, pixelDepthTopRight);

    vec3 surfelViewCenter = pixelCoordsView.center;

    /**********************************

      (ptl)  ----   (pt) ----  (ptr)
        |            |           |
        |  - stl -  st  -  str - |
        |            |           |
     (pl)  - sl - (pc/sc) - sr - (pr)
        |            |           |
        |  - sbl -  sb  -  sbr - |
        |            |           |
      (pbl)  ----   (pb) ----  (pbr)

    **********************************/

    // sample normal map
    vec3 pixelNormalBottomLeft  = normalToView(view, sampleNormal(normalMap, uvs.bottomLeft));
    vec3 pixelNormalBottom      = normalToView(view, sampleNormal(normalMap, uvs.bottom));
    vec3 pixelNormalBottomRight = normalToView(view, sampleNormal(normalMap, uvs.bottomRight));
    vec3 pixelNormalLeft        = normalToView(view, sampleNormal(normalMap, uvs.left));
    vec3 pixelNormalCenter      = normalToView(view, sampleNormal(normalMap, uvs.center));
    vec3 pixelNormalRight       = normalToView(view, sampleNormal(normalMap, uvs.right));
    vec3 pixelNormalTopLeft     = normalToView(view, sampleNormal(normalMap, uvs.topLeft));
    vec3 pixelNormalTop         = normalToView(view, sampleNormal(normalMap, uvs.top));
    vec3 pixelNormalTopRight    = normalToView(view, sampleNormal(normalMap, uvs.topRight));

    if (doOrientationCorrection) {
        pixelNormalBottomLeft  = adjustNormal(pixelNormalBottomLeft, pixelCoordsView.bottomLeft);
        pixelNormalBottom      = adjustNormal(pixelNormalBottom, pixelCoordsView.bottom);
        pixelNormalBottomRight = adjustNormal(pixelNormalBottomRight, pixelCoordsView.bottomRight);
        pixelNormalLeft        = adjustNormal(pixelNormalLeft, pixelCoordsView.left);
        pixelNormalCenter      = adjustNormal(pixelNormalCenter, pixelCoordsView.center);
        pixelNormalRight       = adjustNormal(pixelNormalRight, pixelCoordsView.right);
        pixelNormalTopLeft     = adjustNormal(pixelNormalTopLeft, pixelCoordsView.topLeft);
        pixelNormalTop         = adjustNormal(pixelNormalTop, pixelCoordsView.top);
        pixelNormalTopRight    = adjustNormal(pixelNormalTopRight, pixelCoordsView.topRight);
    }

    // project all points to the far plane
    MultiQuad surfelCoordsFarPlane;
    surfelCoordsFarPlane.bottomLeft  = ndcToView(projectionInverse, surfelNDCs.bottomLeft, 1.0);
    surfelCoordsFarPlane.bottom      = ndcToView(projectionInverse, surfelNDCs.bottom, 1.0);
    surfelCoordsFarPlane.bottomRight = ndcToView(projectionInverse, surfelNDCs.bottomRight, 1.0);
    surfelCoordsFarPlane.left        = ndcToView(projectionInverse, surfelNDCs.left, 1.0);
    surfelCoordsFarPlane.center      = ndcToView(projectionInverse, surfelNDCs.center, 1.0);
    surfelCoordsFarPlane.right       = ndcToView(projectionInverse, surfelNDCs.right, 1.0);
    surfelCoordsFarPlane.topLeft     = ndcToView(projectionInverse, surfelNDCs.topLeft, 1.0);
    surfelCoordsFarPlane.top         = ndcToView(projectionInverse, surfelNDCs.top, 1.0);
    surfelCoordsFarPlane.topRight    = ndcToView(projectionInverse, surfelNDCs.topRight, 1.0);

    // find all points on a ray going through each coordinate intersecting a plane defined by neighboring pixels
    vec3 rayDirection;

    rayDirection = normalize(surfelCoordsFarPlane.bottomLeft - origin);
    vec3 surfelViewBottomLeftPlane = planeRayIntersection(origin, rayDirection, pixelCoordsView.center, pixelNormalCenter);
    vec3 surfelViewBottomLeftPlanePixelBottomLeft = planeRayIntersection(origin, rayDirection, pixelCoordsView.bottomLeft, pixelNormalBottomLeft);
    vec3 surfelViewBottomLeftPlanePixelBottom = planeRayIntersection(origin, rayDirection, pixelCoordsView.bottom, pixelNormalBottom);
    vec3 surfelViewBottomLeftPlanePixelLeft = planeRayIntersection(origin, rayDirection, pixelCoordsView.left, pixelNormalLeft);

    rayDirection = normalize(surfelCoordsFarPlane.bottom - origin);
    vec3 surfelViewBottomPlane = planeRayIntersection(origin, rayDirection, pixelCoordsView.center, pixelNormalCenter);
    vec3 surfelViewBottomPlanePixelBottom = planeRayIntersection(origin, rayDirection, pixelCoordsView.bottom, pixelNormalBottom);

    rayDirection = normalize(surfelCoordsFarPlane.bottomRight - origin);
    vec3 surfelViewBottomRightPlane = planeRayIntersection(origin, rayDirection, pixelCoordsView.center, pixelNormalCenter);
    vec3 surfelViewBottomRightPlanePixelBottomRight = planeRayIntersection(origin, rayDirection, pixelCoordsView.bottomRight, pixelNormalBottomRight);
    vec3 surfelViewBottomRightPlanePixelBottom = planeRayIntersection(origin, rayDirection, pixelCoordsView.bottom, pixelNormalBottom);
    vec3 surfelViewBottomRightPlanePixelRight = planeRayIntersection(origin, rayDirection, pixelCoordsView.right, pixelNormalRight);

    rayDirection = normalize(surfelCoordsFarPlane.left - origin);
    vec3 surfelViewLeftPlane = planeRayIntersection(origin, rayDirection, pixelCoordsView.center, pixelNormalCenter);
    vec3 surfelViewLeftPlanePixelLeft = planeRayIntersection(origin, rayDirection, pixelCoordsView.left, pixelNormalLeft);

    rayDirection = normalize(surfelCoordsFarPlane.right - origin);
    vec3 surfelViewRightPlane = planeRayIntersection(origin, rayDirection, pixelCoordsView.center, pixelNormalCenter);
    vec3 surfelViewRightPlanePixelRight = planeRayIntersection(origin, rayDirection, pixelCoordsView.right, pixelNormalRight);

    rayDirection = normalize(surfelCoordsFarPlane.topLeft - origin);
    vec3 surfelViewTopLeftPlane = planeRayIntersection(origin, rayDirection, pixelCoordsView.center, pixelNormalCenter);
    vec3 surfelViewTopLeftPlanePixelTopLeft = planeRayIntersection(origin, rayDirection, pixelCoordsView.topLeft, pixelNormalTopLeft);
    vec3 surfelViewTopLeftPlanePixelLeft = planeRayIntersection(origin, rayDirection, pixelCoordsView.left, pixelNormalLeft);
    vec3 surfelViewTopLeftPlanePixelTop = planeRayIntersection(origin, rayDirection, pixelCoordsView.top, pixelNormalTop);

    rayDirection = normalize(surfelCoordsFarPlane.top - origin);
    vec3 surfelViewTopPlane = planeRayIntersection(origin, rayDirection, pixelCoordsView.center, pixelNormalCenter);
    vec3 surfelViewTopPlanePixelTop = planeRayIntersection(origin, rayDirection, pixelCoordsView.top, pixelNormalTop);

    rayDirection = normalize(surfelCoordsFarPlane.topRight - origin);
    vec3 surfelViewTopRightPlane = planeRayIntersection(origin, rayDirection, pixelCoordsView.center, pixelNormalCenter);
    vec3 surfelViewTopRightPlanePixelTopRight = planeRayIntersection(origin, rayDirection, pixelCoordsView.topRight, pixelNormalTopRight);
    vec3 surfelViewTopRightPlanePixelTop = planeRayIntersection(origin, rayDirection, pixelCoordsView.top, pixelNormalTop);
    vec3 surfelViewTopRightPlanePixelRight = planeRayIntersection(origin, rayDirection, pixelCoordsView.right, pixelNormalRight);

    /**********************************

      (ptl)  ----   (pt) ----  (ptr)
        |            |           |
        |  - stl -  st  -  str - |
        |            |           |
     (pl)  - sl - (pc/sc) - sr - (pr)
        |            |           |
        |  - sbl -  sb  -  sbr - |
        |            |           |
      (pbl)  ----   (pb) ----  (pbr)

    **********************************/

    // adjust points
    vec3 surfelViewBottomLeft = findQuadPointCorner(
        surfelNDCs.bottomLeft,
        surfelViewBottomLeftPlane,
        surfelViewBottomLeftPlanePixelBottomLeft, surfelViewBottomLeftPlanePixelBottom, surfelViewBottomLeftPlanePixelLeft,
        pixelDepthCenter, pixelDepthBottomLeft, pixelDepthBottom, pixelDepthLeft
    );

    vec3 surfelViewBottom = findQuadPointEdge(
        surfelNDCs.bottom,
        surfelViewBottomPlane,
        surfelViewBottomPlanePixelBottom,
        pixelDepthCenter, pixelDepthBottom
    );

    vec3 surfelViewBottomRight = findQuadPointCorner(
        surfelNDCs.bottomRight,
        surfelViewBottomRightPlane,
        surfelViewBottomRightPlanePixelBottomRight, surfelViewBottomRightPlanePixelBottom, surfelViewBottomRightPlanePixelRight,
        pixelDepthCenter, pixelDepthBottomRight, pixelDepthBottom, pixelDepthRight
    );

    vec3 surfelViewLeft = findQuadPointEdge(
        surfelNDCs.left,
        surfelViewLeftPlane,
        surfelViewLeftPlanePixelLeft,
        pixelDepthCenter, pixelDepthLeft
    );

    vec3 surfelViewRight = findQuadPointEdge(
        surfelNDCs.right,
        surfelViewRightPlane,
        surfelViewRightPlanePixelRight,
        pixelDepthCenter, pixelDepthRight
    );

    vec3 surfelViewTopLeft = findQuadPointCorner(
        surfelNDCs.topLeft,
        surfelViewTopLeftPlane,
        surfelViewTopLeftPlanePixelTopLeft, surfelViewTopLeftPlanePixelTop, surfelViewTopLeftPlanePixelLeft,
        pixelDepthCenter, pixelDepthTopLeft, pixelDepthTop, pixelDepthLeft
    );

    vec3 surfelViewTop = findQuadPointEdge(
        surfelNDCs.top,
        surfelViewTopPlane,
        surfelViewTopPlanePixelTop,
        pixelDepthCenter, pixelDepthTop
    );

    vec3 surfelViewTopRight = findQuadPointCorner(
        surfelNDCs.topRight,
        surfelViewTopRightPlane,
        surfelViewTopRightPlanePixelTopRight, surfelViewTopRightPlanePixelTop, surfelViewTopRightPlanePixelRight,
        pixelDepthCenter, pixelDepthTopRight, pixelDepthTop, pixelDepthRight
    );

    /**********************

     (stl) - (st) - str
        |     |     |
      (sl) - (sc) - sr
        |     |     |
       sbl - sb - sbr

    **********************/
    Quad subQuadTopLeft = Quad(
        surfelViewLeft, surfelViewCenter, surfelViewTopLeft, surfelViewTop
    );
    storeQuad(
        subQuadTopLeft,
        shaderIndex, 0 * VERTICES_IN_A_QUAD, 0 * INDICES_IN_A_QUAD
    );

    /**********************

       stl - (st) - (str)
        |     |       |
        sl - (sc) - (sr)
        |     |       |
       sbl -  sb  -  sbr

    **********************/
    Quad subQuadTopRight = Quad(
        surfelViewCenter, surfelViewRight, surfelViewTop, surfelViewTopRight
    );
    storeQuad(
        subQuadTopRight,
        shaderIndex, 1 * VERTICES_IN_A_QUAD, 1 * INDICES_IN_A_QUAD
    );
    /**********************

        stl -  st - str
        |      |     |
       (sl) - (sc) - sr
        |      |     |
      (sbl) - (sb) - sbr

    **********************/
    Quad subQuadBottomLeft = Quad(
        surfelViewBottomLeft, surfelViewBottom, surfelViewLeft, surfelViewCenter
    );
    storeQuad(
        subQuadBottomLeft,
        shaderIndex, 2 * VERTICES_IN_A_QUAD, 2 * INDICES_IN_A_QUAD
    );

    /**********************

        stl -  st - str
        |      |     |
        sl - (sc) - (sr)
        |      |     |
       sbl - (sb) - (sbr)

    **********************/
    Quad subQuadBottomRight = Quad(
        surfelViewBottom, surfelViewBottomRight, surfelViewCenter, surfelViewRight
    );
    storeQuad(
        subQuadBottomRight,
        shaderIndex, 3 * VERTICES_IN_A_QUAD, 3 * INDICES_IN_A_QUAD
    );

    verticesDepth[shaderIndex].position = viewToWorld(viewInverse, pixelCoordsView.center);
    verticesDepth[shaderIndex].color = vec3(1.0, 1.0, 1.0);
    verticesDepth[shaderIndex].texCoords = worldToScreen(view, projection, viewToWorld(viewInverse, pixelCoordsView.center));
}
